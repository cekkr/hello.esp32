{"files": {"../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_wasi.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_wasi.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_wasi.h\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_core.h\"\n#include \"m3_exception.h\"\n\n#if defined(d_m3HasUVWASI)\n#include \"uvwasi.h\"\n#endif\n\n\nd_m3BeginExternC\n\ntypedef struct m3_wasi_context_t\n{\n    i32                     exit_code;\n    u32                     argc;\n    ccstr_t *               argv;\n} m3_wasi_context_t;\n\nM3Result    m3_LinkWASI             (IM3Module io_module);\n\n#if defined(d_m3HasUVWASI)\n\nM3Result    m3_LinkWASIWithOptions  (IM3Module io_module, uvwasi_options_t uvwasiOptions);\n\n#endif\n\nm3_wasi_context_t* m3_GetWasiContext();\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_compile.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_compile.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_compile.c\n//\n//  Created by Steven Massey on 4/17/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n// Allow using opcodes for compilation process\n#define M3_COMPILE_OPCODES\n\n#include \"m3_compile.h\"\n\n//----- EMIT --------------------------------------------------------------------------------------------------------------\n\nstatic inline\npc_t GetPC (IM3Compilation o)\n{\n    return GetPagePC (o->page);\n}\n\nstatic M3_NOINLINE\nM3Result  EnsureCodePageNumLines  (IM3Compilation o, u32 i_numLines)\n{\n    M3Result result = m3Err_none;\n\n    i_numLines += 2; // room for Bridge\n\n    if (NumFreeLines (o->page) < i_numLines)\n    {\n        IM3CodePage page = AcquireCodePageWithCapacity (o->runtime, i_numLines);\n\n        if (page)\n        {\n            m3log (emit, \"bridging new code page from: %d %p (free slots: %d) to: %d\", o->page->info.sequence, GetPC (o), NumFreeLines (o->page), page->info.sequence);\n            d_m3Assert (NumFreeLines (o->page) >= 2);\n\n            EmitWord (o->page, op_Branch);\n            EmitWord (o->page, GetPagePC (page));\n\n            ReleaseCodePage (o->runtime, o->page);\n\n            o->page = page;\n        }\n        else result = m3Err_mallocFailedCodePage;\n    }\n\n    return result;\n}\n\nstatic M3_NOINLINE\nM3Result  EmitOp  (IM3Compilation o, IM3Operation i_operation)\n{\n    M3Result result = m3Err_none;                                 d_m3Assert (i_operation or IsStackPolymorphic (o));\n\n    // it's OK for page to be null; when compile-walking the bytecode without emitting\n    if (o->page)\n    {\n# if d_m3EnableOpTracing\n        if (i_operation != op_DumpStack)\n            o->numEmits++;\n# endif\n\n        // have execution jump to a new page if slots are critically low\n        result = EnsureCodePageNumLines (o, d_m3CodePageFreeLinesThreshold);\n\n        if (not result)\n        {                                                           if (d_m3LogEmit) log_emit (o, i_operation);\n# if d_m3RecordBacktraces\n            EmitMappingEntry (o->page, o->lastOpcodeStart - o->module->wasmStart);\n# endif // d_m3RecordBacktraces\n            EmitWord (o->page, i_operation);\n        }\n    }\n\n    return result;\n}\n\n// Push an immediate constant into the M3 codestream\nstatic M3_NOINLINE\nvoid  EmitConstant32  (IM3Compilation o, const u32 i_immediate)\n{\n    if (o->page)\n        EmitWord32 (o->page, i_immediate);\n}\n\nstatic M3_NOINLINE\nvoid  EmitSlotOffset  (IM3Compilation o, const i32 i_offset)\n{\n    if (o->page)\n        EmitWord32 (o->page, i_offset);\n}\n\nstatic M3_NOINLINE\npc_t  EmitPointer  (IM3Compilation o, const void * const i_pointer)\n{\n    pc_t ptr = GetPagePC (o->page);\n\n    if (o->page)\n        EmitWord (o->page, i_pointer);\n\n    return ptr;\n}\n\nstatic M3_NOINLINE\nvoid * ReservePointer (IM3Compilation o)\n{\n    pc_t ptr = GetPagePC (o->page);\n    EmitPointer (o, NULL);\n    return (void *) ptr;\n}\n\n\n//-------------------------------------------------------------------------------------------------------------------------\n\n#define d_indent \"     | %s\"\n\n// just want less letters and numbers to stare at down the way in the compiler table\n#define i_32    c_m3Type_i32\n#define i_64    c_m3Type_i64\n#define f_32    c_m3Type_f32\n#define f_64    c_m3Type_f64\n#define none    c_m3Type_none\n#define any     (u8)-1\n\n#if d_m3HasFloat\n#   define FPOP(x) x\n#else\n#   define FPOP(x) NULL\n#endif\n\nstatic const IM3Operation c_preserveSetSlot [] = { NULL, op_PreserveSetSlot_i32,       op_PreserveSetSlot_i64,\n                                                    FPOP(op_PreserveSetSlot_f32), FPOP(op_PreserveSetSlot_f64) };\nstatic const IM3Operation c_setSetOps [] =       { NULL, op_SetSlot_i32,               op_SetSlot_i64,\n                                                    FPOP(op_SetSlot_f32),         FPOP(op_SetSlot_f64) };\nstatic const IM3Operation c_setGlobalOps [] =    { NULL, op_SetGlobal_i32,             op_SetGlobal_i64,\n                                                    FPOP(op_SetGlobal_f32),       FPOP(op_SetGlobal_f64) };\nstatic const IM3Operation c_setRegisterOps [] =  { NULL, op_SetRegister_i32,           op_SetRegister_i64,\n                                                    FPOP(op_SetRegister_f32),     FPOP(op_SetRegister_f64) };\n\nstatic const IM3Operation c_intSelectOps [2] [4] =      { { op_Select_i32_rss, op_Select_i32_srs, op_Select_i32_ssr, op_Select_i32_sss },\n                                                          { op_Select_i64_rss, op_Select_i64_srs, op_Select_i64_ssr, op_Select_i64_sss } };\n#if d_m3HasFloat\nstatic const IM3Operation c_fpSelectOps [2] [2] [3] = { { { op_Select_f32_sss, op_Select_f32_srs, op_Select_f32_ssr },        // selector in slot\n                                                          { op_Select_f32_rss, op_Select_f32_rrs, op_Select_f32_rsr } },      // selector in reg\n                                                        { { op_Select_f64_sss, op_Select_f64_srs, op_Select_f64_ssr },        // selector in slot\n                                                          { op_Select_f64_rss, op_Select_f64_rrs, op_Select_f64_rsr } } };    // selector in reg\n#endif\n\n// all args & returns are 64-bit aligned, so use 2 slots for a d_m3Use32BitSlots=1 build\nstatic const u16 c_ioSlotCount = sizeof (u64) / sizeof (m3slot_t);\n\nstatic\nM3Result  AcquireCompilationCodePage  (IM3Compilation o, IM3CodePage * o_codePage)\n{\n    M3Result result = m3Err_none;\n\n    IM3CodePage page = AcquireCodePage (o->runtime);\n\n    if (page)\n    {\n#       if (d_m3EnableCodePageRefCounting)\n        {\n            if (o->function)\n            {\n                IM3Function func = o->function;\n                page->info.usageCount++;\n\n                u32 index = func->numCodePageRefs++;\n_               (m3ReallocArray (& func->codePageRefs, IM3CodePage, func->numCodePageRefs, index));\n                func->codePageRefs [index] = page;\n            }\n        }\n#       endif\n    }\n    else _throw (m3Err_mallocFailedCodePage);\n\n    _catch:\n\n    * o_codePage = page;\n\n    return result;\n}\n\nstatic inline\nvoid  ReleaseCompilationCodePage  (IM3Compilation o)\n{\n    ReleaseCodePage (o->runtime, o->page);\n}\n\nstatic inline\nu16 GetTypeNumSlots (u8 i_type)\n{\n#   if d_m3Use32BitSlots\n        return Is64BitType (i_type) ? 2 : 1;\n#   else\n        return 1;\n#   endif\n}\n\nstatic inline\nvoid  AlignSlotToType  (u16 * io_slot, u8 i_type)\n{\n    // align 64-bit words to even slots (if d_m3Use32BitSlots)\n    u16 numSlots = GetTypeNumSlots (i_type);\n\n    u16 mask = numSlots - 1;\n    * io_slot = (* io_slot + mask) & ~mask;\n}\n\nstatic inline\ni16  GetStackTopIndex  (IM3Compilation o)\n{                                                           d_m3Assert (o->stackIndex > o->stackFirstDynamicIndex or IsStackPolymorphic (o));\n    return o->stackIndex - 1;\n}\n\n\n// Items in the static portion of the stack (args/locals) are hidden from GetStackTypeFromTop ()\n// In other words, only \"real\" Wasm stack items can be inspected.  This is important when\n// returning values, etc. and you need an accurate wasm-view of the stack.\nstatic\nu8  GetStackTypeFromTop  (IM3Compilation o, u16 i_offset)\n{\n    u8 type = c_m3Type_none;\n\n    ++i_offset;\n    if (o->stackIndex >= i_offset)\n    {\n        u16 index = o->stackIndex - i_offset;\n\n        if (index >= o->stackFirstDynamicIndex)\n            type = o->typeStack [index];\n    }\n\n    return type;\n}\n\nstatic inline\nu8  GetStackTopType  (IM3Compilation o)\n{\n    return GetStackTypeFromTop (o, 0);\n}\n\nstatic inline\nu8  GetStackTypeFromBottom  (IM3Compilation o, u16 i_offset)\n{\n    u8 type = c_m3Type_none;\n\n    if (i_offset < o->stackIndex)\n        type = o->typeStack [i_offset];\n\n    return type;\n}\n\n\nstatic inline bool  IsConstantSlot    (IM3Compilation o, u16 i_slot)  { return (i_slot >= o->slotFirstConstIndex and i_slot < o->slotMaxConstIndex); }\nstatic inline bool  IsSlotAllocated   (IM3Compilation o, u16 i_slot)  { return o->m3Slots [i_slot]; }\n\nstatic inline\nbool  IsStackIndexInRegister  (IM3Compilation o, i32 i_stackIndex)\n{                                                                           d_m3Assert (i_stackIndex < o->stackIndex or IsStackPolymorphic (o));\n    if (i_stackIndex >= 0 and i_stackIndex < o->stackIndex)\n        return (o->wasmStack [i_stackIndex] >= d_m3Reg0SlotAlias);\n    else\n        return false;\n}\n\nstatic inline u16   GetNumBlockValuesOnStack      (IM3Compilation o)  { return o->stackIndex - o->block.blockStackIndex; }\n\nstatic inline bool  IsStackTopInRegister          (IM3Compilation o)  { return IsStackIndexInRegister (o, (i32) GetStackTopIndex (o));       }\nstatic inline bool  IsStackTopMinus1InRegister    (IM3Compilation o)  { return IsStackIndexInRegister (o, (i32) GetStackTopIndex (o) - 1);   }\nstatic inline bool  IsStackTopMinus2InRegister    (IM3Compilation o)  { return IsStackIndexInRegister (o, (i32) GetStackTopIndex (o) - 2);   }\n\nstatic inline bool  IsStackTopInSlot              (IM3Compilation o)  { return not IsStackTopInRegister (o); }\n\nstatic inline bool  IsValidSlot                   (u16 i_slot)        { return (i_slot < d_m3MaxFunctionSlots); }\n\nstatic inline\nu16  GetStackTopSlotNumber  (IM3Compilation o)\n{\n    i16 i = GetStackTopIndex (o);\n\n    u16 slot = c_slotUnused;\n\n    if (i >= 0)\n        slot = o->wasmStack [i];\n\n    return slot;\n}\n\n\n// from bottom\nstatic inline\nu16  GetSlotForStackIndex  (IM3Compilation o, u16 i_stackIndex)\n{                                                                   d_m3Assert (i_stackIndex < o->stackIndex or IsStackPolymorphic (o));\n    u16 slot = c_slotUnused;\n\n    if (i_stackIndex < o->stackIndex)\n        slot = o->wasmStack [i_stackIndex];\n\n    return slot;\n}\n\nstatic inline\nu16  GetExtraSlotForStackIndex  (IM3Compilation o, u16 i_stackIndex)\n{\n    u16 baseSlot = GetSlotForStackIndex (o, i_stackIndex);\n\n    if (baseSlot != c_slotUnused)\n    {\n        u16 extraSlot = GetTypeNumSlots (GetStackTypeFromBottom (o, i_stackIndex)) - 1;\n        baseSlot += extraSlot;\n    }\n\n    return baseSlot;\n}\n\n\nstatic inline\nvoid  TouchSlot  (IM3Compilation o, u16 i_slot)\n{\n    // op_Entry uses this value to track and detect stack overflow\n    o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);\n}\n\nstatic inline\nvoid  MarkSlotAllocated  (IM3Compilation o, u16 i_slot)\n{                                                                   d_m3Assert (o->m3Slots [i_slot] == 0); // shouldn't be already allocated\n    o->m3Slots [i_slot] = 1;\n\n    o->slotMaxAllocatedIndexPlusOne = M3_MAX (o->slotMaxAllocatedIndexPlusOne, i_slot + 1);\n\n    TouchSlot (o, i_slot);\n}\n\nstatic inline\nvoid  MarkSlotsAllocated  (IM3Compilation o, u16 i_slot, u16 i_numSlots)\n{\n    while (i_numSlots--)\n        MarkSlotAllocated (o, i_slot++);\n}\n\nstatic inline\nvoid  MarkSlotsAllocatedByType  (IM3Compilation o, u16 i_slot, u8 i_type)\n{\n    u16 numSlots = GetTypeNumSlots (i_type);\n    MarkSlotsAllocated (o, i_slot, numSlots);\n}\n\n\nstatic\nM3Result  AllocateSlotsWithinRange  (IM3Compilation o, u16 * o_slot, u8 i_type, u16 i_startSlot, u16 i_endSlot)\n{\n    M3Result result = m3Err_functionStackOverflow;\n\n    u16 numSlots = GetTypeNumSlots (i_type);\n    u16 searchOffset = numSlots - 1;\n\n    AlignSlotToType (& i_startSlot, i_type);\n\n    // search for 1 or 2 consecutive slots in the execution stack\n    u16 i = i_startSlot;\n    while (i + searchOffset < i_endSlot)\n    {\n        if (o->m3Slots [i] == 0 and o->m3Slots [i + searchOffset] == 0)\n        {\n            MarkSlotsAllocated (o, i, numSlots);\n\n            * o_slot = i;\n            result = m3Err_none;\n            break;\n        }\n\n        // keep 2-slot allocations even-aligned\n        i += numSlots;\n    }\n\n    return result;\n}\n\nstatic inline\nM3Result  AllocateSlots  (IM3Compilation o, u16 * o_slot, u8 i_type)\n{\n    return AllocateSlotsWithinRange (o, o_slot, i_type, o->slotFirstDynamicIndex, d_m3MaxFunctionSlots);\n}\n\nstatic inline\nM3Result  AllocateConstantSlots  (IM3Compilation o, u16 * o_slot, u8 i_type)\n{\n    u16 maxTableIndex = o->slotFirstConstIndex + d_m3MaxConstantTableSize;\n    return AllocateSlotsWithinRange (o, o_slot, i_type, o->slotFirstConstIndex, M3_MIN(o->slotFirstDynamicIndex, maxTableIndex));\n}\n\n\n// TOQUE: this usage count system could be eliminated. real world code doesn't frequently trigger it.  just copy to multiple\n// unique slots.\nstatic inline\nM3Result  IncrementSlotUsageCount  (IM3Compilation o, u16 i_slot)\n{                                                                                       d_m3Assert (i_slot < d_m3MaxFunctionSlots);\n    M3Result result = m3Err_none;                                                       d_m3Assert (o->m3Slots [i_slot] > 0);\n\n    // OPTZ (memory): 'm3Slots' could still be fused with 'typeStack' if 4 bits were used to indicate: [0,1,2,many]. The many-case\n    // would scan 'wasmStack' to determine the actual usage count\n    if (o->m3Slots [i_slot] < 0xFF)\n    {\n        o->m3Slots [i_slot]++;\n    }\n    else result = \"slot usage count overflow\";\n\n    return result;\n}\n\nstatic inline\nvoid DeallocateSlot (IM3Compilation o, i16 i_slot, u8 i_type)\n{                                                                                       d_m3Assert (i_slot >= o->slotFirstDynamicIndex);\n                                                                                        d_m3Assert (i_slot < o->slotMaxAllocatedIndexPlusOne);\n    for (u16 i = 0; i < GetTypeNumSlots (i_type); ++i, ++i_slot)\n    {                                                                                   d_m3Assert (o->m3Slots [i_slot]);\n        -- o->m3Slots [i_slot];\n    }\n}\n\n\nstatic inline\nbool  IsRegisterTypeAllocated  (IM3Compilation o, u8 i_type)\n{\n    return IsRegisterAllocated (o, IsFpType (i_type));\n}\n\nstatic inline\nvoid  AllocateRegister  (IM3Compilation o, u32 i_register, u16 i_stackIndex)\n{                                                                                       d_m3Assert (not IsRegisterAllocated (o, i_register));\n    o->regStackIndexPlusOne [i_register] = i_stackIndex + 1;\n}\n\nstatic inline\nvoid  DeallocateRegister  (IM3Compilation o, u32 i_register)\n{                                                                                       d_m3Assert (IsRegisterAllocated (o, i_register));\n    o->regStackIndexPlusOne [i_register] = c_m3RegisterUnallocated;\n}\n\nstatic inline\nu16  GetRegisterStackIndex  (IM3Compilation o, u32 i_register)\n{                                                                                       d_m3Assert (IsRegisterAllocated (o, i_register));\n    return o->regStackIndexPlusOne [i_register] - 1;\n}\n\nu16  GetMaxUsedSlotPlusOne  (IM3Compilation o)\n{\n    while (o->slotMaxAllocatedIndexPlusOne > o->slotFirstDynamicIndex)\n    {\n        if (IsSlotAllocated (o, o->slotMaxAllocatedIndexPlusOne - 1))\n            break;\n\n        o->slotMaxAllocatedIndexPlusOne--;\n    }\n\n#   ifdef DEBUG\n        u16 maxSlot = o->slotMaxAllocatedIndexPlusOne;\n        while (maxSlot < d_m3MaxFunctionSlots)\n        {\n            d_m3Assert (o->m3Slots [maxSlot] == 0);\n            maxSlot++;\n        }\n#   endif\n\n    return o->slotMaxAllocatedIndexPlusOne;\n}\n\nstatic\nM3Result  PreserveRegisterIfOccupied  (IM3Compilation o, u8 i_registerType)\n{\n    M3Result result = m3Err_none;\n\n    u32 regSelect = IsFpType (i_registerType);\n\n    if (IsRegisterAllocated (o, regSelect))\n    {\n        u16 stackIndex = GetRegisterStackIndex (o, regSelect);\n        DeallocateRegister (o, regSelect);\n\n        u8 type = GetStackTypeFromBottom (o, stackIndex);\n\n        // and point to a exec slot\n        u16 slot = c_slotUnused;\n_       (AllocateSlots (o, & slot, type));\n        o->wasmStack [stackIndex] = slot;\n\n_       (EmitOp (o, c_setSetOps [type]));\n        EmitSlotOffset (o, slot);\n    }\n\n    _catch: return result;\n}\n\n\n// all values must be in slots before entering loop, if, and else blocks\n// otherwise they'd end up preserve-copied in the block to probably different locations (if/else)\nstatic inline\nM3Result  PreserveRegisters  (IM3Compilation o)\n{\n    M3Result result;\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_f64));\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  PreserveNonTopRegisters  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    i16 stackTop = GetStackTopIndex (o);\n\n    if (stackTop >= 0)\n    {\n        if (IsRegisterAllocated (o, 0))     // r0\n        {\n            if (GetRegisterStackIndex (o, 0) != stackTop)\n_               (PreserveRegisterIfOccupied (o, c_m3Type_i64));\n        }\n\n        if (IsRegisterAllocated (o, 1))     // fp0\n        {\n            if (GetRegisterStackIndex (o, 1) != stackTop)\n_               (PreserveRegisterIfOccupied (o, c_m3Type_f64));\n        }\n    }\n\n    _catch: return result;\n}\n\n\n//----------------------------------------------------------------------------------------------------------------------\n\nstatic\nM3Result  Push  (IM3Compilation o, u8 i_type, u16 i_slot)\n{\n    M3Result result = m3Err_none;\n\n#if !d_m3HasFloat\n    if (i_type == c_m3Type_f32 || i_type == c_m3Type_f64) {\n        return m3Err_unknownOpcode;\n    }\n#endif\n\n    u16 stackIndex = o->stackIndex++;                                       // printf (\"push: %d\\n\", (i32) i);\n\n    if (stackIndex < d_m3MaxFunctionStackHeight)\n    {\n        o->wasmStack        [stackIndex] = i_slot;\n        o->typeStack        [stackIndex] = i_type;\n\n        if (IsRegisterSlotAlias (i_slot))\n        {\n            u32 regSelect = IsFpRegisterSlotAlias (i_slot);\n            AllocateRegister (o, regSelect, stackIndex);\n        }\n\n        if (d_m3LogWasmStack) dump_type_stack (o);\n    }\n    else result = m3Err_functionStackOverflow;\n\n    return result;\n}\n\nstatic inline\nM3Result  PushRegister  (IM3Compilation o, u8 i_type)\n{\n    M3Result result = m3Err_none;                                                       d_m3Assert ((u16) d_m3Reg0SlotAlias > (u16) d_m3MaxFunctionSlots);\n    u16 slot = IsFpType (i_type) ? d_m3Fp0SlotAlias : d_m3Reg0SlotAlias;                d_m3Assert (i_type or IsStackPolymorphic (o));\n\n_   (Push (o, i_type, slot));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Pop  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    if (o->stackIndex > o->block.blockStackIndex)\n    {\n        o->stackIndex--;                                                //  printf (\"pop: %d\\n\", (i32) o->stackIndex);\n\n        u16 slot = o->wasmStack [o->stackIndex];\n        u8 type = o->typeStack [o->stackIndex];\n\n        if (IsRegisterSlotAlias (slot))\n        {\n            u32 regSelect = IsFpRegisterSlotAlias (slot);\n            DeallocateRegister (o, regSelect);\n        }\n        else if (slot >= o->slotFirstDynamicIndex)\n        {\n            DeallocateSlot (o, slot, type);\n        }\n    }\n    else if (not IsStackPolymorphic (o))\n        result = m3Err_functionStackUnderrun;\n\n    return result;\n}\n\nstatic\nM3Result  PopType  (IM3Compilation o, u8 i_type)\n{\n    M3Result result = m3Err_none;\n\n    u8 topType = GetStackTopType (o);\n\n    if (i_type == topType or o->block.isPolymorphic)\n    {\n_       (Pop (o));\n    }\n    else _throw (m3Err_typeMismatch);\n\n    _catch:\n    return result;\n}\n\nstatic\nM3Result  _PushAllocatedSlotAndEmit  (IM3Compilation o, u8 i_type, bool i_doEmit)\n{\n    M3Result result = m3Err_none;\n\n    u16 slot = c_slotUnused;\n\n_   (AllocateSlots (o, & slot, i_type));\n_   (Push (o, i_type, slot));\n\n    if (i_doEmit)\n        EmitSlotOffset (o, slot);\n\n//    printf (\"push: %d\\n\", (u32) slot);\n\n    _catch: return result;\n}\n\nstatic inline\nM3Result  PushAllocatedSlotAndEmit  (IM3Compilation o, u8 i_type)\n{\n    return _PushAllocatedSlotAndEmit (o, i_type, true);\n}\n\nstatic inline\nM3Result  PushAllocatedSlot  (IM3Compilation o, u8 i_type)\n{\n    return _PushAllocatedSlotAndEmit (o, i_type, false);\n}\n\nstatic\nM3Result  PushConst  (IM3Compilation o, u64 i_word, u8 i_type)\n{\n    M3Result result = m3Err_none;\n\n    // Early-exit if we're not emitting\n    if (!o->page) return result;\n\n    bool matchFound = false;\n    bool is64BitType = Is64BitType (i_type);\n\n    u16 numRequiredSlots = GetTypeNumSlots (i_type);\n    u16 numUsedConstSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;\n\n    // search for duplicate matching constant slot to reuse\n    if (numRequiredSlots == 2 and numUsedConstSlots >= 2)\n    {\n        u16 firstConstSlot = o->slotFirstConstIndex;\n        AlignSlotToType (& firstConstSlot, c_m3Type_i64);\n\n        for (u16 slot = firstConstSlot; slot < o->slotMaxConstIndex - 1; slot += 2)\n        {\n            if (IsSlotAllocated (o, slot) and IsSlotAllocated (o, slot + 1))\n            {\n                u64 constant;\n                memcpy (&constant, &o->constants [slot - o->slotFirstConstIndex], sizeof(constant));\n\n                if (constant == i_word)\n                {\n                    matchFound = true;\n_                   (Push (o, i_type, slot));\n                    break;\n                }\n            }\n        }\n    }\n    else if (numRequiredSlots == 1)\n    {\n        for (u16 i = 0; i < numUsedConstSlots; ++i)\n        {\n            u16 slot = o->slotFirstConstIndex + i;\n\n            if (IsSlotAllocated (o, slot))\n            {\n                bool matches;\n                if (is64BitType) {\n                    u64 constant;\n                    memcpy (&constant, &o->constants [i], sizeof(constant));\n                    matches = (constant == i_word);\n                } else {\n                    u32 constant;\n                    memcpy (&constant, &o->constants [i], sizeof(constant));\n                    matches = (constant == i_word);\n                }\n                if (matches)\n                {\n                    matchFound = true;\n_                   (Push (o, i_type, slot));\n                    break;\n                }\n            }\n        }\n    }\n\n    if (not matchFound)\n    {\n        u16 slot = c_slotUnused;\n        result = AllocateConstantSlots (o, & slot, i_type);\n\n        if (result || slot == c_slotUnused) // no more constant table space; use inline constants\n        {\n            result = m3Err_none;\n\n            if (is64BitType) {\n_               (EmitOp (o, op_Const64));\n                EmitWord64 (o->page, i_word);\n            } else {\n_               (EmitOp (o, op_Const32));\n                EmitWord32 (o->page, (u32) i_word);\n            }\n\n_           (PushAllocatedSlotAndEmit (o, i_type));\n        }\n        else\n        {\n            u16 constTableIndex = slot - o->slotFirstConstIndex;\n\n            d_m3Assert(constTableIndex < d_m3MaxConstantTableSize);\n\n            if (is64BitType) {\n                memcpy (& o->constants [constTableIndex], &i_word, sizeof(i_word));\n            } else {\n                u32 word32 = i_word;\n                memcpy (& o->constants [constTableIndex], &word32, sizeof(word32));\n            }\n\n_           (Push (o, i_type, slot));\n\n            o->slotMaxConstIndex = M3_MAX (slot + numRequiredSlots, o->slotMaxConstIndex);\n        }\n    }\n\n    _catch: return result;\n}\n\nstatic inline\nM3Result  EmitSlotNumOfStackTopAndPop  (IM3Compilation o)\n{\n    // no emit if value is in register\n    if (IsStackTopInSlot (o))\n        EmitSlotOffset (o, GetStackTopSlotNumber (o));\n\n    return Pop (o);\n}\n\n\n// Or, maybe: EmitTrappingOp\nM3Result  AddTrapRecord  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    if (o->function)\n    {\n    }\n\n    return result;\n}\n\nstatic\nM3Result  UnwindBlockStack  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    u32 popCount = 0;\n    while (o->stackIndex > o->block.blockStackIndex)\n    {\n_       (Pop (o));\n        ++popCount;\n    }\n\n    if (popCount)\n    {\n        m3log (compile, \"unwound stack top: %d\", popCount);\n    }\n\n    _catch: return result;\n}\n\nstatic inline\nM3Result  SetStackPolymorphic  (IM3Compilation o)\n{\n    o->block.isPolymorphic = true;                              m3log (compile, \"stack set polymorphic\");\n    return UnwindBlockStack (o);\n}\n\nstatic\nvoid  PatchBranches  (IM3Compilation o)\n{\n    pc_t pc = GetPC (o);\n\n    pc_t patches = o->block.patches;\n    o->block.patches = NULL;\n\n    while (patches)\n    {                                                           m3log (compile, \"patching location: %p to pc: %p\", patches, pc);\n        pc_t next = * (pc_t *) patches;\n        * (pc_t *) patches = pc;\n        patches = next;\n    }\n}\n\n//-------------------------------------------------------------------------------------------------------------------------\n\nstatic\nM3Result  CopyStackIndexToSlot  (IM3Compilation o, u16 i_destSlot, u16 i_stackIndex)  // NoPushPop\n{\n    M3Result result = m3Err_none;\n\n    IM3Operation op;\n\n    u8 type = GetStackTypeFromBottom (o, i_stackIndex);\n    bool inRegister = IsStackIndexInRegister (o, i_stackIndex);\n\n    if (inRegister)\n    {\n        op = c_setSetOps [type];\n    }\n    else op = Is64BitType (type) ? op_CopySlot_64 : op_CopySlot_32;\n\n_   (EmitOp (o, op));\n    EmitSlotOffset (o, i_destSlot);\n\n    if (not inRegister)\n    {\n        u16 srcSlot = GetSlotForStackIndex (o, i_stackIndex);\n        EmitSlotOffset (o, srcSlot);\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  CopyStackTopToSlot  (IM3Compilation o, u16 i_destSlot)  // NoPushPop\n{\n    M3Result result;\n\n    i16 stackTop = GetStackTopIndex (o);\n_   (CopyStackIndexToSlot (o, i_destSlot, (u16) stackTop));\n\n    _catch: return result;\n}\n\n\n// a copy-on-write strategy is used with locals. when a get local occurs, it's not copied anywhere. the stack\n// entry just has a index pointer to that local memory slot.\n// then, when a previously referenced local is set, the current value needs to be preserved for those references\n\n// TODO: consider getting rid of these specialized operations: PreserveSetSlot & PreserveCopySlot.\n// They likely just take up space (which seems to reduce performance) without improving performance.\nstatic\nM3Result  PreservedCopyTopSlot  (IM3Compilation o, u16 i_destSlot, u16 i_preserveSlot)\n{\n    M3Result result = m3Err_none;             d_m3Assert (i_destSlot != i_preserveSlot);\n\n    IM3Operation op;\n\n    u8 type = GetStackTopType (o);\n\n    if (IsStackTopInRegister (o))\n    {\n        op = c_preserveSetSlot [type];\n    }\n    else op = Is64BitType (type) ? op_PreserveCopySlot_64 : op_PreserveCopySlot_32;\n\n_   (EmitOp (o, op));\n    EmitSlotOffset (o, i_destSlot);\n\n    if (IsStackTopInSlot (o))\n        EmitSlotOffset (o, GetStackTopSlotNumber (o));\n\n    EmitSlotOffset (o, i_preserveSlot);\n\n    _catch: return result;\n}\n\nstatic\nM3Result  CopyStackTopToRegister  (IM3Compilation o, bool i_updateStack)\n{\n    M3Result result = m3Err_none;\n\n    if (IsStackTopInSlot (o))\n    {\n        u8 type = GetStackTopType (o);\n\n_       (PreserveRegisterIfOccupied (o, type));\n\n        IM3Operation op = c_setRegisterOps [type];\n\n_       (EmitOp (o, op));\n        EmitSlotOffset (o, GetStackTopSlotNumber (o));\n\n        if (i_updateStack)\n        {\n_           (PopType (o, type));\n_           (PushRegister (o, type));\n        }\n    }\n\n    _catch: return result;\n}\n\n\n// if local is unreferenced, o_preservedSlotNumber will be equal to localIndex on return\nstatic\nM3Result  FindReferencedLocalWithinCurrentBlock  (IM3Compilation o, u16 * o_preservedSlotNumber, u32 i_localSlot)\n{\n    M3Result result = m3Err_none;\n\n    IM3CompilationScope scope = & o->block;\n    u16 startIndex = scope->blockStackIndex;\n\n    while (scope->opcode == c_waOp_block)\n    {\n        scope = scope->outer;\n        if (not scope)\n            break;\n\n        startIndex = scope->blockStackIndex;\n    }\n\n    * o_preservedSlotNumber = (u16) i_localSlot;\n\n    for (u32 i = startIndex; i < o->stackIndex; ++i)\n    {\n        if (o->wasmStack [i] == i_localSlot)\n        {\n            if (* o_preservedSlotNumber == i_localSlot)\n            {\n                u8 type = GetStackTypeFromBottom (o, i);                    d_m3Assert (type != c_m3Type_none)\n\n_               (AllocateSlots (o, o_preservedSlotNumber, type));\n            }\n            else\n_               (IncrementSlotUsageCount (o, * o_preservedSlotNumber));\n\n            o->wasmStack [i] = * o_preservedSlotNumber;\n        }\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  GetBlockScope  (IM3Compilation o, IM3CompilationScope * o_scope, u32 i_depth)\n{\n    M3Result result = m3Err_none;\n\n    IM3CompilationScope scope = & o->block;\n\n    while (i_depth--)\n    {\n        scope = scope->outer;\n        _throwif (\"invalid block depth\", not scope);\n    }\n\n    * o_scope = scope;\n\n    _catch:\n    return result;\n}\n\nstatic\nM3Result  CopyStackSlotsR  (IM3Compilation o, u16 i_targetSlotStackIndex, u16 i_stackIndex, u16 i_endStackIndex, u16 i_tempSlot)\n{\n    M3Result result = m3Err_none;\n\n    if (i_stackIndex < i_endStackIndex)\n    {\n        u16 srcSlot = GetSlotForStackIndex (o, i_stackIndex);\n\n        u8 type = GetStackTypeFromBottom (o, i_stackIndex);\n        u16 numSlots = GetTypeNumSlots (type);\n        u16 extraSlot = numSlots - 1;\n\n        u16 targetSlot = GetSlotForStackIndex (o, i_targetSlotStackIndex);\n\n        u16 preserveIndex = i_stackIndex;\n        u16 collisionSlot = srcSlot;\n\n        if (targetSlot != srcSlot)\n        {\n            // search for collisions\n            u16 checkIndex = i_stackIndex + 1;\n            while (checkIndex < i_endStackIndex)\n            {\n                u16 otherSlot1 = GetSlotForStackIndex (o, checkIndex);\n                u16 otherSlot2 = GetExtraSlotForStackIndex (o, checkIndex);\n\n                if (targetSlot == otherSlot1 or\n                    targetSlot == otherSlot2 or\n                    targetSlot + extraSlot == otherSlot1)\n                {\n                    _throwif (m3Err_functionStackOverflow, i_tempSlot >= d_m3MaxFunctionSlots);\n\n_                   (CopyStackIndexToSlot (o, i_tempSlot, checkIndex));\n                    o->wasmStack [checkIndex] = i_tempSlot;\n                    i_tempSlot += GetTypeNumSlots (c_m3Type_i64);\n                    TouchSlot (o, i_tempSlot - 1);\n\n                    // restore this on the way back down\n                    preserveIndex = checkIndex;\n                    collisionSlot = otherSlot1;\n\n                    break;\n                }\n\n                ++checkIndex;\n            }\n\n_           (CopyStackIndexToSlot (o, targetSlot, i_stackIndex));                                               m3log (compile, \" copying slot: %d to slot: %d\", srcSlot, targetSlot);\n            o->wasmStack [i_stackIndex] = targetSlot;\n\n        }\n\n_       (CopyStackSlotsR (o, i_targetSlotStackIndex + 1, i_stackIndex + 1, i_endStackIndex, i_tempSlot));\n\n        // restore the stack state\n        o->wasmStack [i_stackIndex] = srcSlot;\n        o->wasmStack [preserveIndex] = collisionSlot;\n    }\n\n    _catch:\n    return result;\n}\n\nstatic\nM3Result  ResolveBlockResults  (IM3Compilation o, IM3CompilationScope i_targetBlock, bool i_isBranch)\n{\n    M3Result result = m3Err_none;                                   if (d_m3LogWasmStack) dump_type_stack (o);\n\n    bool isLoop = (i_targetBlock->opcode == c_waOp_loop and i_isBranch);\n\n    u16 numParams = GetFuncTypeNumParams (i_targetBlock->type);\n    u16 numResults = GetFuncTypeNumResults (i_targetBlock->type);\n\n    u16 slotRecords = i_targetBlock->exitStackIndex;\n\n    u16 numValues;\n\n    if (not isLoop)\n    {\n        numValues = numResults;\n        slotRecords += numParams;\n    }\n    else numValues = numParams;\n\n    u16 blockHeight = GetNumBlockValuesOnStack (o);\n\n    _throwif (m3Err_typeCountMismatch, i_isBranch ? (blockHeight < numValues) : (blockHeight != numValues));\n\n    if (numValues)\n    {\n        u16 endIndex = GetStackTopIndex (o) + 1;\n        u16 numRemValues = numValues;\n\n        // The last result is taken from _fp0. See PushBlockResults.\n        if (not isLoop and IsFpType (GetStackTopType (o)))\n        {\n_           (CopyStackTopToRegister (o, false));\n            --endIndex;\n            --numRemValues;\n        }\n\n        // TODO: tempslot affects maxStackSlots, so can grow unnecess each time.\n        u16 tempSlot = o->maxStackSlots;// GetMaxUsedSlotPlusOne (o); doesn't work cause can collide with slotRecords\n        AlignSlotToType (& tempSlot, c_m3Type_i64);\n\n_       (CopyStackSlotsR (o, slotRecords, endIndex - numRemValues, endIndex, tempSlot));\n\n        if (d_m3LogWasmStack) dump_type_stack (o);\n    }\n\n    _catch: return result;\n}\n\n\nstatic\nM3Result  ReturnValues  (IM3Compilation o, IM3CompilationScope i_functionBlock, bool i_isBranch)\n{\n    M3Result result = m3Err_none;                                               if (d_m3LogWasmStack) dump_type_stack (o);\n\n    u16 numReturns = GetFuncTypeNumResults (i_functionBlock->type);     // could just o->function too...\n    u16 blockHeight = GetNumBlockValuesOnStack (o);\n\n    if (not IsStackPolymorphic (o))\n        _throwif (m3Err_typeCountMismatch, i_isBranch ? (blockHeight < numReturns) : (blockHeight != numReturns));\n\n    if (numReturns)\n    {\n        // return slots like args are 64-bit aligned\n        u16 returnSlot = numReturns * c_ioSlotCount;\n        u16 stackTop = GetStackTopIndex (o);\n\n        for (u16 i = 0; i < numReturns; ++i)\n        {\n            u8 returnType = GetFuncTypeResultType (i_functionBlock->type, numReturns - 1 - i);\n\n            u8 stackType = GetStackTypeFromTop (o, i);  // using FromTop so that only dynamic items are checked\n\n            if (IsStackPolymorphic (o) and stackType == c_m3Type_none)\n                stackType = returnType;\n\n            _throwif (m3Err_typeMismatch, returnType != stackType);\n\n            if (not IsStackPolymorphic (o))\n            {\n                returnSlot -= c_ioSlotCount;\n_               (CopyStackIndexToSlot (o, returnSlot, stackTop--));\n            }\n        }\n\n        if (not i_isBranch)\n        {\n            while (numReturns--)\n_               (Pop (o));\n        }\n    }\n\n    _catch: return result;\n}\n\n\n//-------------------------------------------------------------------------------------------------------------------------\n\nstatic\nM3Result  Compile_Const_i32  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i32 value;\n_   (ReadLEB_i32 (& value, & o->wasm, o->wasmEnd));\n_   (PushConst (o, value, c_m3Type_i32));                       m3log (compile, d_indent \" (const i32 = %\" PRIi32 \")\", get_indention_string (o), value);\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Const_i64  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i64 value;\n_   (ReadLEB_i64 (& value, & o->wasm, o->wasmEnd));\n_   (PushConst (o, value, c_m3Type_i64));                       m3log (compile, d_indent \" (const i64 = %\" PRIi64 \")\", get_indention_string (o), value);\n    _catch: return result;\n}\n\n\n#if d_m3ImplementFloat\nstatic\nM3Result  Compile_Const_f32  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    union { u32 u; f32 f; } value = { 0 };\n\n_   (Read_f32 (& value.f, & o->wasm, o->wasmEnd));              m3log (compile, d_indent \" (const f32 = %\" PRIf32 \")\", get_indention_string (o), value.f);\n_   (PushConst (o, value.u, c_m3Type_f32));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Const_f64  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    union { u64 u; f64 f; } value = { 0 };\n\n_   (Read_f64 (& value.f, & o->wasm, o->wasmEnd));              m3log (compile, d_indent \" (const f64 = %\" PRIf64 \")\", get_indention_string (o), value.f);\n_   (PushConst (o, value.u, c_m3Type_f64));\n\n    _catch: return result;\n}\n#endif\n\n#if d_m3CascadedOpcodes\n\nstatic\nM3Result  Compile_ExtendedOpcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u8 opcode;\n_   (Read_u8 (& opcode, & o->wasm, o->wasmEnd));             m3log (compile, d_indent \" (FC: %\" PRIi32 \")\", get_indention_string (o), opcode);\n\n    i_opcode = (i_opcode << 8) | opcode;\n\n    //printf(\"Extended opcode: 0x%x\\n\", i_opcode);\n\n    IM3OpInfo opInfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opInfo);\n\n    M3Compiler compiler = opInfo->compiler;\n    _throwif (m3Err_noCompiler, not compiler);\n\n_   ((* compiler) (o, i_opcode));\n\n    o->previousOpcode = i_opcode;\n\n    } _catch: return result;\n}\n#endif\n\nstatic\nM3Result  Compile_Return  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    if (not IsStackPolymorphic (o))\n    {\n        IM3CompilationScope functionScope;\n_       (GetBlockScope (o, & functionScope, o->block.depth));\n\n_       (ReturnValues (o, functionScope, true));\n\n_       (EmitOp (o, op_Return));\n\n_       (SetStackPolymorphic (o));\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  ValidateBlockEnd  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n/*\n    u16 numResults = GetFuncTypeNumResults (o->block.type);\n    u16 blockHeight = GetNumBlockValuesOnStack (o);\n\n    if (IsStackPolymorphic (o))\n    {\n    }\n    else\n    {\n    }\n\n    _catch: */ return result;\n}\n\nstatic\nM3Result  Compile_End  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;                   //dump_type_stack (o);\n\n    // function end:\n    if (o->block.depth == 0)\n    {\n        ValidateBlockEnd (o);\n\n//      if (not IsStackPolymorphic (o))\n        {\n            if (o->function)\n            {\n_               (ReturnValues (o, & o->block, false));\n            }\n\n_           (EmitOp (o, op_Return));\n        }\n    }\n\n    _catch: return result;\n}\n\n\nstatic\nM3Result  Compile_SetLocal  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    u32 localIndex;\n_   (ReadLEB_u32 (& localIndex, & o->wasm, o->wasmEnd));             //  printf (\"--- set local: %d \\n\", localSlot);\n\n    if (localIndex < GetFunctionNumArgsAndLocals (o->function))\n    {\n        u16 localSlot = GetSlotForStackIndex (o, localIndex);\n\n        u16 preserveSlot;\n_       (FindReferencedLocalWithinCurrentBlock (o, & preserveSlot, localSlot));  // preserve will be different than local, if referenced\n\n        if (preserveSlot == localSlot)\n_           (CopyStackTopToSlot (o, localSlot))\n        else\n_           (PreservedCopyTopSlot (o, localSlot, preserveSlot))\n\n        if (i_opcode != c_waOp_teeLocal)\n_           (Pop (o));\n    }\n    else _throw (\"local index out of bounds\");\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_GetLocal  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n\n    u32 localIndex;\n_   (ReadLEB_u32 (& localIndex, & o->wasm, o->wasmEnd));\n\n    if (localIndex >= GetFunctionNumArgsAndLocals (o->function))\n        _throw (\"local index out of bounds\");\n\n    u8 type = GetStackTypeFromBottom (o, localIndex);\n    u16 slot = GetSlotForStackIndex (o, localIndex);\n\n_   (Push (o, type, slot));\n\n    } _catch: return result;\n}\n\nstatic\nM3Result  Compile_GetGlobal  (IM3Compilation o, M3Global * i_global)\n{\n    M3Result result;\n\n    IM3Operation op = Is64BitType (i_global->type) ? op_GetGlobal_s64 : op_GetGlobal_s32;\n_   (EmitOp (o, op));\n    EmitPointer (o, & i_global->i64Value);\n_   (PushAllocatedSlotAndEmit (o, i_global->type));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_SetGlobal  (IM3Compilation o, M3Global * i_global)\n{\n    M3Result result = m3Err_none;\n\n    if (i_global->isMutable)\n    {\n        IM3Operation op;\n        u8 type = GetStackTopType (o);\n\n        if (IsStackTopInRegister (o))\n        {\n            op = c_setGlobalOps [type];\n        }\n        else op = Is64BitType (type) ? op_SetGlobal_s64 : op_SetGlobal_s32;\n\n_      (EmitOp (o, op));\n        EmitPointer (o, & i_global->i64Value);\n\n        if (IsStackTopInSlot (o))\n            EmitSlotOffset (o, GetStackTopSlotNumber (o));\n\n_      (Pop (o));\n    }\n    else _throw (m3Err_settingImmutableGlobal);\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_GetSetGlobal  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    u32 globalIndex;\n_   (ReadLEB_u32 (& globalIndex, & o->wasm, o->wasmEnd));\n\n    if (globalIndex < o->module->numGlobals)\n    {\n        if (o->module->globals)\n        {\n            M3Global * global = & o->module->globals [globalIndex];\n\n_           ((i_opcode == c_waOp_getGlobal) ? Compile_GetGlobal (o, global) : Compile_SetGlobal (o, global));\n        }\n        else _throw (ErrorCompile (m3Err_globalMemoryNotAllocated, o, \"module '%s' is missing global memory\", o->module->name));\n    }\n    else _throw (m3Err_globaIndexOutOfBounds);\n\n    _catch: return result;\n}\n\nstatic\nvoid  EmitPatchingBranchPointer  (IM3Compilation o, IM3CompilationScope i_scope)\n{\n    pc_t patch = EmitPointer (o, i_scope->patches);                     m3log (compile, \"branch patch required at: %p\", patch);\n    i_scope->patches = patch;\n}\n\nstatic\nM3Result  EmitPatchingBranch  (IM3Compilation o, IM3CompilationScope i_scope)\n{\n    M3Result result = m3Err_none;\n\n_   (EmitOp (o, op_Branch));\n    EmitPatchingBranchPointer (o, i_scope);\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Branch  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    u32 depth;\n_   (ReadLEB_u32 (& depth, & o->wasm, o->wasmEnd));\n\n    IM3CompilationScope scope;\n_   (GetBlockScope (o, & scope, depth));\n\n    // branch target is a loop (continue)\n    if (scope->opcode == c_waOp_loop)\n    {\n        if (i_opcode == c_waOp_branchIf)\n        {\n            if (GetFuncTypeNumParams (scope->type))\n            {\n                IM3Operation op = IsStackTopInRegister (o) ? op_BranchIfPrologue_r : op_BranchIfPrologue_s;\n\n_               (EmitOp (o, op));\n_               (EmitSlotNumOfStackTopAndPop (o));\n\n                pc_t * jumpTo = (pc_t *) ReservePointer (o);\n\n_               (ResolveBlockResults (o, scope, /* isBranch: */ true));\n\n_               (EmitOp (o, op_ContinueLoop));\n                EmitPointer (o, scope->pc);\n\n                * jumpTo = GetPC (o);\n            }\n            else\n            {\n                // move the condition to a register\n_               (CopyStackTopToRegister (o, false));\n_               (PopType (o, c_m3Type_i32));\n\n_               (EmitOp (o, op_ContinueLoopIf));\n                EmitPointer (o, scope->pc);\n            }\n\n//          dump_type_stack(o);\n        }\n        else // is c_waOp_branch\n        {\n    _       (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n            o->block.isPolymorphic = true;\n        }\n    }\n    else // forward branch\n    {\n        pc_t * jumpTo = NULL;\n\n        bool isReturn = (scope->depth == 0);\n        bool targetHasResults = GetFuncTypeNumResults (scope->type);\n\n        if (i_opcode == c_waOp_branchIf)\n        {\n            if (targetHasResults or isReturn)\n            {\n                IM3Operation op = IsStackTopInRegister (o) ? op_BranchIfPrologue_r : op_BranchIfPrologue_s;\n\n    _           (EmitOp (o, op));\n    _           (EmitSlotNumOfStackTopAndPop (o)); // condition\n\n                // this is continuation point, if the branch isn't taken\n                jumpTo = (pc_t *) ReservePointer (o);\n            }\n            else\n            {\n                IM3Operation op = IsStackTopInRegister (o) ? op_BranchIf_r : op_BranchIf_s;\n\n    _           (EmitOp (o, op));\n    _           (EmitSlotNumOfStackTopAndPop (o)); // condition\n\n                EmitPatchingBranchPointer (o, scope);\n                goto _catch;\n            }\n        }\n\n        if (not IsStackPolymorphic (o))\n        {\n            if (isReturn)\n            {\n_               (ReturnValues (o, scope, true));\n_               (EmitOp (o, op_Return));\n            }\n            else\n            {\n_               (ResolveBlockResults (o, scope, true));\n_               (EmitPatchingBranch (o, scope));\n            }\n        }\n\n        if (jumpTo)\n        {\n            * jumpTo = GetPC (o);\n        }\n\n        if (i_opcode == c_waOp_branch)\n_           (SetStackPolymorphic (o));\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_BranchTable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u32 targetCount;\n_   (ReadLEB_u32 (& targetCount, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));         // move branch operand to a slot\n    u16 slot = GetStackTopSlotNumber (o);\n_   (Pop (o));\n\n    // OPTZ: according to spec: \"forward branches that target a control instruction with a non-empty\n    // result type consume matching operands first and push them back on the operand stack after unwinding\"\n    // So, this move-to-reg is only necessary if the target scopes have a type.\n\n    u32 numCodeLines = targetCount + 4; // 3 => IM3Operation + slot + target_count + default_target\n_   (EnsureCodePageNumLines (o, numCodeLines));\n\n_   (EmitOp (o, op_BranchTable));\n    EmitSlotOffset (o, slot);\n    EmitConstant32 (o, targetCount);\n\n    IM3CodePage continueOpPage = NULL;\n\n    ++targetCount; // include default\n    for (u32 i = 0; i < targetCount; ++i)\n    {\n        u32 target;\n_       (ReadLEB_u32 (& target, & o->wasm, o->wasmEnd));\n\n        IM3CompilationScope scope;\n_       (GetBlockScope (o, & scope, target));\n\n        // TODO: don't need codepage rigmarole for\n        // no-param forward-branch targets\n\n_       (AcquireCompilationCodePage (o, & continueOpPage));\n\n        pc_t startPC = GetPagePC (continueOpPage);\n        IM3CodePage savedPage = o->page;\n        o->page = continueOpPage;\n\n        if (scope->opcode == c_waOp_loop)\n        {\n_           (ResolveBlockResults (o, scope, true));\n\n_           (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n        }\n        else\n        {\n            // TODO: this could be fused with equivalent targets\n            if (not IsStackPolymorphic (o))\n            {\n                if (scope->depth == 0)\n                {\n_                   (ReturnValues (o, scope, true));\n_                   (EmitOp (o, op_Return));\n                }\n                else\n                {\n_                   (ResolveBlockResults (o, scope, true));\n\n_                   (EmitPatchingBranch (o, scope));\n                }\n            }\n        }\n\n        ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown\n        o->page = savedPage;\n\n        EmitPointer (o, startPC);\n    }\n\n_   (SetStackPolymorphic (o));\n\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  CompileCallArgsAndReturn  (IM3Compilation o, u16 * o_stackOffset, IM3FuncType i_type, bool i_isIndirect)\n{\n_try {\n\n    u16 topSlot = GetMaxUsedSlotPlusOne (o);\n\n    // force use of at least one stack slot; this is to help ensure\n    // the m3 stack overflows (and traps) before the native stack can overflow.\n    // e.g. see Wasm spec test 'runaway' in call.wast\n    topSlot = M3_MAX (1, topSlot);\n\n    // stack frame is 64-bit aligned\n    AlignSlotToType (& topSlot, c_m3Type_i64);\n\n    * o_stackOffset = topSlot;\n\n    // wait to pop this here so that topSlot search is correct\n    if (i_isIndirect)\n_       (Pop (o));\n\n    u16 numArgs = GetFuncTypeNumParams (i_type);\n    u16 numRets = GetFuncTypeNumResults (i_type);\n\n    u16 argTop = topSlot + (numArgs + numRets) * c_ioSlotCount;\n\n    while (numArgs--)\n    {\n_       (CopyStackTopToSlot (o, argTop -= c_ioSlotCount));\n_       (Pop (o));\n    }\n\n    u16 i = 0;\n    while (numRets--)\n    {\n        u8 type = GetFuncTypeResultType (i_type, i++);\n\n_       (Push (o, type, topSlot));\n        MarkSlotsAllocatedByType (o, topSlot, type);\n\n        topSlot += c_ioSlotCount;\n    }\n\n    } _catch: return result;\n}\n\nstatic\nM3Result  Compile_Call  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u32 functionIndex;\n_   (ReadLEB_u32 (& functionIndex, & o->wasm, o->wasmEnd));\n\n    IM3Function function = Module_GetFunction (o->module, functionIndex);\n\n    if (function)\n    {                                                                   m3log (compile, d_indent \" (func= [%d] '%s'; args= %d)\",\n                                                                                get_indention_string (o), functionIndex, m3_GetFunctionName (function), function->funcType->numArgs);\n        if (function->module)\n        {\n            u16 slotTop;\n_           (CompileCallArgsAndReturn (o, & slotTop, function->funcType, false));\n\n            IM3Operation op;\n            const void * operand;\n\n            if (function->compiled)\n            {\n                op = op_Call;\n                operand = function->compiled;\n            }\n            else\n            {\n                op = op_Compile;\n                operand = function;\n            }\n\n_           (EmitOp     (o, op));\n            EmitPointer (o, operand);\n            EmitSlotOffset  (o, slotTop);\n        }\n        else\n        {\n            _throw (ErrorCompile (m3Err_functionImportMissing, o, \"'%s.%s'\", GetFunctionImportModuleName (function), m3_GetFunctionName (function)));\n        }\n    }\n    else _throw (m3Err_functionLookupFailed);\n\n    } _catch: return result;\n}\n\nstatic\nM3Result  Compile_CallIndirect  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u32 typeIndex;\n_   (ReadLEB_u32 (& typeIndex, & o->wasm, o->wasmEnd));\n\n    u32 tableIndex;\n_   (ReadLEB_u32 (& tableIndex, & o->wasm, o->wasmEnd));\n\n    _throwif (\"function call type index out of range\", typeIndex >= o->module->numFuncTypes);\n\n    if (IsStackTopInRegister (o))\n_       (PreserveRegisterIfOccupied (o, c_m3Type_i32));\n\n    u16 tableIndexSlot = GetStackTopSlotNumber (o);\n\n    u16 execTop;\n    IM3FuncType type = o->module->funcTypes [typeIndex];\n_   (CompileCallArgsAndReturn (o, & execTop, type, true));\n\n_   (EmitOp         (o, op_CallIndirect));\n    EmitSlotOffset  (o, tableIndexSlot);\n    EmitPointer     (o, o->module);\n    EmitPointer     (o, type);              // TODO: unify all types in M3Environment\n    EmitSlotOffset  (o, execTop);\n\n} _catch:\n    return result;\n}\n\nstatic\nM3Result  Compile_Memory_Size  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i8 reserved;\n_   (ReadLEB_i7 (& reserved, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i32));\n\n_   (EmitOp     (o, op_MemSize));\n\n_   (PushRegister (o, c_m3Type_i32));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Memory_Grow  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i8 reserved;\n_   (ReadLEB_i7 (& reserved, & o->wasm, o->wasmEnd));\n\n_   (CopyStackTopToRegister (o, false));\n_   (PopType (o, c_m3Type_i32));\n\n_   (EmitOp     (o, op_MemGrow));\n\n_   (PushRegister (o, c_m3Type_i32));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Memory_CopyFill  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    u32 sourceMemoryIdx, targetMemoryIdx;\n    IM3Operation op;\n    if (i_opcode == c_waOp_memoryCopy)\n    {\n_       (ReadLEB_u32 (& sourceMemoryIdx, & o->wasm, o->wasmEnd));\n        op = op_MemCopy;\n    }\n    else op = op_MemFill;\n\n_   (ReadLEB_u32 (& targetMemoryIdx, & o->wasm, o->wasmEnd));\n\n_   (CopyStackTopToRegister (o, false));\n\n_   (EmitOp  (o, op));\n_   (PopType (o, c_m3Type_i32));\n_   (EmitSlotNumOfStackTopAndPop (o));\n_   (EmitSlotNumOfStackTopAndPop (o));\n\n    _catch: return result;\n}\n\n\nstatic\nM3Result  ReadBlockType  (IM3Compilation o, IM3FuncType * o_blockType)\n{\n    M3Result result;\n\n    i64 type;\n_   (ReadLebSigned (& type, 33, & o->wasm, o->wasmEnd));\n\n    if (type < 0)\n    {\n        u8 valueType;\n_       (NormalizeType (&valueType, type));                                m3log (compile, d_indent \" (type: %s)\", get_indention_string (o), c_waTypes [valueType]);\n        *o_blockType = o->module->environment->retFuncTypes[valueType];\n    }\n    else\n    {\n        _throwif(\"func type out of bounds\", type >= o->module->numFuncTypes);\n        *o_blockType = o->module->funcTypes[type];                         m3log (compile, d_indent \" (type: %s)\", get_indention_string (o), SPrintFuncTypeSignature (*o_blockType));\n    }\n    _catch: return result;\n}\n\nstatic\nM3Result  PreserveArgsAndLocals  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    if (o->stackIndex > o->stackFirstDynamicIndex)\n    {\n        u32 numArgsAndLocals = GetFunctionNumArgsAndLocals (o->function);\n\n        for (u32 i = 0; i < numArgsAndLocals; ++i)\n        {\n            u16 slot = GetSlotForStackIndex (o, i);\n\n            u16 preservedSlotNumber;\n_           (FindReferencedLocalWithinCurrentBlock (o, & preservedSlotNumber, slot));\n\n            if (preservedSlotNumber != slot)\n            {\n                u8 type = GetStackTypeFromBottom (o, i);                    d_m3Assert (type != c_m3Type_none)\n                IM3Operation op = Is64BitType (type) ? op_CopySlot_64 : op_CopySlot_32;\n\n                EmitOp          (o, op);\n                EmitSlotOffset  (o, preservedSlotNumber);\n                EmitSlotOffset  (o, slot);\n            }\n        }\n    }\n\n    _catch:\n    return result;\n}\n\nstatic\nM3Result  Compile_LoopOrBlock  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    // TODO: these shouldn't be necessary for non-loop blocks?\n_   (PreserveRegisters (o));\n_   (PreserveArgsAndLocals (o));\n\n    IM3FuncType blockType;\n_   (ReadBlockType (o, & blockType));\n\n    if (i_opcode == c_waOp_loop)\n    {\n        u16 numParams = GetFuncTypeNumParams (blockType);\n        if (numParams)\n        {\n            // instantiate constants\n            u16 numValues = GetNumBlockValuesOnStack (o);                   // CompileBlock enforces this at comptime\n                                                                            d_m3Assert (numValues >= numParams);\n            if (numValues >= numParams)\n            {\n                u16 stackTop = GetStackTopIndex (o) + 1;\n\n                for (u16 i = stackTop - numParams; i < stackTop; ++i)\n                {\n                    u16 slot = GetSlotForStackIndex (o, i);\n                    u8 type = GetStackTypeFromBottom (o, i);\n\n                    if (IsConstantSlot (o, slot))\n                    {\n                        u16 newSlot = c_slotUnused;\n_                       (AllocateSlots (o, & newSlot, type));\n_                       (CopyStackIndexToSlot (o, newSlot, i));\n                        o->wasmStack [i] = newSlot;\n                    }\n                }\n            }\n        }\n\n_       (EmitOp (o, op_Loop));\n    }\n    else\n    {\n    }\n\n_   (CompileBlock (o, blockType, i_opcode));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  CompileElseBlock  (IM3Compilation o, pc_t * o_startPC, IM3FuncType i_blockType)\n{\n    IM3CodePage savedPage = o->page;\n_try {\n\n    IM3CodePage elsePage;\n_   (AcquireCompilationCodePage (o, & elsePage));\n\n    * o_startPC = GetPagePC (elsePage);\n\n    o->page = elsePage;\n\n_   (CompileBlock (o, i_blockType, c_waOp_else));\n\n_   (EmitOp (o, op_Branch));\n    EmitPointer (o, GetPagePC (savedPage));\n} _catch:\n    if(o->page != savedPage) {\n        ReleaseCompilationCodePage (o);\n    }\n    o->page = savedPage;\n    return result;\n}\n\nstatic\nM3Result  Compile_If  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    /*      [   op_If   ]\n            [ <else-pc> ]   ---->   [ ..else..  ]\n            [  ..if..   ]           [ ..block.. ]\n            [ ..block.. ]           [ op_Branch ]\n            [    end    ]  <-----   [  <end-pc> ]       */\n\n_try {\n\n_   (PreserveNonTopRegisters (o));\n_   (PreserveArgsAndLocals (o));\n\n    IM3Operation op = IsStackTopInRegister (o) ? op_If_r : op_If_s;\n\n_   (EmitOp (o, op));\n_   (EmitSlotNumOfStackTopAndPop (o));\n\n    pc_t * pc = (pc_t *) ReservePointer (o);\n\n    IM3FuncType blockType;\n_   (ReadBlockType (o, & blockType));\n\n//  dump_type_stack (o);\n\n    u16 stackIndex = o->stackIndex;\n\n_   (CompileBlock (o, blockType, i_opcode));\n\n    if (o->previousOpcode == c_waOp_else)\n    {\n        o->stackIndex = stackIndex;\n_       (CompileElseBlock (o, pc, blockType));\n    }\n    else\n    {\n        // if block produces values and there isn't a defined else\n        // case, then we need to make one up so that the pass-through\n        // results end up in the right place\n        if (GetFuncTypeNumResults (blockType))\n        {\n            // rewind to the if's end to create a fake else block\n            o->wasm--;\n            o->stackIndex = stackIndex;\n\n//          dump_type_stack (o);\n\n_           (CompileElseBlock (o, pc, blockType));\n        }\n        else * pc = GetPC (o);\n    }\n\n    } _catch: return result;\n}\n\nstatic\nM3Result  Compile_Select  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    u16 slots [3] = { c_slotUnused, c_slotUnused, c_slotUnused };\n\n    u8 type = GetStackTypeFromTop (o, 1); // get type of selection\n\n    IM3Operation op = NULL;\n\n    if (IsFpType (type))\n    {\n#   if d_m3HasFloat\n        // not consuming a fp reg, so preserve\n        if (not IsStackTopMinus1InRegister (o) and\n            not IsStackTopMinus2InRegister (o))\n        {\n_           (PreserveRegisterIfOccupied (o, type));\n        }\n\n        bool selectorInReg = IsStackTopInRegister (o);\n        slots [0] = GetStackTopSlotNumber (o);\n_       (Pop (o));\n\n        u32 opIndex = 0;\n\n        for (u32 i = 1; i <= 2; ++i)\n        {\n            if (IsStackTopInRegister (o))\n                opIndex = i;\n            else\n                slots [i] = GetStackTopSlotNumber (o);\n\n_          (Pop (o));\n        }\n\n        op = c_fpSelectOps [type - c_m3Type_f32] [selectorInReg] [opIndex];\n#   else\n        _throw (m3Err_unknownOpcode);\n#   endif\n    }\n    else if (IsIntType (type))\n    {\n        // 'sss' operation doesn't consume a register, so might have to protected its contents\n        if (not IsStackTopInRegister (o) and\n            not IsStackTopMinus1InRegister (o) and\n            not IsStackTopMinus2InRegister (o))\n        {\n_           (PreserveRegisterIfOccupied (o, type));\n        }\n\n        u32 opIndex = 3;  // op_Select_*_sss\n\n        for (u32 i = 0; i < 3; ++i)\n        {\n            if (IsStackTopInRegister (o))\n                opIndex = i;\n            else\n                slots [i] = GetStackTopSlotNumber (o);\n\n_          (Pop (o));\n        }\n\n        op = c_intSelectOps [type - c_m3Type_i32] [opIndex];\n    }\n    else if (not IsStackPolymorphic (o))\n        _throw (m3Err_functionStackUnderrun);\n\n    EmitOp (o, op);\n    for (u32 i = 0; i < 3; i++)\n    {\n        if (IsValidSlot (slots [i]))\n            EmitSlotOffset (o, slots [i]);\n    }\n_   (PushRegister (o, type));\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Drop  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = Pop (o);                                              if (d_m3LogWasmStack) dump_type_stack (o);\n    return result;\n}\n\nstatic\nM3Result  Compile_Nop  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    return m3Err_none;\n}\n\nstatic\nM3Result  Compile_Unreachable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n_   (AddTrapRecord (o));\n\n_   (EmitOp (o, op_Unreachable));\n_   (SetStackPolymorphic (o));\n\n    _catch:\n    return result;\n}\n\n\n// OPTZ: currently all stack slot indices take up a full word, but\n// dual stack source operands could be packed together\nstatic\nM3Result  Compile_Operator  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    IM3OpInfo opInfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opInfo);\n\n    IM3Operation op;\n\n    // This preserve is for for FP compare operations.\n    // either need additional slot destination operations or the\n    // easy fix, move _r0 out of the way.\n    // moving out the way might be the optimal solution most often?\n    // otherwise, the _r0 reg can get buried down in the stack\n    // and be idle & wasted for a moment.\n    if (IsFpType (GetStackTopType (o)) and IsIntType (opInfo->type))\n    {\n_       (PreserveRegisterIfOccupied (o, opInfo->type));\n    }\n\n    if (opInfo->stackOffset == 0)\n    {\n        if (IsStackTopInRegister (o))\n        {\n            op = opInfo->operations [0]; // _s\n        }\n        else\n        {\n_           (PreserveRegisterIfOccupied (o, opInfo->type));\n            op = opInfo->operations [1]; // _r\n        }\n    }\n    else\n    {\n        if (IsStackTopInRegister (o))\n        {\n            op = opInfo->operations [0];  // _rs\n\n            if (IsStackTopMinus1InRegister (o))\n            {                                       d_m3Assert (i_opcode == c_waOp_store_f32 or i_opcode == c_waOp_store_f64);\n                op = opInfo->operations [3]; // _rr for fp.store\n            }\n        }\n        else if (IsStackTopMinus1InRegister (o))\n        {\n            op = opInfo->operations [1]; // _sr\n\n            if (not op)  // must be commutative, then\n                op = opInfo->operations [0];\n        }\n        else\n        {\n_           (PreserveRegisterIfOccupied (o, opInfo->type));     // _ss\n            op = opInfo->operations [2];\n        }\n    }\n\n    if (op)\n    {\n_       (EmitOp (o, op));\n\n_       (EmitSlotNumOfStackTopAndPop (o));\n\n        if (opInfo->stackOffset < 0)\n_           (EmitSlotNumOfStackTopAndPop (o));\n\n        if (opInfo->type != c_m3Type_none)\n_           (PushRegister (o, opInfo->type));\n    }\n    else\n    {\n#       ifdef DEBUG\n            result = ErrorCompile (\"no operation found for opcode\", o, \"'%s'\", opInfo->name);\n#       else\n            result = ErrorCompile (\"no operation found for opcode\", o, \"%x\", i_opcode);\n#       endif\n        _throw (result);\n    }\n\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Convert  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    IM3OpInfo opInfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opInfo);\n\n    bool destInSlot = IsRegisterTypeAllocated (o, opInfo->type);\n    bool sourceInSlot = IsStackTopInSlot (o);\n\n    IM3Operation op = opInfo->operations [destInSlot * 2 + sourceInSlot];\n\n_   (EmitOp (o, op));\n_   (EmitSlotNumOfStackTopAndPop (o));\n\n    if (destInSlot)\n_       (PushAllocatedSlotAndEmit (o, opInfo->type))\n    else\n_       (PushRegister (o, opInfo->type))\n\n}\n    _catch: return result;\n}\n\nstatic\nM3Result  Compile_Load_Store  (IM3Compilation o, m3opcode_t i_opcode)\n{\n_try {\n    u32 alignHint, memoryOffset;\n\n_   (ReadLEB_u32 (& alignHint, & o->wasm, o->wasmEnd));\n_   (ReadLEB_u32 (& memoryOffset, & o->wasm, o->wasmEnd));\n                                                                        m3log (compile, d_indent \" (offset = %d)\", get_indention_string (o), memoryOffset);\n    IM3OpInfo opInfo = GetOpInfo (i_opcode);\n    _throwif (m3Err_unknownOpcode, not opInfo);\n\n    if (IsFpType (opInfo->type))\n_       (PreserveRegisterIfOccupied (o, c_m3Type_f64));\n\n_   (Compile_Operator (o, i_opcode));\n\n    EmitConstant32 (o, memoryOffset);\n}\n    _catch: return result;\n}\n\n\nM3Result  CompileRawFunction  (IM3Module io_module,  IM3Function io_function, const void * i_function, const void * i_userdata)\n{\n    d_m3Assert (io_module->runtime);\n\n    IM3CodePage page = AcquireCodePageWithCapacity (io_module->runtime, 4);\n\n    if (page)\n    {\n        io_function->compiled = GetPagePC (page);\n        io_function->module = io_module;\n\n        EmitWord (page, op_CallRawFunction);\n        EmitWord (page, i_function);\n        EmitWord (page, io_function);\n        EmitWord (page, i_userdata);\n\n        ReleaseCodePage (io_module->runtime, page);\n        return m3Err_none;\n    }\n    else {\n        return m3Err_mallocFailedCodePage;\n    }\n}\n\n\n// d_logOp, d_logOp2 macros aren't actually used by the compiler, just codepage decoding (d_m3LogCodePages = 1)\n#define d_logOp(OP)                         { op_##OP,                  NULL,                       NULL,                       NULL }\n#define d_logOp2(OP1,OP2)                   { op_##OP1,                 op_##OP2,                   NULL,                       NULL }\n\n#define d_emptyOpList                       { NULL,                     NULL,                       NULL,                       NULL }\n#define d_unaryOpList(TYPE, NAME)           { op_##TYPE##_##NAME##_r,   op_##TYPE##_##NAME##_s,     NULL,                       NULL }\n#define d_binOpList(TYPE, NAME)             { op_##TYPE##_##NAME##_rs,  op_##TYPE##_##NAME##_sr,    op_##TYPE##_##NAME##_ss,    NULL }\n#define d_storeFpOpList(TYPE, NAME)         { op_##TYPE##_##NAME##_rs,  op_##TYPE##_##NAME##_sr,    op_##TYPE##_##NAME##_ss,    op_##TYPE##_##NAME##_rr }\n#define d_commutativeBinOpList(TYPE, NAME)  { op_##TYPE##_##NAME##_rs,  NULL,                       op_##TYPE##_##NAME##_ss,    NULL }\n#define d_convertOpList(OP)                 { op_##OP##_r_r,            op_##OP##_r_s,              op_##OP##_s_r,              op_##OP##_s_s }\n\n\nconst M3OpInfo c_operations [] =\n{\n    M3OP( \"unreachable\",         0, none,   d_logOp (Unreachable),              Compile_Unreachable ),  // 0x00\n    M3OP( \"nop\",                 0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x01 .\n    M3OP( \"block\",               0, none,   d_emptyOpList,                      Compile_LoopOrBlock ),  // 0x02\n    M3OP( \"loop\",                0, none,   d_logOp (Loop),                     Compile_LoopOrBlock ),  // 0x03\n    M3OP( \"if\",                 -1, none,   d_emptyOpList,                      Compile_If ),           // 0x04\n    M3OP( \"else\",                0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x05\n\n    M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                          // 0x06...0x0a\n\n    M3OP( \"end\",                 0, none,   d_emptyOpList,                      Compile_End ),          // 0x0b\n    M3OP( \"br\",                  0, none,   d_logOp (Branch),                   Compile_Branch ),       // 0x0c\n    M3OP( \"br_if\",              -1, none,   d_logOp2 (BranchIf_r, BranchIf_s),  Compile_Branch ),       // 0x0d\n    M3OP( \"br_table\",           -1, none,   d_logOp (BranchTable),              Compile_BranchTable ),  // 0x0e\n    M3OP( \"return\",              0, any,    d_logOp (Return),                   Compile_Return ),       // 0x0f\n    M3OP( \"call\",                0, any,    d_logOp (Call),                     Compile_Call ),         // 0x10\n    M3OP( \"call_indirect\",       0, any,    d_logOp (CallIndirect),             Compile_CallIndirect ), // 0x11\n    M3OP( \"return_call\",         0, any,    d_emptyOpList,                      Compile_Call ),         // 0x12 TODO: Optimize\n    M3OP( \"return_call_indirect\",0, any,    d_emptyOpList,                      Compile_CallIndirect ), // 0x13\n\n    M3OP_RESERVED,  M3OP_RESERVED,                                                                      // 0x14...\n    M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // ...0x19\n\n    M3OP( \"drop\",               -1, none,   d_emptyOpList,                      Compile_Drop ),         // 0x1a\n    M3OP( \"select\",             -2, any,    d_emptyOpList,                      Compile_Select  ),      // 0x1b\n\n    M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // 0x1c...0x1f\n\n    M3OP( \"local.get\",          1,  any,    d_emptyOpList,                      Compile_GetLocal ),     // 0x20\n    M3OP( \"local.set\",          1,  none,   d_emptyOpList,                      Compile_SetLocal ),     // 0x21\n    M3OP( \"local.tee\",          0,  any,    d_emptyOpList,                      Compile_SetLocal ),     // 0x22\n    M3OP( \"global.get\",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x23\n    M3OP( \"global.set\",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x24\n\n    M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED,                                                       // 0x25...0x27\n\n    M3OP( \"i32.load\",           0,  i_32,   d_unaryOpList (i32, Load_i32),      Compile_Load_Store ),   // 0x28\n    M3OP( \"i64.load\",           0,  i_64,   d_unaryOpList (i64, Load_i64),      Compile_Load_Store ),   // 0x29\n    M3OP_F( \"f32.load\",         0,  f_32,   d_unaryOpList (f32, Load_f32),      Compile_Load_Store ),   // 0x2a\n    M3OP_F( \"f64.load\",         0,  f_64,   d_unaryOpList (f64, Load_f64),      Compile_Load_Store ),   // 0x2b\n\n    M3OP( \"i32.load8_s\",        0,  i_32,   d_unaryOpList (i32, Load_i8),       Compile_Load_Store ),   // 0x2c\n    M3OP( \"i32.load8_u\",        0,  i_32,   d_unaryOpList (i32, Load_u8),       Compile_Load_Store ),   // 0x2d\n    M3OP( \"i32.load16_s\",       0,  i_32,   d_unaryOpList (i32, Load_i16),      Compile_Load_Store ),   // 0x2e\n    M3OP( \"i32.load16_u\",       0,  i_32,   d_unaryOpList (i32, Load_u16),      Compile_Load_Store ),   // 0x2f\n\n    M3OP( \"i64.load8_s\",        0,  i_64,   d_unaryOpList (i64, Load_i8),       Compile_Load_Store ),   // 0x30\n    M3OP( \"i64.load8_u\",        0,  i_64,   d_unaryOpList (i64, Load_u8),       Compile_Load_Store ),   // 0x31\n    M3OP( \"i64.load16_s\",       0,  i_64,   d_unaryOpList (i64, Load_i16),      Compile_Load_Store ),   // 0x32\n    M3OP( \"i64.load16_u\",       0,  i_64,   d_unaryOpList (i64, Load_u16),      Compile_Load_Store ),   // 0x33\n    M3OP( \"i64.load32_s\",       0,  i_64,   d_unaryOpList (i64, Load_i32),      Compile_Load_Store ),   // 0x34\n    M3OP( \"i64.load32_u\",       0,  i_64,   d_unaryOpList (i64, Load_u32),      Compile_Load_Store ),   // 0x35\n\n    M3OP( \"i32.store\",          -2, none,   d_binOpList (i32, Store_i32),       Compile_Load_Store ),   // 0x36\n    M3OP( \"i64.store\",          -2, none,   d_binOpList (i64, Store_i64),       Compile_Load_Store ),   // 0x37\n    M3OP_F( \"f32.store\",        -2, none,   d_storeFpOpList (f32, Store_f32),   Compile_Load_Store ),   // 0x38\n    M3OP_F( \"f64.store\",        -2, none,   d_storeFpOpList (f64, Store_f64),   Compile_Load_Store ),   // 0x39\n\n    M3OP( \"i32.store8\",         -2, none,   d_binOpList (i32, Store_u8),        Compile_Load_Store ),   // 0x3a\n    M3OP( \"i32.store16\",        -2, none,   d_binOpList (i32, Store_i16),       Compile_Load_Store ),   // 0x3b\n\n    M3OP( \"i64.store8\",         -2, none,   d_binOpList (i64, Store_u8),        Compile_Load_Store ),   // 0x3c\n    M3OP( \"i64.store16\",        -2, none,   d_binOpList (i64, Store_i16),       Compile_Load_Store ),   // 0x3d\n    M3OP( \"i64.store32\",        -2, none,   d_binOpList (i64, Store_i32),       Compile_Load_Store ),   // 0x3e\n\n    M3OP( \"memory.size\",        1,  i_32,   d_logOp (MemSize),                  Compile_Memory_Size ),  // 0x3f\n    M3OP( \"memory.grow\",        1,  i_32,   d_logOp (MemGrow),                  Compile_Memory_Grow ),  // 0x40\n\n    M3OP( \"i32.const\",          1,  i_32,   d_logOp (Const32),                  Compile_Const_i32 ),    // 0x41\n    M3OP( \"i64.const\",          1,  i_64,   d_logOp (Const64),                  Compile_Const_i64 ),    // 0x42\n    M3OP_F( \"f32.const\",        1,  f_32,   d_emptyOpList,                      Compile_Const_f32 ),    // 0x43\n    M3OP_F( \"f64.const\",        1,  f_64,   d_emptyOpList,                      Compile_Const_f64 ),    // 0x44\n\n    M3OP( \"i32.eqz\",            0,  i_32,   d_unaryOpList (i32, EqualToZero)        , NULL  ),          // 0x45\n    M3OP( \"i32.eq\",             -1, i_32,   d_commutativeBinOpList (i32, Equal)     , NULL  ),          // 0x46\n    M3OP( \"i32.ne\",             -1, i_32,   d_commutativeBinOpList (i32, NotEqual)  , NULL  ),          // 0x47\n    M3OP( \"i32.lt_s\",           -1, i_32,   d_binOpList (i32, LessThan)             , NULL  ),          // 0x48\n    M3OP( \"i32.lt_u\",           -1, i_32,   d_binOpList (u32, LessThan)             , NULL  ),          // 0x49\n    M3OP( \"i32.gt_s\",           -1, i_32,   d_binOpList (i32, GreaterThan)          , NULL  ),          // 0x4a\n    M3OP( \"i32.gt_u\",           -1, i_32,   d_binOpList (u32, GreaterThan)          , NULL  ),          // 0x4b\n    M3OP( \"i32.le_s\",           -1, i_32,   d_binOpList (i32, LessThanOrEqual)      , NULL  ),          // 0x4c\n    M3OP( \"i32.le_u\",           -1, i_32,   d_binOpList (u32, LessThanOrEqual)      , NULL  ),          // 0x4d\n    M3OP( \"i32.ge_s\",           -1, i_32,   d_binOpList (i32, GreaterThanOrEqual)   , NULL  ),          // 0x4e\n    M3OP( \"i32.ge_u\",           -1, i_32,   d_binOpList (u32, GreaterThanOrEqual)   , NULL  ),          // 0x4f\n\n    M3OP( \"i64.eqz\",            0,  i_32,   d_unaryOpList (i64, EqualToZero)        , NULL  ),          // 0x50\n    M3OP( \"i64.eq\",             -1, i_32,   d_commutativeBinOpList (i64, Equal)     , NULL  ),          // 0x51\n    M3OP( \"i64.ne\",             -1, i_32,   d_commutativeBinOpList (i64, NotEqual)  , NULL  ),          // 0x52\n    M3OP( \"i64.lt_s\",           -1, i_32,   d_binOpList (i64, LessThan)             , NULL  ),          // 0x53\n    M3OP( \"i64.lt_u\",           -1, i_32,   d_binOpList (u64, LessThan)             , NULL  ),          // 0x54\n    M3OP( \"i64.gt_s\",           -1, i_32,   d_binOpList (i64, GreaterThan)          , NULL  ),          // 0x55\n    M3OP( \"i64.gt_u\",           -1, i_32,   d_binOpList (u64, GreaterThan)          , NULL  ),          // 0x56\n    M3OP( \"i64.le_s\",           -1, i_32,   d_binOpList (i64, LessThanOrEqual)      , NULL  ),          // 0x57\n    M3OP( \"i64.le_u\",           -1, i_32,   d_binOpList (u64, LessThanOrEqual)      , NULL  ),          // 0x58\n    M3OP( \"i64.ge_s\",           -1, i_32,   d_binOpList (i64, GreaterThanOrEqual)   , NULL  ),          // 0x59\n    M3OP( \"i64.ge_u\",           -1, i_32,   d_binOpList (u64, GreaterThanOrEqual)   , NULL  ),          // 0x5a\n\n    M3OP_F( \"f32.eq\",           -1, i_32,   d_commutativeBinOpList (f32, Equal)     , NULL  ),          // 0x5b\n    M3OP_F( \"f32.ne\",           -1, i_32,   d_commutativeBinOpList (f32, NotEqual)  , NULL  ),          // 0x5c\n    M3OP_F( \"f32.lt\",           -1, i_32,   d_binOpList (f32, LessThan)             , NULL  ),          // 0x5d\n    M3OP_F( \"f32.gt\",           -1, i_32,   d_binOpList (f32, GreaterThan)          , NULL  ),          // 0x5e\n    M3OP_F( \"f32.le\",           -1, i_32,   d_binOpList (f32, LessThanOrEqual)      , NULL  ),          // 0x5f\n    M3OP_F( \"f32.ge\",           -1, i_32,   d_binOpList (f32, GreaterThanOrEqual)   , NULL  ),          // 0x60\n\n    M3OP_F( \"f64.eq\",           -1, i_32,   d_commutativeBinOpList (f64, Equal)     , NULL  ),          // 0x61\n    M3OP_F( \"f64.ne\",           -1, i_32,   d_commutativeBinOpList (f64, NotEqual)  , NULL  ),          // 0x62\n    M3OP_F( \"f64.lt\",           -1, i_32,   d_binOpList (f64, LessThan)             , NULL  ),          // 0x63\n    M3OP_F( \"f64.gt\",           -1, i_32,   d_binOpList (f64, GreaterThan)          , NULL  ),          // 0x64\n    M3OP_F( \"f64.le\",           -1, i_32,   d_binOpList (f64, LessThanOrEqual)      , NULL  ),          // 0x65\n    M3OP_F( \"f64.ge\",           -1, i_32,   d_binOpList (f64, GreaterThanOrEqual)   , NULL  ),          // 0x66\n\n    M3OP( \"i32.clz\",            0,  i_32,   d_unaryOpList (u32, Clz)                , NULL  ),          // 0x67\n    M3OP( \"i32.ctz\",            0,  i_32,   d_unaryOpList (u32, Ctz)                , NULL  ),          // 0x68\n    M3OP( \"i32.popcnt\",         0,  i_32,   d_unaryOpList (u32, Popcnt)             , NULL  ),          // 0x69\n\n    M3OP( \"i32.add\",            -1, i_32,   d_commutativeBinOpList (i32, Add)       , NULL  ),          // 0x6a\n    M3OP( \"i32.sub\",            -1, i_32,   d_binOpList (i32, Subtract)             , NULL  ),          // 0x6b\n    M3OP( \"i32.mul\",            -1, i_32,   d_commutativeBinOpList (i32, Multiply)  , NULL  ),          // 0x6c\n    M3OP( \"i32.div_s\",          -1, i_32,   d_binOpList (i32, Divide)               , NULL  ),          // 0x6d\n    M3OP( \"i32.div_u\",          -1, i_32,   d_binOpList (u32, Divide)               , NULL  ),          // 0x6e\n    M3OP( \"i32.rem_s\",          -1, i_32,   d_binOpList (i32, Remainder)            , NULL  ),          // 0x6f\n    M3OP( \"i32.rem_u\",          -1, i_32,   d_binOpList (u32, Remainder)            , NULL  ),          // 0x70\n    M3OP( \"i32.and\",            -1, i_32,   d_commutativeBinOpList (u32, And)       , NULL  ),          // 0x71\n    M3OP( \"i32.or\",             -1, i_32,   d_commutativeBinOpList (u32, Or)        , NULL  ),          // 0x72\n    M3OP( \"i32.xor\",            -1, i_32,   d_commutativeBinOpList (u32, Xor)       , NULL  ),          // 0x73\n    M3OP( \"i32.shl\",            -1, i_32,   d_binOpList (u32, ShiftLeft)            , NULL  ),          // 0x74\n    M3OP( \"i32.shr_s\",          -1, i_32,   d_binOpList (i32, ShiftRight)           , NULL  ),          // 0x75\n    M3OP( \"i32.shr_u\",          -1, i_32,   d_binOpList (u32, ShiftRight)           , NULL  ),          // 0x76\n    M3OP( \"i32.rotl\",           -1, i_32,   d_binOpList (u32, Rotl)                 , NULL  ),          // 0x77\n    M3OP( \"i32.rotr\",           -1, i_32,   d_binOpList (u32, Rotr)                 , NULL  ),          // 0x78\n\n    M3OP( \"i64.clz\",            0,  i_64,   d_unaryOpList (u64, Clz)                , NULL  ),          // 0x79\n    M3OP( \"i64.ctz\",            0,  i_64,   d_unaryOpList (u64, Ctz)                , NULL  ),          // 0x7a\n    M3OP( \"i64.popcnt\",         0,  i_64,   d_unaryOpList (u64, Popcnt)             , NULL  ),          // 0x7b\n\n    M3OP( \"i64.add\",            -1, i_64,   d_commutativeBinOpList (i64, Add)       , NULL  ),          // 0x7c\n    M3OP( \"i64.sub\",            -1, i_64,   d_binOpList (i64, Subtract)             , NULL  ),          // 0x7d\n    M3OP( \"i64.mul\",            -1, i_64,   d_commutativeBinOpList (i64, Multiply)  , NULL  ),          // 0x7e\n    M3OP( \"i64.div_s\",          -1, i_64,   d_binOpList (i64, Divide)               , NULL  ),          // 0x7f\n    M3OP( \"i64.div_u\",          -1, i_64,   d_binOpList (u64, Divide)               , NULL  ),          // 0x80\n    M3OP( \"i64.rem_s\",          -1, i_64,   d_binOpList (i64, Remainder)            , NULL  ),          // 0x81\n    M3OP( \"i64.rem_u\",          -1, i_64,   d_binOpList (u64, Remainder)            , NULL  ),          // 0x82\n    M3OP( \"i64.and\",            -1, i_64,   d_commutativeBinOpList (u64, And)       , NULL  ),          // 0x83\n    M3OP( \"i64.or\",             -1, i_64,   d_commutativeBinOpList (u64, Or)        , NULL  ),          // 0x84\n    M3OP( \"i64.xor\",            -1, i_64,   d_commutativeBinOpList (u64, Xor)       , NULL  ),          // 0x85\n    M3OP( \"i64.shl\",            -1, i_64,   d_binOpList (u64, ShiftLeft)            , NULL  ),          // 0x86\n    M3OP( \"i64.shr_s\",          -1, i_64,   d_binOpList (i64, ShiftRight)           , NULL  ),          // 0x87\n    M3OP( \"i64.shr_u\",          -1, i_64,   d_binOpList (u64, ShiftRight)           , NULL  ),          // 0x88\n    M3OP( \"i64.rotl\",           -1, i_64,   d_binOpList (u64, Rotl)                 , NULL  ),          // 0x89\n    M3OP( \"i64.rotr\",           -1, i_64,   d_binOpList (u64, Rotr)                 , NULL  ),          // 0x8a\n\n    M3OP_F( \"f32.abs\",          0,  f_32,   d_unaryOpList(f32, Abs)                 , NULL  ),          // 0x8b\n    M3OP_F( \"f32.neg\",          0,  f_32,   d_unaryOpList(f32, Negate)              , NULL  ),          // 0x8c\n    M3OP_F( \"f32.ceil\",         0,  f_32,   d_unaryOpList(f32, Ceil)                , NULL  ),          // 0x8d\n    M3OP_F( \"f32.floor\",        0,  f_32,   d_unaryOpList(f32, Floor)               , NULL  ),          // 0x8e\n    M3OP_F( \"f32.trunc\",        0,  f_32,   d_unaryOpList(f32, Trunc)               , NULL  ),          // 0x8f\n    M3OP_F( \"f32.nearest\",      0,  f_32,   d_unaryOpList(f32, Nearest)             , NULL  ),          // 0x90\n    M3OP_F( \"f32.sqrt\",         0,  f_32,   d_unaryOpList(f32, Sqrt)                , NULL  ),          // 0x91\n\n    M3OP_F( \"f32.add\",          -1, f_32,   d_commutativeBinOpList (f32, Add)       , NULL  ),          // 0x92\n    M3OP_F( \"f32.sub\",          -1, f_32,   d_binOpList (f32, Subtract)             , NULL  ),          // 0x93\n    M3OP_F( \"f32.mul\",          -1, f_32,   d_commutativeBinOpList (f32, Multiply)  , NULL  ),          // 0x94\n    M3OP_F( \"f32.div\",          -1, f_32,   d_binOpList (f32, Divide)               , NULL  ),          // 0x95\n    M3OP_F( \"f32.min\",          -1, f_32,   d_commutativeBinOpList (f32, Min)       , NULL  ),          // 0x96\n    M3OP_F( \"f32.max\",          -1, f_32,   d_commutativeBinOpList (f32, Max)       , NULL  ),          // 0x97\n    M3OP_F( \"f32.copysign\",     -1, f_32,   d_binOpList (f32, CopySign)             , NULL  ),          // 0x98\n\n    M3OP_F( \"f64.abs\",          0,  f_64,   d_unaryOpList(f64, Abs)                 , NULL  ),          // 0x99\n    M3OP_F( \"f64.neg\",          0,  f_64,   d_unaryOpList(f64, Negate)              , NULL  ),          // 0x9a\n    M3OP_F( \"f64.ceil\",         0,  f_64,   d_unaryOpList(f64, Ceil)                , NULL  ),          // 0x9b\n    M3OP_F( \"f64.floor\",        0,  f_64,   d_unaryOpList(f64, Floor)               , NULL  ),          // 0x9c\n    M3OP_F( \"f64.trunc\",        0,  f_64,   d_unaryOpList(f64, Trunc)               , NULL  ),          // 0x9d\n    M3OP_F( \"f64.nearest\",      0,  f_64,   d_unaryOpList(f64, Nearest)             , NULL  ),          // 0x9e\n    M3OP_F( \"f64.sqrt\",         0,  f_64,   d_unaryOpList(f64, Sqrt)                , NULL  ),          // 0x9f\n\n    M3OP_F( \"f64.add\",          -1, f_64,   d_commutativeBinOpList (f64, Add)       , NULL  ),          // 0xa0\n    M3OP_F( \"f64.sub\",          -1, f_64,   d_binOpList (f64, Subtract)             , NULL  ),          // 0xa1\n    M3OP_F( \"f64.mul\",          -1, f_64,   d_commutativeBinOpList (f64, Multiply)  , NULL  ),          // 0xa2\n    M3OP_F( \"f64.div\",          -1, f_64,   d_binOpList (f64, Divide)               , NULL  ),          // 0xa3\n    M3OP_F( \"f64.min\",          -1, f_64,   d_commutativeBinOpList (f64, Min)       , NULL  ),          // 0xa4\n    M3OP_F( \"f64.max\",          -1, f_64,   d_commutativeBinOpList (f64, Max)       , NULL  ),          // 0xa5\n    M3OP_F( \"f64.copysign\",     -1, f_64,   d_binOpList (f64, CopySign)             , NULL  ),          // 0xa6\n\n    M3OP( \"i32.wrap/i64\",       0,  i_32,   d_unaryOpList (i32, Wrap_i64),          NULL    ),          // 0xa7\n    M3OP_F( \"i32.trunc_s/f32\",  0,  i_32,   d_convertOpList (i32_Trunc_f32),        Compile_Convert ),  // 0xa8\n    M3OP_F( \"i32.trunc_u/f32\",  0,  i_32,   d_convertOpList (u32_Trunc_f32),        Compile_Convert ),  // 0xa9\n    M3OP_F( \"i32.trunc_s/f64\",  0,  i_32,   d_convertOpList (i32_Trunc_f64),        Compile_Convert ),  // 0xaa\n    M3OP_F( \"i32.trunc_u/f64\",  0,  i_32,   d_convertOpList (u32_Trunc_f64),        Compile_Convert ),  // 0xab\n\n    M3OP( \"i64.extend_s/i32\",   0,  i_64,   d_unaryOpList (i64, Extend_i32),        NULL    ),          // 0xac\n    M3OP( \"i64.extend_u/i32\",   0,  i_64,   d_unaryOpList (i64, Extend_u32),        NULL    ),          // 0xad\n\n    M3OP_F( \"i64.trunc_s/f32\",  0,  i_64,   d_convertOpList (i64_Trunc_f32),        Compile_Convert ),  // 0xae\n    M3OP_F( \"i64.trunc_u/f32\",  0,  i_64,   d_convertOpList (u64_Trunc_f32),        Compile_Convert ),  // 0xaf\n    M3OP_F( \"i64.trunc_s/f64\",  0,  i_64,   d_convertOpList (i64_Trunc_f64),        Compile_Convert ),  // 0xb0\n    M3OP_F( \"i64.trunc_u/f64\",  0,  i_64,   d_convertOpList (u64_Trunc_f64),        Compile_Convert ),  // 0xb1\n\n    M3OP_F( \"f32.convert_s/i32\",0,  f_32,   d_convertOpList (f32_Convert_i32),      Compile_Convert ),  // 0xb2\n    M3OP_F( \"f32.convert_u/i32\",0,  f_32,   d_convertOpList (f32_Convert_u32),      Compile_Convert ),  // 0xb3\n    M3OP_F( \"f32.convert_s/i64\",0,  f_32,   d_convertOpList (f32_Convert_i64),      Compile_Convert ),  // 0xb4\n    M3OP_F( \"f32.convert_u/i64\",0,  f_32,   d_convertOpList (f32_Convert_u64),      Compile_Convert ),  // 0xb5\n\n    M3OP_F( \"f32.demote/f64\",   0,  f_32,   d_unaryOpList (f32, Demote_f64),        NULL    ),          // 0xb6\n\n    M3OP_F( \"f64.convert_s/i32\",0,  f_64,   d_convertOpList (f64_Convert_i32),      Compile_Convert ),  // 0xb7\n    M3OP_F( \"f64.convert_u/i32\",0,  f_64,   d_convertOpList (f64_Convert_u32),      Compile_Convert ),  // 0xb8\n    M3OP_F( \"f64.convert_s/i64\",0,  f_64,   d_convertOpList (f64_Convert_i64),      Compile_Convert ),  // 0xb9\n    M3OP_F( \"f64.convert_u/i64\",0,  f_64,   d_convertOpList (f64_Convert_u64),      Compile_Convert ),  // 0xba\n\n    M3OP_F( \"f64.promote/f32\",  0,  f_64,   d_unaryOpList (f64, Promote_f32),       NULL    ),          // 0xbb\n\n    M3OP_F( \"i32.reinterpret/f32\",0,i_32,   d_convertOpList (i32_Reinterpret_f32),  Compile_Convert ),  // 0xbc\n    M3OP_F( \"i64.reinterpret/f64\",0,i_64,   d_convertOpList (i64_Reinterpret_f64),  Compile_Convert ),  // 0xbd\n    M3OP_F( \"f32.reinterpret/i32\",0,f_32,   d_convertOpList (f32_Reinterpret_i32),  Compile_Convert ),  // 0xbe\n    M3OP_F( \"f64.reinterpret/i64\",0,f_64,   d_convertOpList (f64_Reinterpret_i64),  Compile_Convert ),  // 0xbf\n\n    M3OP( \"i32.extend8_s\",       0,  i_32,   d_unaryOpList (i32, Extend8_s),        NULL    ),          // 0xc0\n    M3OP( \"i32.extend16_s\",      0,  i_32,   d_unaryOpList (i32, Extend16_s),       NULL    ),          // 0xc1\n    M3OP( \"i64.extend8_s\",       0,  i_64,   d_unaryOpList (i64, Extend8_s),        NULL    ),          // 0xc2\n    M3OP( \"i64.extend16_s\",      0,  i_64,   d_unaryOpList (i64, Extend16_s),       NULL    ),          // 0xc3\n    M3OP( \"i64.extend32_s\",      0,  i_64,   d_unaryOpList (i64, Extend32_s),       NULL    ),          // 0xc4\n\n# ifdef DEBUG // for codepage logging. the order doesn't matter:\n#   define d_m3DebugOp(OP) M3OP (#OP, 0, none, { op_##OP })\n\n# if d_m3HasFloat\n#   define d_m3DebugTypedOp(OP) M3OP (#OP, 0, none, { op_##OP##_i32, op_##OP##_i64, op_##OP##_f32, op_##OP##_f64, })\n# else\n#   define d_m3DebugTypedOp(OP) M3OP (#OP, 0, none, { op_##OP##_i32, op_##OP##_i64 })\n# endif\n\n    d_m3DebugOp (Compile),          d_m3DebugOp (Entry),            d_m3DebugOp (End),\n    d_m3DebugOp (Unsupported),      d_m3DebugOp (CallRawFunction),\n\n    d_m3DebugOp (GetGlobal_s32),    d_m3DebugOp (GetGlobal_s64),    d_m3DebugOp (ContinueLoop),     d_m3DebugOp (ContinueLoopIf),\n\n    d_m3DebugOp (CopySlot_32),      d_m3DebugOp (PreserveCopySlot_32), d_m3DebugOp (If_s),          d_m3DebugOp (BranchIfPrologue_s),\n    d_m3DebugOp (CopySlot_64),      d_m3DebugOp (PreserveCopySlot_64), d_m3DebugOp (If_r),          d_m3DebugOp (BranchIfPrologue_r),\n\n    d_m3DebugOp (Select_i32_rss),   d_m3DebugOp (Select_i32_srs),   d_m3DebugOp (Select_i32_ssr),   d_m3DebugOp (Select_i32_sss),\n    d_m3DebugOp (Select_i64_rss),   d_m3DebugOp (Select_i64_srs),   d_m3DebugOp (Select_i64_ssr),   d_m3DebugOp (Select_i64_sss),\n\n# if d_m3HasFloat\n    d_m3DebugOp (Select_f32_sss),   d_m3DebugOp (Select_f32_srs),   d_m3DebugOp (Select_f32_ssr),\n    d_m3DebugOp (Select_f32_rss),   d_m3DebugOp (Select_f32_rrs),   d_m3DebugOp (Select_f32_rsr),\n\n    d_m3DebugOp (Select_f64_sss),   d_m3DebugOp (Select_f64_srs),   d_m3DebugOp (Select_f64_ssr),\n    d_m3DebugOp (Select_f64_rss),   d_m3DebugOp (Select_f64_rrs),   d_m3DebugOp (Select_f64_rsr),\n# endif\n\n    d_m3DebugOp (MemFill),          d_m3DebugOp (MemCopy),\n\n    d_m3DebugTypedOp (SetGlobal),   d_m3DebugOp (SetGlobal_s32),    d_m3DebugOp (SetGlobal_s64),\n\n    d_m3DebugTypedOp (SetRegister), d_m3DebugTypedOp (SetSlot),     d_m3DebugTypedOp (PreserveSetSlot),\n# endif\n\n# if d_m3CascadedOpcodes\n    [c_waOp_extended] = M3OP( \"0xFC\", 0, c_m3Type_unknown,   d_emptyOpList,  Compile_ExtendedOpcode ),\n# endif\n\n# ifdef DEBUG\n    M3OP( \"termination\", 0, c_m3Type_unknown ) // for find_operation_info\n# endif\n};\n\nconst M3OpInfo c_operationsFC [] =\n{\n    M3OP_F( \"i32.trunc_s:sat/f32\",0,  i_32,   d_convertOpList (i32_TruncSat_f32),        Compile_Convert ),  // 0x00\n    M3OP_F( \"i32.trunc_u:sat/f32\",0,  i_32,   d_convertOpList (u32_TruncSat_f32),        Compile_Convert ),  // 0x01\n    M3OP_F( \"i32.trunc_s:sat/f64\",0,  i_32,   d_convertOpList (i32_TruncSat_f64),        Compile_Convert ),  // 0x02\n    M3OP_F( \"i32.trunc_u:sat/f64\",0,  i_32,   d_convertOpList (u32_TruncSat_f64),        Compile_Convert ),  // 0x03\n    M3OP_F( \"i64.trunc_s:sat/f32\",0,  i_64,   d_convertOpList (i64_TruncSat_f32),        Compile_Convert ),  // 0x04\n    M3OP_F( \"i64.trunc_u:sat/f32\",0,  i_64,   d_convertOpList (u64_TruncSat_f32),        Compile_Convert ),  // 0x05\n    M3OP_F( \"i64.trunc_s:sat/f64\",0,  i_64,   d_convertOpList (i64_TruncSat_f64),        Compile_Convert ),  // 0x06\n    M3OP_F( \"i64.trunc_u:sat/f64\",0,  i_64,   d_convertOpList (u64_TruncSat_f64),        Compile_Convert ),  // 0x07\n\n    M3OP_RESERVED, M3OP_RESERVED,\n\n    M3OP( \"memory.copy\",            0,  none,   d_emptyOpList,                           Compile_Memory_CopyFill ), // 0x0a\n    M3OP( \"memory.fill\",            0,  none,   d_emptyOpList,                           Compile_Memory_CopyFill ), // 0x0b\n\n\n# ifdef DEBUG\n    M3OP( \"termination\", 0, c_m3Type_unknown ) // for find_operation_info\n# endif\n};\n\n\nIM3OpInfo  GetOpInfo  (m3opcode_t opcode)\n{\n    switch (opcode >> 8) {\n    case 0x00:\n        if (M3_LIKELY(opcode < M3_COUNT_OF(c_operations))) {\n            return &c_operations[opcode];\n        }\n        break;\n    case c_waOp_extended:\n        opcode &= 0xFF;\n        if (M3_LIKELY(opcode < M3_COUNT_OF(c_operationsFC))) {\n            return &c_operationsFC[opcode];\n        }\n        break;\n    }\n    return NULL;\n}\n\nM3Result  CompileBlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool validEnd = false;\n\n    while (o->wasm < o->wasmEnd)\n    {\n# if d_m3EnableOpTracing\n        if (o->numEmits)\n        {\n            EmitOp          (o, op_DumpStack);\n            EmitConstant32  (o, o->numOpcodes);\n            EmitConstant32  (o, GetMaxUsedSlotPlusOne(o));\n            EmitPointer     (o, o->function);\n\n            o->numEmits = 0;\n        }\n# endif\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restrictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo (opcode);\n\n        if (opinfo == NULL)\n            _throw (ErrorCompile (m3Err_unknownOpcode, o, \"opcode '%x' not available\", opcode));\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;\n\n        if (opcode == c_waOp_else)\n        {\n            _throwif (m3Err_wasmMalformed, o->block.opcode != c_waOp_if);\n            validEnd = true;\n            break;\n        }\n        else if (opcode == c_waOp_end)\n        {\n            validEnd = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(validEnd));\n\n_catch:\n    return result;\n}\n\nstatic\nM3Result  PushBlockResults  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    u16 numResults = GetFuncTypeNumResults (o->block.type);\n\n    for (u16 i = 0; i < numResults; ++i)\n    {\n        u8 type = GetFuncTypeResultType (o->block.type, i);\n\n        if (i == numResults - 1 and IsFpType (type))\n        {\n_           (PushRegister (o, type));\n        }\n        else\n_           (PushAllocatedSlot (o, type));\n    }\n\n    _catch: return result;\n}\n\n\nM3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n    /*\n     The block stack frame is a little strange but for good reasons.  Because blocks need to be restarted to\n     compile different pathways (if/else), the incoming params must be saved.  The parameters are popped\n     and validated.  But, then the stack top is readjusted so they aren't subsequently overwritten.\n     Next, the result are preallocated to find destination slots.  But again these are immediately popped\n     (deallocated) and the stack top is readjusted to keep these records in pace. This allows branch instructions\n     to find their result landing pads.  Finally, the params are copied from the \"dead\" records and pushed back\n     onto the stack as active stack items for the CompileBlockStatements () call.\n\n    [     block      ]\n    [     params     ]\n    ------------------\n    [     result     ]  <---- blockStackIndex\n    [      slots     ]\n    ------------------\n    [   saved param  ]\n    [     records    ]\n                        <----- exitStackIndex\n    */\n\n_try {\n    // validate and dealloc params ----------------------------\n\n    u16 stackIndex = o->stackIndex;\n\n    u16 numParams = GetFuncTypeNumParams (i_blockType);\n\n    if (i_blockOpcode != c_waOp_else)\n    {\n        for (u16 i = 0; i < numParams; ++i)\n        {\n            u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);\n_           (PopType (o, type));\n        }\n    }\n    else {\n        if (IsStackPolymorphic (o) && o->block.blockStackIndex + numParams > o->stackIndex) {\n            o->stackIndex = o->block.blockStackIndex;\n        } else {\n            o->stackIndex -= numParams;\n        }\n    }\n\n    u16 paramIndex = o->stackIndex;\n    block->exitStackIndex = paramIndex; // consume the params at block exit\n\n    // keep copies of param slots in the stack\n    o->stackIndex = stackIndex;\n\n    // find slots for the results ----------------------------\n    PushBlockResults (o);\n\n    stackIndex = o->stackIndex;\n\n    // dealloc but keep record of the result slots in the stack\n    u16 numResults = GetFuncTypeNumResults (i_blockType);\n    while (numResults--)\n        Pop (o);\n\n    block->blockStackIndex = o->stackIndex = stackIndex;\n\n    // push the params back onto the stack -------------------\n    for (u16 i = 0; i < numParams; ++i)\n    {\n        u8 type = GetFuncTypeParamType (i_blockType, i);\n\n        u16 slot = GetSlotForStackIndex (o, paramIndex + i);\n        Push (o, type, slot);\n\n        if (slot >= o->slotFirstDynamicIndex && slot != c_slotUnused)\n            MarkSlotsAllocatedByType (o, slot, type);\n    }\n\n    //--------------------------------------------------------\n\n_   (CompileBlockStatements (o));\n\n_   (ValidateBlockEnd (o));\n\n    if (o->function)    // skip for expressions\n    {\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, & o->block, /* isBranch: */ false));\n\n_       (UnwindBlockStack (o))\n\n        if (not ((i_blockOpcode == c_waOp_if and numResults) or o->previousOpcode == c_waOp_else))\n        {\n            o->stackIndex = o->block.exitStackIndex;\n_           (PushBlockResults (o));\n        }\n    }\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n}   _catch: return result;\n}\n\nstatic\nM3Result  CompileLocals  (IM3Compilation o)\n{\n    M3Result result;\n\n    u32 numLocals = 0;\n    u32 numLocalBlocks;\n_   (ReadLEB_u32 (& numLocalBlocks, & o->wasm, o->wasmEnd));\n\n    for (u32 l = 0; l < numLocalBlocks; ++l)\n    {\n        u32 varCount;\n        i8 waType;\n        u8 localType;\n\n_       (ReadLEB_u32 (& varCount, & o->wasm, o->wasmEnd));\n_       (ReadLEB_i7 (& waType, & o->wasm, o->wasmEnd));\n_       (NormalizeType (& localType, waType));\n        numLocals += varCount;                                                          m3log (compile, \"pushing locals. count: %d; type: %s\", varCount, c_waTypes [localType]);\n        while (varCount--)\n_           (PushAllocatedSlot (o, localType));\n    }\n\n    if (o->function)\n        o->function->numLocals = numLocals;\n\n    _catch: return result;\n}\n\nstatic\nM3Result  ReserveConstants  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    // in the interest of speed, this blindly scans the Wasm code looking for any byte\n    // that looks like an const opcode.\n    u16 numConstantSlots = 0;\n\n    bytes_t wa = o->wasm;\n    while (wa < o->wasmEnd)\n    {\n        u8 code = * wa++;\n        u16 addSlots = 0;\n\n        if (code == c_waOp_i32_const or code == c_waOp_f32_const)\n            addSlots = 1;\n        else if (code == c_waOp_i64_const or code == c_waOp_f64_const)\n            addSlots = GetTypeNumSlots (c_m3Type_i64);\n\n        if (numConstantSlots + addSlots >= d_m3MaxConstantTableSize)\n            break;\n\n        numConstantSlots += addSlots;\n    }\n\n    // if constants overflow their reserved stack space, the compiler simply emits op_Const\n    // operations as needed. Compiled expressions (global inits) don't pass through this\n    // ReserveConstants function and thus always produce inline constants.\n\n    AlignSlotToType (& numConstantSlots, c_m3Type_i64);                                         m3log (compile, \"reserved constant slots: %d\", numConstantSlots);\n\n    o->slotFirstDynamicIndex = o->slotFirstConstIndex + numConstantSlots;\n\n    if (o->slotFirstDynamicIndex >= d_m3MaxFunctionSlots)\n        _throw (m3Err_functionStackOverflow);\n\n    _catch:\n    return result;\n}\n\n\nstatic const double WAS_DEBUG_CompileFunction = true;\nM3Result  CompileFunction  (IM3Function io_function)\n{\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;                   m3log (compile, \"compiling: [%d] %s %s; wasm-size: %d\",\n                                                                        io_function->index, m3_GetFunctionName (io_function), SPrintFuncTypeSignature (funcType), (u32) (io_function->wasmEnd - io_function->wasm));\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    memset (o, 0x0, sizeof (M3Compilation));\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    if(WAS_DEBUG_CompileFunction) ESP_LOGI(\"WASM3\", \"Assigning o->maxStacksSlots\");\n    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.blockStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d\",\n                                                                                                          (u32) o->stackFirstDynamicIndex);\n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n\n    if(WAS_DEBUG_CompileFunction) ESP_LOGI(\"WASM3\", \"Assigning io_function->maxStacksSlots\");\n    io_function->maxStackSlots = o->maxStackSlots;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;                           m3log (compile, \"unique constant slots: %d; unused slots: %d\",\n                                                                                                           numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_Int_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\n\n    ReleaseCompilationCodePage (o);\n\n    return result;\n}\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_core.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_core.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_core.h\n//\n//  Created by Steven Massey on 4/15/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"wasm3.h\"\n#include \"m3_config.h\"\n#include \"m3_pointers.h\"\n#include \"m3_exception.h\"\n#include \"m3_segmented_memory.h\"\n#include \"m3_compile.h\"\n\n/* // Try to deprecate it\ntypedef struct M3MemoryHeader\n{\n    IM3Runtime      runtime;\n    void *          maxStack;\n    size_t          length;\n}\nM3MemoryHeader;\n*/\n\n\n#define d_m3CodePageFreeLinesThreshold      4+2       // max is: select _sss & CallIndirect + 2 for bridge\n\n#define d_m3DefaultMemPageSize              65536\n\n#define d_m3Reg0SlotAlias                   60000\n#define d_m3Fp0SlotAlias                    (d_m3Reg0SlotAlias + 2)\n\n#define d_m3MaxSaneTypesCount               1000000\n#define d_m3MaxSaneFunctionsCount           1000000\n#define d_m3MaxSaneImportsCount             100000\n#define d_m3MaxSaneExportsCount             100000\n#define d_m3MaxSaneGlobalsCount             1000000\n#define d_m3MaxSaneElementSegments          10000000\n#define d_m3MaxSaneDataSegments             100000\n#define d_m3MaxSaneTableSize                10000000\n#define d_m3MaxSaneUtf8Length               10000\n#define d_m3MaxSaneFunctionArgRetCount      1000    // still insane, but whatever\n\n#define d_externalKind_function             0\n#define d_externalKind_table                1\n#define d_externalKind_memory               2\n#define d_externalKind_global               3\n\nstatic const char * const c_waTypes []          = { \"nil\", \"i32\", \"i64\", \"f32\", \"f64\", \"unknown\" };\nstatic const char * const c_waCompactTypes []   = { \"_\", \"i\", \"I\", \"f\", \"F\", \"?\" };\n\n\n# if d_m3VerboseErrorMessages\n\nM3Result m3Error (M3Result i_result, IM3Runtime i_runtime, IM3Module i_module, IM3Function i_function,\n                  const char * const i_file, u32 i_lineNum, const char * const i_errorMessage, ...);\n\n#  define _m3Error(RESULT, RT, MOD, FUN, FILE, LINE, FORMAT, ...) \\\n            m3Error (RESULT, RT, MOD, FUN, FILE, LINE, FORMAT, ##__VA_ARGS__)\n\n# else\n#  define _m3Error(RESULT, RT, MOD, FUN, FILE, LINE, FORMAT, ...) (RESULT)\n# endif\n\n#define ErrorRuntime(RESULT, RUNTIME, FORMAT, ...)      _m3Error (RESULT, RUNTIME, NULL, NULL,  __FILE__, __LINE__, FORMAT, ##__VA_ARGS__)\n#define ErrorModule(RESULT, MOD, FORMAT, ...)           _m3Error (RESULT, MOD->runtime, MOD, NULL,  __FILE__, __LINE__, FORMAT, ##__VA_ARGS__)\n#define ErrorCompile(RESULT, COMP, FORMAT, ...)         _m3Error (RESULT, COMP->runtime, COMP->module, NULL, __FILE__, __LINE__, FORMAT, ##__VA_ARGS__)\n\n#if d_m3LogNativeStack\nvoid        m3StackCheckInit        ();\nvoid        m3StackCheck            ();\nint         m3StackGetMax           ();\n#else\n#define     m3StackCheckInit()\n#define     m3StackCheck()\n#define     m3StackGetMax()         0\n#endif\n\n#if d_m3LogTimestamps\n#define     PRIts                   \"%llu\"\nuint64_t    m3_GetTimestamp         ();\n#else\n#define     PRIts                   \"%s\"\n#define     m3_GetTimestamp()       \"\"\n#endif\n\nvoid        m3_Abort                (const char* message);\nvoid *      m3_Malloc_Impl          (size_t i_size);\nvoid *      m3_Realloc_Impl         (void * i_ptr, size_t i_newSize, size_t i_oldSize);\nvoid        m3_Free_Impl            (void * i_ptr, bool isMemory);\nvoid *      m3_CopyMem              (const void * i_from, size_t i_size);\n\n#if d_m3LogHeapOps\n\n// Tracing format: timestamp;heap:OpCode;name;size(bytes);new items;new ptr;old items;old ptr\n\nstatic inline void * m3_AllocStruct_Impl(ccstr_t name, size_t i_size) {\n    void * result = m3_Malloc_Impl(i_size);\n    fprintf(stderr, PRIts \";heap:AllocStruct;%s;%zu;;%p;;\\n\", m3_GetTimestamp(), name, i_size, result);\n    return result;\n}\n\nstatic inline void * m3_AllocArray_Impl(ccstr_t name, size_t i_num, size_t i_size) {\n    void * result = m3_Malloc_Impl(i_size * i_num);\n    fprintf(stderr, PRIts \";heap:AllocArr;%s;%zu;%zu;%p;;\\n\", m3_GetTimestamp(), name, i_size, i_num, result);\n    return result;\n}\n\nstatic inline void * m3_ReallocArray_Impl(ccstr_t name, void * i_ptr_old, size_t i_num_new, size_t i_num_old, size_t i_size) {\n    void * result = m3_Realloc_Impl (i_ptr_old, i_size * i_num_new, i_size * i_num_old);\n    fprintf(stderr, PRIts \";heap:ReallocArr;%s;%zu;%zu;%p;%zu;%p\\n\", m3_GetTimestamp(), name, i_size, i_num_new, result, i_num_old, i_ptr_old);\n    return result;\n}\n\nstatic inline void * m3_Malloc (ccstr_t name, size_t i_size) {\n    void * result = m3_Malloc_Impl (i_size);\n    fprintf(stderr, PRIts \";heap:AllocMem;%s;%zu;;%p;;\\n\", m3_GetTimestamp(), name, i_size, result);\n    return result;\n}\nstatic inline void * m3_Realloc (ccstr_t name, void * i_ptr, size_t i_newSize, size_t i_oldSize) {\n    void * result = m3_Realloc_Impl (i_ptr, i_newSize, i_oldSize);\n    fprintf(stderr, PRIts \";heap:ReallocMem;%s;;%zu;%p;%zu;%p\\n\", m3_GetTimestamp(), name, i_newSize, result, i_oldSize, i_ptr);\n    return result;\n}\n\n#define     m3_AllocStruct(STRUCT)                  (STRUCT *)m3_AllocStruct_Impl  (#STRUCT, sizeof (STRUCT))\n#define     m3_AllocArray(STRUCT, NUM)              (STRUCT *)m3_AllocArray_Impl   (#STRUCT, NUM, sizeof (STRUCT))\n#define     m3_ReallocArray(STRUCT, PTR, NEW, OLD)  (STRUCT *)m3_ReallocArray_Impl (#STRUCT, (void *)(PTR), (NEW), (OLD), sizeof (STRUCT))\n#define     m3_Free(P)                              do { void* p = (void*)(P);                                  \\\n                                                        if (p) { fprintf(stderr, PRIts \";heap:FreeMem;;;;%p;\\n\", m3_GetTimestamp(), p); }     \\\n                                                        m3_Free_Impl (p); (P) = NULL; } while(0)\n#else\n#define     m3_Malloc(NAME, SIZE)                   m3_Malloc_Impl(SIZE)\n#define     m3_Realloc(NAME, PTR, NEW, OLD)         m3_Realloc_Impl(PTR, NEW, OLD)\n#define     m3_AllocStruct(STRUCT)                  (STRUCT *)m3_Malloc_Impl (sizeof (STRUCT))\n#define     m3_AllocArray(STRUCT, NUM)              (STRUCT *)m3_Malloc_Impl (sizeof (STRUCT) * (NUM))\n#define     m3_ReallocArray(STRUCT, PTR, NEW, OLD)  (STRUCT *)m3_Realloc_Impl ((void *)(PTR), sizeof (STRUCT) * (NEW), sizeof (STRUCT) * (OLD))\n//#define     m3_Free(P)                              do { m3_Free_Impl ((void*)(P)); (P) = NULL; } while(0)\n#define     m3_Free(P)                              do { m3_Free_Impl((void*)(P), false); (P) = NULL; } while(0)\n#define     m3_FreeMemory(P)                        do { m3_Free_Impl((void*)(P), true); (P) = NULL; } while(0)\n#endif\n\nM3Result    NormalizeType           (u8 * o_type, i8 i_convolutedWasmType);\n\nbool        IsIntType               (u8 i_wasmType);\nbool        IsFpType                (u8 i_wasmType);\nbool        Is64BitType             (u8 i_m3Type);\nu32         SizeOfType              (u8 i_m3Type);\n\nM3Result    Read_u64                (u64 * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    Read_u32                (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end);\n#if d_m3ImplementFloat\nM3Result    Read_f64                (f64 * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    Read_f32                (f32 * o_value, bytes_t * io_bytes, cbytes_t i_end);\n#endif\nM3Result    Read_u8                 (u8  * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    Read_opcode             (m3opcode_t * o_value, bytes_t  * io_bytes, cbytes_t i_end);\n\nM3Result    ReadLebUnsigned         (u64 * o_value, u32 i_maxNumBits, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLebSigned           (i64 * o_value, u32 i_maxNumBits, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLEB_u32             (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLEB_u7              (u8  * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLEB_i7              (i8  * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLEB_i32             (i32 * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    ReadLEB_i64             (i64 * o_value, bytes_t * io_bytes, cbytes_t i_end);\nM3Result    Read_utf8               (cstr_t * o_utf8, bytes_t * io_bytes, cbytes_t i_end);\n\ncstr_t      SPrintValue             (void * i_value, u8 i_type);\nsize_t      SPrintArg               (char * o_string, size_t i_stringBufferSize, voidptr_t i_sp, u8 i_type);\n\nvoid        ReportError             (IM3Runtime io_runtime, IM3Module i_module, IM3Function i_function, ccstr_t i_errorMessage, ccstr_t i_file, u32 i_lineNum);\n\n# if d_m3RecordBacktraces\nvoid        PushBacktraceFrame         (IM3Runtime io_runtime, pc_t i_pc);\nvoid        FillBacktraceFunctionInfo  (IM3Runtime io_runtime, IM3Function i_function);\nvoid        ClearBacktrace             (IM3Runtime io_runtime);\n# endif\n\nvoid *  m3_Int_CopyMem  (const void * i_from, size_t i_size);\n\nvoid* default_malloc(size_t size);\nvoid default_free(void* ptr);\nvoid* default_realloc(void* ptr, size_t new_size);\n//bool allocate_segment(M3Memory* memory, size_t segment_index);\n\ntypedef struct {\n    void* (*malloc)(size_t size);\n    void  (*free)(void* ptr);\n    void* (*realloc)(void* ptr, size_t new_size);\n} MemoryAllocator;\n\nstatic MemoryAllocator default_allocator = {\n    .malloc = default_malloc,\n    .free = default_free,\n    .realloc = default_realloc\n};\n\nstatic MemoryAllocator* current_allocator = &default_allocator;\n\nd_m3EndExternC\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_config.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_config.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_config.h\n//\n//  Created by Steven Massey on 5/4/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_config_platforms.h\"\n#include \"m3_exception.h\"\n\n// general --------------------------------------------------------------------\n\n# ifndef d_m3CodePageAlignSize\n#   define d_m3CodePageAlignSize                32*1024\n# endif\n\n# ifndef d_m3MaxFunctionStackHeight\n#   define d_m3MaxFunctionStackHeight           2000    // max: 32768\n# endif\n\n# ifndef d_m3MaxLinearMemoryPages\n#   define d_m3MaxLinearMemoryPages             65536\n# endif\n\n# ifndef d_m3MaxFunctionSlots\n#   define d_m3MaxFunctionSlots                 ((d_m3MaxFunctionStackHeight)*2)\n# endif\n\n# ifndef d_m3MaxConstantTableSize\n#   define d_m3MaxConstantTableSize             120\n# endif\n\n# ifndef d_m3MaxDuplicateFunctionImpl\n#   define d_m3MaxDuplicateFunctionImpl         3\n# endif\n\n# ifndef d_m3CascadedOpcodes                            // Cascaded opcodes are slightly faster at the expense of some memory\n#   define d_m3CascadedOpcodes                  1       // Adds ~3Kb to operations table in m3_compile.c\n# endif\n\n# ifndef d_m3VerboseErrorMessages\n#   define d_m3VerboseErrorMessages             1\n# endif\n\n# ifndef d_m3FixedHeap\n#   define d_m3FixedHeap                        false\n//# define d_m3FixedHeap                        (32*1024)\n# endif\n\n# ifndef d_m3FixedHeapAlign\n#   define d_m3FixedHeapAlign                   16\n# endif\n\n# ifndef d_m3Use32BitSlots\n#   define d_m3Use32BitSlots                    1\n# endif\n\n# ifndef d_m3ProfilerSlotMask\n#   define d_m3ProfilerSlotMask                 0xFFFF\n# endif\n\n# ifndef d_m3RecordBacktraces\n#   define d_m3RecordBacktraces                 0\n# endif\n\n# ifndef d_m3EnableExceptionBreakpoint\n#   define d_m3EnableExceptionBreakpoint        0       // see m3_exception.h\n# endif\n\n\n// profiling and tracing ------------------------------------------------------\n\n# ifndef d_m3EnableOpProfiling\n#   define d_m3EnableOpProfiling                0       // opcode usage counters\n# endif\n\n# ifndef d_m3EnableOpTracing\n#   define d_m3EnableOpTracing                  0       // only works with DEBUG\n# endif\n\n# ifndef d_m3EnableWasiTracing\n#  define d_m3EnableWasiTracing                 0\n# endif\n\n# ifndef d_m3EnableStrace\n#   define d_m3EnableStrace                     0       // 1 - trace exported function calls\n                                                        // 2 - trace all calls (structured)\n                                                        // 3 - all calls + loops + memory operations\n# endif\n\n\n// logging --------------------------------------------------------------------\n\n# ifndef d_m3LogParse\n#   define d_m3LogParse                         0       // .wasm binary decoding info\n# endif\n\n# ifndef d_m3LogModule\n#   define d_m3LogModule                        0       // wasm module info\n# endif\n\n# ifndef d_m3LogCompile\n#   define d_m3LogCompile                       0       // wasm -> metacode generation phase\n# endif\n\n# ifndef d_m3LogWasmStack\n#   define d_m3LogWasmStack                     0       // dump the wasm stack when pushed or popped\n# endif\n\n# ifndef d_m3LogEmit\n#   define d_m3LogEmit                          0       // metacode generation info\n# endif\n\n# ifndef d_m3LogCodePages\n#   define d_m3LogCodePages                     0       // dump metacode pages when released\n# endif\n\n# ifndef d_m3LogRuntime\n#   define d_m3LogRuntime                       0       // higher-level runtime information\n# endif\n\n# ifndef d_m3LogNativeStack\n#   define d_m3LogNativeStack                   0       // track the memory usage of the C-stack\n# endif\n\n# ifndef d_m3LogHeapOps\n#   define d_m3LogHeapOps                       0       // track heap usage\n# endif\n\n# ifndef d_m3LogTimestamps\n#   define d_m3LogTimestamps                    0       // track timestamps on heap logs\n# endif\n\n// other ----------------------------------------------------------------------\n\n# ifndef d_m3HasFloat\n#   define d_m3HasFloat                         1       // implement floating point ops\n# endif\n\n#if !d_m3HasFloat && !defined(d_m3NoFloatDynamic)\n#   define d_m3NoFloatDynamic                   1       // if no floats, do not fail until flops are actually executed\n#endif\n\n# ifndef d_m3SkipStackCheck\n#   define d_m3SkipStackCheck                   0       // skip stack overrun checks\n# endif\n\n# ifndef d_m3SkipMemoryBoundsCheck\n#   define d_m3SkipMemoryBoundsCheck            0       // skip memory bounds checks\n# endif\n\n#define d_m3EnableCodePageRefCounting           0       // not supported currently\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_tracer.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_tracer.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_tracer.h\n//\n//  Created by Volodymyr Shymanskyy on 02/18/20.\n//  Copyright © 2020 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_core.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\nM3Result    m3_LinkTracer       (IM3Module io_module);\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_pointers.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_pointers.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#pragma once\n\n#include \"m3_segmented_memory.h\"\n#include \"m3_exception.h\"\n\n///\n/// Pointer validation\n///\n\ntypedef enum {\n    PTR_CHECK_OK = 0,\n    PTR_CHECK_NULL,\n    PTR_CHECK_UNALIGNED,\n    PTR_CHECK_OUT_OF_BOUNDS\n} ptr_check_result_t;\n\nptr_check_result_t validate_pointer(const void* ptr, size_t expected_size);\nbool is_ptr_freeable(void* ptr);\nbool safe_free(void* ptr);\n\n\nbool safe_m3_int_free(void** ptr);\nbool safe_free_with_check(void** ptr);\nbool is_ptr_valid(const void* ptr);\n\nstatic inline bool is_address_in_range(uintptr_t addr);\nbool ultra_safe_ptr_valid(const void* ptr);\n\n////////////////////////////////////////////////////////////////\n\ntypedef struct {\n    void* ptr;\n    size_t size;\n    const char* allocation_point;\n} safe_ptr_t;\n\ntypedef enum {\n    PTR_OK = 0,\n    PTR_NULL,\n    PTR_UNALIGNED,\n    PTR_OUT_OF_BOUNDS,\n    PTR_ALREADY_FREED,\n    PTR_CORRUPTED,\n    PTR_INVALID_BLOCK\n} ptr_status_t;\n\nbool ultra_safe_free(void** ptr);\nptr_status_t validate_ptr_for_free(const void* ptr);\n\n///\n/// Internal\n///\n\n#define     m3_Int_Malloc(NAME, SIZE)                   default_malloc(SIZE)\n//#define     m3_Int_Malloc(SIZE)                         default_malloc(SIZE)\n#define     m3_Int_Realloc(NAME, PTR, NEW, OLD)         default_realloc(PTR, NEW, OLD)\n//#define     m3_Int_Realloc(PTR, NEW, OLD)               default_realloc(PTR, NEW, OLD)\n#define     m3_Int_AllocStruct(STRUCT)                  (STRUCT *)default_malloc (sizeof (STRUCT))\n#define     m3_Int_AllocArray(STRUCT, NUM)              (STRUCT *)default_malloc (sizeof (STRUCT) * (NUM))\n#define     m3_Int_ReallocArray(STRUCT, PTR, NEW, OLD)  (STRUCT *)default_realloc ((void *)(PTR), sizeof (STRUCT) * (NEW)) // , sizeof (STRUCT) * (OLD)\n#define     m3_Int_Free(P)                              do { default_free((void*)(P)); (P) = NULL; } while(0)\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_libc.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_libc.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_libc.c\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#define _POSIX_C_SOURCE 200809L\n\n#include \"m3_api_libc.h\"\n\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n\ntypedef uint32_t wasm_ptr_t;\ntypedef uint32_t wasm_size_t;\n\nm3ApiRawFunction(m3_libc_abort)\n{\n    m3ApiTrap(m3Err_trapAbort);\n}\n\nm3ApiRawFunction(m3_libc_exit)\n{\n    m3ApiGetArg     (int32_t, code)\n\n    m3ApiTrap(m3Err_trapExit);\n}\n\n\nm3ApiRawFunction(m3_libc_memset)\n{\n    m3ApiReturnType (int32_t)\n\n    m3ApiGetArgMem  (void*,           i_ptr)\n    m3ApiGetArg     (int32_t,         i_value)\n    m3ApiGetArg     (wasm_size_t,     i_size)\n\n    m3ApiCheckMem(i_ptr, i_size);\n\n    u32 result = m3ApiPtrToOffset(memset (i_ptr, i_value, i_size));\n    m3ApiReturn(result);\n}\n\nm3ApiRawFunction(m3_libc_memmove)\n{\n    m3ApiReturnType (int32_t)\n\n    m3ApiGetArgMem  (void*,           o_dst)\n    m3ApiGetArgMem  (void*,           i_src)\n    m3ApiGetArg     (wasm_size_t,     i_size)\n\n    m3ApiCheckMem(o_dst, i_size);\n    m3ApiCheckMem(i_src, i_size);\n\n    u32 result = m3ApiPtrToOffset(memmove (o_dst, i_src, i_size));\n    m3ApiReturn(result);\n}\n\nm3ApiRawFunction(m3_libc_print)\n{\n    m3ApiReturnType (uint32_t)\n\n    m3ApiGetArgMem  (void*,           i_ptr)\n    m3ApiGetArg     (wasm_size_t,     i_size)\n\n    m3ApiCheckMem(i_ptr, i_size);\n\n    fwrite(i_ptr, i_size, 1, stdout);\n    fflush(stdout);\n\n    m3ApiReturn(i_size);\n}\n\nstatic\nvoid internal_itoa(int n, char s[], int radix)\n{\n    static char const HEXDIGITS[0x10] = {\n        '0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n    int i, j, sign;\n    char c;\n\n    if ((sign = n) < 0) { n = -n; }\n    i = 0;\n    do {\n        s[i++] = HEXDIGITS[n % radix];\n    } while ((n /= radix) > 0);\n\n    if (sign < 0) { s[i++] = '-'; }\n    s[i] = '\\0';\n\n    // reverse\n    for (i = 0, j = strlen(s)-1; i<j; i++, j--) {\n        c = s[i];\n        s[i] = s[j];\n        s[j] = c;\n    }\n}\n\nm3ApiRawFunction(m3_libc_printf)\n{\n    m3ApiReturnType (int32_t)\n\n    m3ApiGetArgMem  (const char*,    i_fmt)\n    m3ApiGetArgMem  (wasm_ptr_t*,    i_args)\n\n    if (m3ApiIsNullPtr(i_fmt)) {\n        m3ApiReturn(0);\n    }\n\n    m3ApiCheckMem(i_fmt, 1);\n    size_t fmt_len = strnlen(i_fmt, 1024);\n    m3ApiCheckMem(i_fmt, fmt_len+1); // include `\\0`\n\n    FILE* file = stdout;\n\n    int32_t length = 0;\n    char ch;\n    while ((ch = *i_fmt++)) {\n        if ( '%' != ch ) {\n            putc(ch, file);\n            length++;\n            continue;\n        }\n        ch = *i_fmt++;\n        switch (ch) {\n            case 'c': {\n                m3ApiCheckMem(i_args, sizeof(wasm_ptr_t));\n                char char_temp = *i_args++;\n                fputc(char_temp, file);\n                length++;\n                break;\n            }\n            case 'd':\n            case 'x': {\n                m3ApiCheckMem(i_args, sizeof(wasm_ptr_t));\n                int int_temp = *i_args++;\n                char buffer[32] = { 0, };\n                internal_itoa(int_temp, buffer, (ch == 'x') ? 16 : 10);\n                fputs(buffer, file);\n                length += strnlen(buffer, sizeof(buffer));\n                break;\n            }\n            case 's': {\n                m3ApiCheckMem(i_args, sizeof(wasm_ptr_t));\n                const char* string_temp;\n                size_t string_len;\n\n                string_temp = (const char*)m3ApiOffsetToPtr(*i_args++);\n                if (m3ApiIsNullPtr(string_temp)) {\n                    string_temp = \"(null)\";\n                    string_len = 6;\n                } else {\n                    string_len = strnlen(string_temp, 1024);\n                    m3ApiCheckMem(string_temp, string_len+1);\n                }\n\n                fwrite(string_temp, 1, string_len, file);\n                length += string_len;\n                break;\n            default:\n                fputc(ch, file);\n                length++;\n                break;\n            }\n        }\n    }\n\n    m3ApiReturn(length);\n}\n\nm3ApiRawFunction(m3_libc_clock_ms)\n{\n    m3ApiReturnType (uint32_t)\n#ifdef CLOCKS_PER_SEC\n    uint32_t clock_divider = CLOCKS_PER_SEC/1000;\n    if (clock_divider != 0) {\n        m3ApiReturn(clock() / clock_divider);\n    } else {\n        m3ApiReturn(clock());\n    }\n#else\n    m3ApiReturn(clock());\n#endif\n}\n\nstatic\nM3Result  SuppressLookupFailure (M3Result i_result)\n{\n    if (i_result == m3Err_functionLookupFailed)\n        return m3Err_none;\n    else\n        return i_result;\n}\n\nm3ApiRawFunction(m3_spectest_dummy)\n{\n    m3ApiSuccess();\n}\n\nM3Result  m3_LinkSpecTest  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    const char* spectest = \"spectest\";\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print\",         \"v()\",      &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_i32\",     \"v(i)\",     &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_i64\",     \"v(I)\",     &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_f32\",     \"v(f)\",     &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_f64\",     \"v(F)\",     &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_i32_f32\", \"v(if)\",    &m3_spectest_dummy)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, spectest, \"print_i64_f64\", \"v(IF)\",    &m3_spectest_dummy)));\n\n_catch:\n    return result;\n}\n\n\nM3Result  m3_LinkLibC  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    const char* env = \"env\";\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_debug\",            \"i(*i)\",   &m3_libc_print)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_memset\",           \"*(*ii)\",  &m3_libc_memset)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_memmove\",          \"*(**i)\",  &m3_libc_memmove)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_memcpy\",           \"*(**i)\",  &m3_libc_memmove))); // just alias of memmove\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_abort\",            \"v()\",     &m3_libc_abort)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"_exit\",             \"v(i)\",    &m3_libc_exit)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"clock_ms\",          \"i()\",     &m3_libc_clock_ms)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"printf\",            \"i(**)\",   &m3_libc_printf)));\n\n_catch:\n    return result;\n}\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_env.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_env.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_env.c\n//\n//  Created by Steven Massey on 4/19/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include <stdarg.h>\n#include <limits.h>\n\n#include \"m3_env.h\"\n\nstatic const bool WASM_DEBUG_NEW_ENV = false;\n\nIM3Environment  m3_NewEnvironment  ()\n{\n    if(WASM_DEBUG_NEW_ENV) ESP_LOGI(\"WASM3\", \"m3_NewEnvironment called\");\n    IM3Environment env = m3_Int_AllocStruct (M3Environment);\n    if(WASM_DEBUG_NEW_ENV) ESP_LOGI(\"WASM3\", \"env allocated\");\n\n    if (env)\n    {\n        _try\n        {\n            // create FuncTypes for all simple block return ValueTypes\n            for (u8 t = c_m3Type_none; t <= c_m3Type_f64; t++)\n            {\n                IM3FuncType ftype;\n_               (AllocFuncType (& ftype, 1));\n\n                ftype->numArgs = 0;\n                ftype->numRets = (t == c_m3Type_none) ? 0 : 1;\n                ftype->types [0] = t;\n\n                Environment_AddFuncType (env, & ftype);\n\n                d_m3Assert (t < 5);\n                env->retFuncTypes [t] = ftype;\n\n                if(WASM_DEBUG_NEW_ENV) ESP_LOGI(\"WASM3\", \"Ended an Environment_AddFuncType\");\n            }\n        }\n\n        if(WASM_DEBUG_NEW_ENV) ESP_LOGI(\"WASM3\", \"m3_NewEnvironment done.\");\n\n        _catch:\n        if (result)\n        {\n            m3_FreeEnvironment (env);\n            env = NULL;\n        }\n    }\n\n    return env;\n}\n\n\nvoid  Environment_Release  (IM3Environment i_environment)\n{\n    IM3FuncType ftype = i_environment->funcTypes;\n\n    while (ftype)\n    {\n        IM3FuncType next = ftype->next;\n        m3_Int_Free (ftype);\n        ftype = next;\n    }\n\n    m3log (runtime, \"freeing %d pages from environment\", CountCodePages (i_environment->pagesReleased));\n    FreeCodePages (& i_environment->pagesReleased);\n}\n\n\nvoid  m3_FreeEnvironment  (IM3Environment i_environment)\n{\n    if (i_environment)\n    {\n        Environment_Release (i_environment);\n        m3_Int_Free (i_environment);\n    }\n}\n\n\nvoid m3_SetCustomSectionHandler  (IM3Environment i_environment, M3SectionHandler i_handler)\n{\n    if (i_environment) i_environment->customSectionHandler = i_handler;\n}\n\n\nstatic const bool WASM_DEBUG_ADDFUNC = false;\n\n// returns the same io_funcType or replaces it with an equivalent that's already in the type linked list\nvoid  Environment_AddFuncType  (IM3Environment i_environment, IM3FuncType * io_funcType)\n{\n    if(WASM_DEBUG_ADDFUNC) ESP_LOGI(\"WASM3\", \"Called Environment_AddFuncType\");\n\n    IM3FuncType addType = * io_funcType;\n    IM3FuncType newType = i_environment->funcTypes;\n\n    while (newType)\n    {\n        if (AreFuncTypesEqual (newType, addType))\n        {\n            m3_Int_Free (addType);\n            break;\n        }\n        else {\n            if(!ultra_safe_ptr_valid(addType)){\n                ESP_LOGE(\"WASM3\", \"Invalid addType pointer in Environment_AddFuncType\");\n                return;\n            }\n\n            if(!ultra_safe_ptr_valid(newType)){\n                ESP_LOGE(\"WASM3\", \"Invalid newType pointer in Environment_AddFuncType\");\n                m3_Int_Free (addType);\n                return;\n            }\n        }\n\n        newType = newType->next;\n    }\n\n    if (newType == NULL)\n    {\n        newType = addType;\n        newType->next = i_environment->funcTypes;\n        i_environment->funcTypes = newType;\n    }\n\n    * io_funcType = newType;\n\n    if(WASM_DEBUG_ADDFUNC) ESP_LOGI(\"WASM3\", \"End of Environment_AddFuncType call\");\n}\n\n\nIM3CodePage RemoveCodePageOfCapacity (M3CodePage ** io_list, u32 i_minimumLineCount)\n{\n    IM3CodePage prev = NULL;\n    IM3CodePage page = * io_list;\n\n    while (page)\n    {\n        if (NumFreeLines (page) >= i_minimumLineCount)\n        {                                                           d_m3Assert (page->info.usageCount == 0);\n            IM3CodePage next = page->info.next;\n            if (prev)\n                prev->info.next = next; // mid-list\n            else\n                * io_list = next;       // front of list\n\n            break;\n        }\n\n        prev = page;\n        page = page->info.next;\n    }\n\n    return page;\n}\n\n\nIM3CodePage  Environment_AcquireCodePage (IM3Environment i_environment, u32 i_minimumLineCount)\n{\n    return RemoveCodePageOfCapacity (& i_environment->pagesReleased, i_minimumLineCount);\n}\n\n\nvoid  Environment_ReleaseCodePages  (IM3Environment i_environment, IM3CodePage i_codePageList)\n{\n    IM3CodePage end = i_codePageList;\n\n    while (end)\n    {\n        end->info.lineIndex = 0; // reset page\n#if d_m3RecordBacktraces\n        end->info.mapping->size = 0;\n#endif // d_m3RecordBacktraces\n\n        IM3CodePage next = end->info.next;\n        if (not next)\n            break;\n\n        end = next;\n    }\n\n    if (end)\n    {\n        // push list to front\n        end->info.next = i_environment->pagesReleased;\n        i_environment->pagesReleased = i_codePageList;\n    }\n}\n\nstatic const bool WASM_DEBUG_STACK = false;\nIM3Memory m3_NewStack(){\n    if(WASM_DEBUG_STACK) ESP_LOGI(\"WASM3\", \"m3_NewStack called\");\n\n    IM3Memory memory = m3_NewMemory();\n    \n    if (memory == NULL){\n        ESP_LOGE(\"WASM3\", \"Failed to allocate memory for IM3Memory\");\n        return NULL;\n    }\n\n    return memory;\n}\n\n\nIM3Runtime  m3_NewRuntime  (IM3Environment i_environment, u32 i_stackSizeInBytes, void * i_userdata)\n{\n    ESP_LOGI(\"WASM3\", \"m3_NewRuntime called\");\n\n    IM3Runtime runtime = m3_Int_AllocStruct (M3Runtime);\n\n    if (runtime)\n    {\n        m3_ResetErrorInfo(runtime);\n\n        runtime->environment = i_environment;\n        runtime->userdata = i_userdata;\n\n        //runtime->originStack = m3_Int_Malloc (\"Wasm Stack\", i_stackSizeInBytes + 4*sizeof (m3slot_t)); // TODO: more precise stack checks\n        runtime->originStack = m3_NewStack();        \n\n        if (runtime->originStack)\n        {\n            runtime->originStack->runtime = runtime;\n            runtime->originStack->max_size = i_stackSizeInBytes;\n\n            runtime->stack = runtime->originStack;\n            runtime->maxStackSize = i_stackSizeInBytes; // is it important save it here?\n            //runtime->numStackSlots = i_stackSizeInBytes / sizeof (m3slot_t);         \n            m3log (runtime, \"new stack: %p\", runtime->originStack);\n        }\n        else m3_Int_Free (runtime);\n    }\n\n    return runtime;\n}\n\nvoid *  m3_GetUserData  (IM3Runtime i_runtime)\n{\n    return i_runtime ? i_runtime->userdata : NULL;\n}\n\n\nvoid *  ForEachModule  (IM3Runtime i_runtime, ModuleVisitor i_visitor, void * i_info)\n{\n    void * r = NULL;\n\n    IM3Module module = i_runtime->modules;\n\n    while (module)\n    {\n        IM3Module next = module->next;\n        r = i_visitor (module, i_info);\n        if (r)\n            break;\n\n        module = next;\n    }\n\n    return r;\n}\n\n\nvoid *  _FreeModule  (IM3Module i_module, void * i_info)\n{\n    m3_FreeModule (i_module);\n    return NULL;\n}\n\n\nvoid  Runtime_Release  (IM3Runtime i_runtime)\n{\n    ForEachModule (i_runtime, _FreeModule, NULL);                   d_m3Assert (i_runtime->numActiveCodePages == 0);\n\n    Environment_ReleaseCodePages (i_runtime->environment, i_runtime->pagesOpen);\n    Environment_ReleaseCodePages (i_runtime->environment, i_runtime->pagesFull);\n\n    m3_Int_Free (i_runtime->originStack);\n\n    void* memory_ptr = &i_runtime->memory;\n    m3_FreeMemory (memory_ptr);\n}\n\n\nvoid  m3_FreeRuntime  (IM3Runtime i_runtime)\n{\n    if (i_runtime)\n    {\n        m3_PrintProfilerInfo ();\n\n        Runtime_Release (i_runtime);\n        m3_Int_Free (i_runtime);\n    }\n}\n\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // OPTZ: use a simplified interpreter for expressions\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    //runtime.numStackSlots = i_module->runtime->numStackSlots; // deprecated\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        /*if (not result && o->maxStackSlots >= runtime.numStackSlots) {\n            result = error_details(m3Err_trapStackOverflow, \"in EvaluateExpression\");\n        }*/\n\n        if (not result)\n        {\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n            m3ret_t r = RunCode (m3code, stack, NULL, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n            m3ret_t r = RunCode (m3code, stack, NULL, d_m3OpDefaultArgs);\n# endif\n            \n            if (r == 0)\n            {                                                                               m3log (runtime, \"expression result: %s\", SPrintValue (stack, i_type));\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.originStack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\n\n\n/*M3Result  InitMemory  (IM3Runtime io_runtime, IM3Module i_module)\n{\n    if (i_module->memoryInfo.pageSize == 0) { //todo: use costants or external settings\n        i_module->memoryInfo.pageSize = 65524; // 65536 - 12  \n        ESP_LOGI(\"WASM3\", \"InitMemory - Fixed pageSize to standard 64KB\");\n    }\n\n    #ifdef _DEBUG_MEMORY\n     // Prima del calcolo\n    ESP_LOGI(\"WASM3\", \"InitMemory - Module memory info: initial pages: %lu, max pages: %lu\", \n            (unsigned long)i_module->memoryInfo.initPages,\n            (unsigned long)i_module->memoryInfo.maxPages);\n\n    ESP_LOGI(\"WASM3\", \"InitMemory - Page size: %lu bytes\", \n            (unsigned long)i_module->memoryInfo.pageSize);\n    #endif\n\n    // Calcolo con verifica overflow\n    size_t alloc_size = 0;\n    if (i_module->memoryInfo.pageSize > 0) {  // previene divisione per zero\n        alloc_size = (size_t)i_module->memoryInfo.initPages * i_module->memoryInfo.pageSize;\n        \n        // Verifica overflow\n        if (alloc_size / i_module->memoryInfo.pageSize != i_module->memoryInfo.initPages) {\n            ESP_LOGE(\"WASM3\", \"Memory size calculation overflow!\");\n            return \"memory size overflow\";\n        }\n    }\n\n    M3Result result = m3Err_none;                                     //d_m3Assert (not io_runtime->memory.wasmPages);\n\n    if (not i_module->memoryImported)\n    {\n        u32 maxPages = i_module->memoryInfo.maxPages;\n        u32 pageSize = i_module->memoryInfo.pageSize;\n        io_runtime->memory.maxPages = maxPages ? maxPages : 65536;\n        io_runtime->memory.pageSize = pageSize ? pageSize : d_m3DefaultMemPageSize;\n\n        ESP_LOGI(\"WASM3\", \"InitMemory - ResizeMemory\"); \n        result = ResizeMemory (io_runtime, i_module->memoryInfo.initPages);\n    }\n\n    #ifdef _DEBUG_MEMORY\n    ESP_LOGI(\"WASM3\", \"InitMemory - Calculated allocation size: %lu bytes\", \n            (unsigned long)alloc_size);\n    #endif\n\n\n    return result;\n}\n\n\nM3Result  ResizeMemory  (IM3Runtime io_runtime, u32 i_numPages)\n{\n    M3Result result = m3Err_none;\n\n    u32 numPagesToAlloc = i_numPages;\n\n    M3Memory * memory = & io_runtime->memory;\n\n#if 0 // Temporary fix for memory allocation\n    if (memory->mallocated) {\n        memory->numPages = i_numPages;\n        memory->mallocated->end = memory->wasmPages + (memory->numPages * io_runtime->memory.pageSize);\n        return result;\n    }\n\n    i_numPagesToAlloc = 256;\n#endif\n\n    if (numPagesToAlloc <= memory->maxPages)\n    {\n        size_t numPageBytes = numPagesToAlloc * io_runtime->memory.pageSize;\n\n#if d_m3MaxLinearMemoryPages > 0\n        _throwif(\"linear memory limitation exceeded\", numPagesToAlloc > d_m3MaxLinearMemoryPages);\n#endif\n\n        // Limit the amount of memory that gets actually allocated\n        if (io_runtime->memoryLimit) {\n            numPageBytes = M3_MIN (numPageBytes, io_runtime->memoryLimit);\n        }\n\n        size_t numBytes = numPageBytes + sizeof (M3MemoryHeader);\n\n        size_t numPreviousBytes = memory->numPages * io_runtime->memory.pageSize;\n        if (numPreviousBytes)\n            numPreviousBytes += sizeof (M3MemoryHeader);\n\n        void* newMem = m3_Realloc (\"Wasm Linear Memory\", memory->mallocated, numBytes, numPreviousBytes);\n        _throwifnull(newMem);\n\n        memory->mallocated = (M3MemoryHeader*)newMem;\n\n# if d_m3LogRuntime\n        M3MemoryHeader * oldMallocated = memory->mallocated;\n# endif\n\n        memory->numPages = numPagesToAlloc;\n\n        memory->mallocated->length =  numPageBytes;\n        memory->mallocated->runtime = io_runtime;\n\n        memory->mallocated->maxStack = (m3slot_t *) io_runtime->stack + io_runtime->numStackSlots;\n\n        m3log (runtime, \"resized old: %p; mem: %p; length: %zu; pages: %d\", oldMallocated, memory->mallocated, memory->mallocated->length, memory->numPages);\n    }\n    else result = m3Err_wasmMemoryOverflow;\n\n    _catch: return result;\n}\n*/\n\n///\n///\n///\n\nM3Result  InitGlobals  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (io_module->numGlobals)\n    {\n        // placing the globals in their structs isn't good for cache locality, but i don't really know what the global\n        // access patterns typically look like yet.\n\n        //          io_module->globalMemory = m3Alloc (m3reg_t, io_module->numGlobals);\n\n        //          if (io_module->globalMemory)\n        {\n            for (u32 i = 0; i < io_module->numGlobals; ++i)\n            {\n                M3Global * g = & io_module->globals [i];                        m3log (runtime, \"initializing global: %d\", i);\n\n                if (g->initExpr)\n                {\n                    bytes_t start = g->initExpr;\n\n                    result = EvaluateExpression (io_module, & g->i64Value, g->type, & start, g->initExpr + g->initExprSize);\n\n                    if (not result)\n                    {\n                        // io_module->globalMemory [i] = initValue;\n                    }\n                    else break;\n                }\n                else\n                {                                                               m3log (runtime, \"importing global\");\n\n                }\n            }\n        }\n        //          else result = ErrorModule (m3Err_mallocFailed, io_module, \"could allocate globals for module: '%s\", io_module->name);\n    }\n\n    return result;\n}\n\n\nM3Result InitDataSegments(M3Memory* io_memory, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n    \n    // Verifica che la struttura di memoria sia inizializzata\n    _throwif(\"uninitialized memory structure\", !io_memory || !io_memory->segments);\n\n    for (u32 i = 0; i < io_module->numDataSegments; ++i)\n    {\n        M3DataSegment* segment = &io_module->dataSegments[i];\n\n        i32 segmentOffset;\n        bytes_t start = segment->initExpr;\n_       (EvaluateExpression(io_module, &segmentOffset, c_m3Type_i32, &start, \n                           segment->initExpr + segment->initExprSize));\n\n        m3log(runtime, \"loading data segment: %d; size: %d; offset: %d\", \n              i, segment->size, segmentOffset);\n\n        // Verifica limiti\n        if (segmentOffset >= 0 && (size_t)(segmentOffset) + segment->size <= io_memory->total_size)\n        {\n            // Calcola i segmenti interessati\n            size_t start_segment = segmentOffset / io_memory->segment_size;\n            size_t end_segment = (segmentOffset + segment->size - 1) / io_memory->segment_size;\n            \n            // Alloca tutti i segmenti necessari se non sono già allocati\n            for (size_t seg = start_segment; seg <= end_segment; seg++)\n            {\n                if (!io_memory->segments[seg].is_allocated) {\n                    if (!allocate_segment(io_memory, seg)) {\n                        _throw(\"failed to allocate memory segment\");\n                    }\n                }\n            }\n            \n            // Copia i dati attraverso i segmenti\n            size_t remaining = segment->size;\n            size_t src_offset = 0;\n            size_t dest_offset = segmentOffset;\n            \n            while (remaining > 0)\n            {\n                size_t current_segment = dest_offset / io_memory->segment_size;\n                size_t segment_offset = dest_offset % io_memory->segment_size;\n                size_t bytes_to_copy = M3_MIN(\n                    remaining,\n                    io_memory->segment_size - segment_offset\n                );\n                \n                u8* dest = ((u8*)io_memory->segments[current_segment].data) + segment_offset;\n                memcpy(dest, segment->data + src_offset, bytes_to_copy);\n                \n                remaining -= bytes_to_copy;\n                src_offset += bytes_to_copy;\n                dest_offset += bytes_to_copy;\n            }\n        }\n        else {\n            _throw(\"data segment out of bounds\");\n        }\n    }\n\n    _catch: return result;\n}\n\n\nM3Result  InitElements  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    bytes_t bytes = io_module->elementSection;\n    cbytes_t end = io_module->elementSectionEnd;\n\n    for (u32 i = 0; i < io_module->numElementSegments; ++i)\n    {\n        u32 index;\n_       (ReadLEB_u32 (& index, & bytes, end));\n\n        if (index == 0)\n        {\n            i32 offset;\n_           (EvaluateExpression (io_module, & offset, c_m3Type_i32, & bytes, end));\n            _throwif (\"table underflow\", offset < 0);\n\n            u32 numElements;\n_           (ReadLEB_u32 (& numElements, & bytes, end));\n\n            size_t endElement = (size_t) numElements + offset;\n            _throwif (\"table overflow\", endElement > d_m3MaxSaneTableSize);\n\n            // is there any requirement that elements must be in increasing sequence?\n            // make sure the table isn't shrunk.\n            if (endElement > io_module->table0Size)\n            {\n                io_module->table0 = m3_Int_ReallocArray (IM3Function, io_module->table0, endElement, io_module->table0Size);\n                io_module->table0Size = (u32) endElement;\n            }\n            _throwifnull(io_module->table0);\n\n            for (u32 e = 0; e < numElements; ++e)\n            {\n                u32 functionIndex;\n_               (ReadLEB_u32 (& functionIndex, & bytes, end));\n                _throwif (\"function index out of range\", functionIndex >= io_module->numFunctions);\n                IM3Function function = & io_module->functions [functionIndex];      d_m3Assert (function); //printf (\"table: %s\\n\", m3_GetFunctionName(function));\n                io_module->table0 [e + offset] = function;\n            }\n        }\n        else _throw (\"element table index must be zero for MVP\");\n    }\n\n    _catch: return result;\n}\n\nM3Result  m3_CompileModule  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    for (u32 i = 0; i < io_module->numFunctions; ++i)\n    {\n        IM3Function f = & io_module->functions [i];\n        if (f->wasm and not f->compiled)\n        {\n_           (CompileFunction (f));\n        }\n    }\n\n    _catch: return result;\n}\n\nM3Result  m3_RunStart  (IM3Module io_module)\n{\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    // Execution disabled for fuzzing builds\n    return m3Err_none;\n#endif\n\n    M3Result result = m3Err_none;\n    i32 startFunctionTmp = -1;\n\n    if (io_module and io_module->startFunction >= 0)\n    {\n        IM3Function function = & io_module->functions [io_module->startFunction];\n\n        if (not function->compiled)\n        {\n_           (CompileFunction (function));\n        }\n\n        IM3FuncType ftype = function->funcType;\n        if (ftype->numArgs != 0 || ftype->numRets != 0)\n            _throw (m3Err_argumentCountMismatch);\n\n        IM3Module module = function->module;\n        IM3Runtime runtime = module->runtime;\n\n        startFunctionTmp = io_module->startFunction;\n        io_module->startFunction = -1;\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n        result = (M3Result) RunCode (function->compiled, (m3stack_t) runtime->stack, runtime->memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n        result = (M3Result) RunCode (function->compiled, (m3stack_t) runtime->stack, &runtime->memory, d_m3OpDefaultArgs);\n# endif\n\n        if (result)\n        {\n            io_module->startFunction = startFunctionTmp;\n            EXCEPTION_PRINT(result);\n            goto _catch;\n        }\n    }\n\n    _catch: return result;\n}\n\n// TODO: deal with main + side-modules loading efforcement\nM3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    // Debug memory allocation\n    multi_heap_info_t info;\n    heap_caps_get_info(&info, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    ESP_LOGI(\"WASM3\", \"Before LoadModule - Free: %d bytes, Largest block: %d bytes\", \n         info.total_free_bytes, info.largest_free_block);\n\n    // Start\n    M3Result result = m3Err_none;\n\n    if (M3_UNLIKELY(io_module->runtime)) {\n        return m3Err_moduleAlreadyLinked;\n    }\n\n    io_module->runtime = io_runtime;\n    M3Memory * memory = & io_runtime->memory;    \n\n    ESP_LOGI(\"WASM3\", \"Starting InitMemory\");\n_   (InitMemory (io_runtime, io_module));\n    ESP_LOGI(\"WASM3\", \"InitMemory completed\");\n\n    ESP_LOGI(\"WASM3\", \"Starting InitGlobals\");\n_   (InitGlobals (io_module));\n    ESP_LOGI(\"WASM3\", \"InitGlobals completed\");\n\n    ESP_LOGI(\"WASM3\", \"Starting InitDataSegments\");\n_   (InitDataSegments (memory, io_module));\n    ESP_LOGI(\"WASM3\", \"InitDataSegments completed\");\n\n    ESP_LOGI(\"WASM3\", \"Starting InitElements\");\n_   (InitElements (io_module));\n    ESP_LOGI(\"WASM3\", \"InitElements completed\");\n\n#ifdef DEBUG\n    Module_GenerateNames(io_module);\n#endif\n\n    io_module->next = io_runtime->modules;\n    io_runtime->modules = io_module;\n    return result; // ok\n\n_catch:\n    // Log di debug per capire dove è fallito\n    heap_caps_get_info(&info, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    ESP_LOGE(\"WASM3\", \"LoadModule failed - Free: %d bytes, Largest block: %d bytes\", \n         info.total_free_bytes, info.largest_free_block);\n    \n    io_module->runtime = NULL;\n    return result;\n}\n\nIM3Global  m3_FindGlobal  (IM3Module               io_module,\n                           const char * const      i_globalName)\n{\n    // Search exports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n        if (g->name and strcmp (g->name, i_globalName) == 0)\n        {\n            return g;\n        }\n    }\n\n    // Search imports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n\n        if (g->import.moduleUtf8 and g->import.fieldUtf8)\n        {\n            if (strcmp (g->import.fieldUtf8, i_globalName) == 0)\n            {\n                return g;\n            }\n        }\n    }\n    return NULL;\n}\n\nM3Result  m3_GetGlobal  (IM3Global                 i_global,\n                         IM3TaggedValue            o_value)\n{\n    if (not i_global) return m3Err_globalLookupFailed;\n\n    switch (i_global->type) {\n    case c_m3Type_i32: o_value->value.i32 = i_global->i32Value; break;\n    case c_m3Type_i64: o_value->value.i64 = i_global->i64Value; break;\n# if d_m3HasFloat\n    case c_m3Type_f32: o_value->value.f32 = i_global->f32Value; break;\n    case c_m3Type_f64: o_value->value.f64 = i_global->f64Value; break;\n# endif\n    default: return m3Err_invalidTypeId;\n    }\n\n    o_value->type = (M3ValueType)(i_global->type);\n    return m3Err_none;\n}\n\nM3Result  m3_SetGlobal  (IM3Global                 i_global,\n                         const IM3TaggedValue      i_value)\n{\n    if (not i_global) return m3Err_globalLookupFailed;\n    if (not i_global->isMutable) return m3Err_globalNotMutable;\n    if (i_global->type != i_value->type) return m3Err_globalTypeMismatch;\n\n    switch (i_value->type) {\n    case c_m3Type_i32: i_global->i32Value = i_value->value.i32; break;\n    case c_m3Type_i64: i_global->i64Value = i_value->value.i64; break;\n# if d_m3HasFloat\n    case c_m3Type_f32: i_global->f32Value = i_value->value.f32; break;\n    case c_m3Type_f64: i_global->f64Value = i_value->value.f64; break;\n# endif\n    default: return m3Err_invalidTypeId;\n    }\n\n    return m3Err_none;\n}\n\nM3ValueType  m3_GetGlobalType  (IM3Global          i_global)\n{\n    return (i_global) ? (M3ValueType)(i_global->type) : c_m3Type_none;\n}\n\n\nstatic const bool WASM_DEBUG_VERBOSE_v_FindFunction = false;\nvoid *  v_FindFunction  (IM3Module i_module, const char * const i_name)\n{\n    // Prefer exported functions\n    for (u32 i = 0; i < i_module->numFunctions; ++i)\n    {\n        IM3Function f = & i_module->functions [i];\n\n        if(WASM_DEBUG_VERBOSE_v_FindFunction){\n            if(f->export_name){\n                ESP_LOGI(\"WASM3\", \"v_FindFunction: cycling function %s in module %s\", f->export_name, i_module->name);\n            }\n        }\n\n        if (f->export_name and strcmp (f->export_name, i_name) == 0)\n            return f;\n    }\n\n    // Search internal functions\n    for (u32 i = 0; i < i_module->numFunctions; ++i)\n    {\n        IM3Function f = & i_module->functions [i];\n\n        bool isImported = f->import.moduleUtf8 or f->import.fieldUtf8;\n\n        if (isImported)\n            continue;\n\n        for (int j = 0; j < f->numNames; j++)\n        {\n            if(WASM_DEBUG_VERBOSE_v_FindFunction){\n                if(f->names [j]){\n                    ESP_LOGI(\"WASM3\", \"v_FindFunction: cycling internal function %s in module %s\", f->names [j], i_module->name);\n                }\n            }\n\n            if (f->names [j] and strcmp (f->names [j], i_name) == 0)\n                return f;\n        }\n    }\n\n    return NULL;\n}\n\n\nM3Result  m3_FindFunction  (IM3Function * o_function, IM3Runtime i_runtime, const char * const i_functionName)\n{\n    M3Result result = m3Err_none;                               d_m3Assert (o_function and i_runtime and i_functionName);\n\n    IM3Function function = NULL;\n\n    if (not i_runtime->modules) {\n        _throw (\"no modules loaded\");\n    }\n\n    function = (IM3Function) ForEachModule (i_runtime, (ModuleVisitor) v_FindFunction, (void *) i_functionName);\n\n    if (function)\n    {\n        if (not function->compiled)\n        {\n_           (CompileFunction (function))\n        }\n    }\n    else _throw (ErrorModule (m3Err_functionLookupFailed, i_runtime->modules, \"'%s'\", i_functionName));\n\n    _catch:\n    if (result)\n        function = NULL;\n\n    * o_function = function;\n\n    return result;\n}\n\n\nM3Result  m3_GetTableFunction  (IM3Function * o_function, IM3Module i_module, uint32_t i_index)\n{\n_try {\n    if (i_index >= i_module->table0Size)\n    {\n        _throw (\"function index out of range\");\n    }\n\n    IM3Function function = i_module->table0[i_index];\n\n    if (function)\n    {\n        if (not function->compiled)\n        {\n_           (CompileFunction (function))\n        }\n    }\n\n    * o_function = function;\n}   _catch:\n    return result;\n}\n\n\nstatic\nM3Result checkStartFunction(IM3Module i_module)\n{\n    M3Result result = m3Err_none;                               d_m3Assert(i_module);\n\n    // Check if start function needs to be called\n    if (i_module->startFunction >= 0)\n    {\n        result = m3_RunStart (i_module);\n    }\n\n    return result;\n}\n\nuint32_t  m3_GetArgCount  (IM3Function i_function)\n{\n    if (i_function) {\n        IM3FuncType ft = i_function->funcType;\n        if (ft) {\n            return ft->numArgs;\n        }\n    }\n    return 0;\n}\n\nuint32_t  m3_GetRetCount  (IM3Function i_function)\n{\n    if (i_function) {\n        IM3FuncType ft = i_function->funcType;\n        if (ft) {\n            return ft->numRets;\n        }\n    }\n    return 0;\n}\n\n\nM3ValueType  m3_GetArgType  (IM3Function i_function, uint32_t index)\n{\n    if (i_function) {\n        IM3FuncType ft = i_function->funcType;\n        if (ft and index < ft->numArgs) {\n            return (M3ValueType)d_FuncArgType(ft, index);\n        }\n    }\n    return c_m3Type_none;\n}\n\nM3ValueType  m3_GetRetType  (IM3Function i_function, uint32_t index)\n{\n    if (i_function) {\n        IM3FuncType ft = i_function->funcType;\n        if (ft and index < ft->numRets) {\n            return (M3ValueType) d_FuncRetType (ft, index);\n        }\n    }\n    return c_m3Type_none;\n}\n\n\nu8 *  GetStackPointerForArgs  (IM3Function i_function)\n{\n    u64 * stack = (u64 *) i_function->module->runtime->stack;\n    IM3FuncType ftype = i_function->funcType;\n\n    stack += ftype->numRets;\n\n    return (u8 *) stack;\n}\n\n\nM3Result  m3_CallV  (IM3Function i_function, ...)\n{\n    va_list ap;\n    va_start(ap, i_function);\n    M3Result r = m3_CallVL(i_function, ap);\n    va_end(ap);\n    return r;\n}\n\nstatic\nvoid  ReportNativeStackUsage  ()\n{\n#   if d_m3LogNativeStack\n        int stackUsed =  m3StackGetMax();\n        fprintf (stderr, \"Native stack used: %d\\n\", stackUsed);\n#   endif\n}\n\n\nM3Result m3_CallVL(IM3Function i_function, va_list i_args)\n{\n    IM3Runtime runtime = i_function->module->runtime;\n    IM3FuncType ftype = i_function->funcType;\n    M3Result result = m3Err_none;\n    u8* s = NULL;\n\n    if (!i_function->compiled) {\n        return m3Err_missingCompiledCode;\n    }\n\n# if d_m3RecordBacktraces\n    ClearBacktrace(runtime);\n# endif\n\n    m3StackCheckInit();\n\n_   (checkStartFunction(i_function->module))\n\n    s = GetStackPointerForArgs(i_function);\n\n    for (u32 i = 0; i < ftype->numArgs; ++i)\n    {\n        switch (d_FuncArgType(ftype, i)) {\n        case c_m3Type_i32:  *(i32*)(s) = va_arg(i_args, i32);  s += 8; break;\n        case c_m3Type_i64:  *(i64*)(s) = va_arg(i_args, i64);  s += 8; break;\n# if d_m3HasFloat\n        case c_m3Type_f32:  *(f32*)(s) = va_arg(i_args, f64);  s += 8; break;\n        case c_m3Type_f64:  *(f64*)(s) = va_arg(i_args, f64);  s += 8; break;\n# endif\n        default: return \"unknown argument type\";\n        }\n    }\n\n// Here's born _mem\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs);\n# endif\n    ReportNativeStackUsage();\n\n    runtime->lastCalled = result ? NULL : i_function;\n\n    _catch: return result;\n}\n\nM3Result m3_Call(IM3Function i_function, uint32_t i_argc, const void* i_argptrs[])\n{\n    IM3Runtime runtime = i_function->module->runtime;\n    IM3FuncType ftype = i_function->funcType;\n    M3Result result = m3Err_none;\n    u8* s = NULL;\n\n    if (i_argc != ftype->numArgs) {\n        return m3Err_argumentCountMismatch;\n    }\n    if (!i_function->compiled) {\n        return m3Err_missingCompiledCode;\n    }\n\n# if d_m3RecordBacktraces\n    ClearBacktrace(runtime);\n# endif\n\n    m3StackCheckInit();\n\n_   (checkStartFunction(i_function->module))\n\n    s = GetStackPointerForArgs(i_function);\n\n    for (u32 i = 0; i < ftype->numArgs; ++i)\n    {\n        switch (d_FuncArgType(ftype, i)) {\n        case c_m3Type_i32:  *(i32*)(s) = *(i32*)i_argptrs[i];  s += 8; break;\n        case c_m3Type_i64:  *(i64*)(s) = *(i64*)i_argptrs[i];  s += 8; break;\n# if d_m3HasFloat\n        case c_m3Type_f32:  *(f32*)(s) = *(f32*)i_argptrs[i];  s += 8; break;\n        case c_m3Type_f64:  *(f64*)(s) = *(f64*)i_argptrs[i];  s += 8; break;\n# endif\n        default: return \"unknown argument type\";\n        }\n    }\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs);\n# endif\n\n    ReportNativeStackUsage();\n\n    runtime->lastCalled = result ? NULL : i_function;\n\n    _catch: return result;\n}\n\nM3Result m3_CallArgv(IM3Function i_function, uint32_t i_argc, const char* i_argv[])\n{\n    IM3FuncType ftype = i_function->funcType;\n    IM3Runtime runtime = i_function->module->runtime;\n    M3Result result = m3Err_none;\n    u8* s = NULL;\n\n    if (i_argc != ftype->numArgs) {\n        return m3Err_argumentCountMismatch;\n    }\n    if (!i_function->compiled) {\n        return m3Err_missingCompiledCode;\n    }\n\n# if d_m3RecordBacktraces\n    ClearBacktrace(runtime);\n# endif\n\n    m3StackCheckInit();\n\n_   (checkStartFunction(i_function->module))\n\n    s = GetStackPointerForArgs(i_function);\n\n    for (u32 i = 0; i < ftype->numArgs; ++i)\n    {\n        switch (d_FuncArgType(ftype, i)) {\n        case c_m3Type_i32:  *(i32*)(s) = strtoul(i_argv[i], NULL, 10);  s += 8; break;\n        case c_m3Type_i64:  *(i64*)(s) = strtoull(i_argv[i], NULL, 10); s += 8; break;\n# if d_m3HasFloat\n        case c_m3Type_f32:  *(f32*)(s) = strtod(i_argv[i], NULL);       s += 8; break;\n        case c_m3Type_f64:  *(f64*)(s) = strtod(i_argv[i], NULL);       s += 8; break;\n# endif\n        default: return \"unknown argument type\";\n        }\n    }\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n    result = (M3Result) RunCode(i_function->compiled, (m3stack_t)(runtime->stack), &runtime->memory, d_m3OpDefaultArgs);\n# endif\n    \n    ReportNativeStackUsage();\n\n    runtime->lastCalled = result ? NULL : i_function;\n\n    _catch: return result;\n}\n\n\n//u8 * AlignStackPointerTo64Bits (const u8 * i_stack)\n//{\n//    uintptr_t ptr = (uintptr_t) i_stack;\n//    return (u8 *) ((ptr + 7) & ~7);\n//}\n\n\nM3Result  m3_GetResults  (IM3Function i_function, uint32_t i_retc, const void * o_retptrs[])\n{\n    IM3FuncType ftype = i_function->funcType;\n    IM3Runtime runtime = i_function->module->runtime;\n\n    if (i_retc != ftype->numRets) {\n        return m3Err_argumentCountMismatch;\n    }\n    if (i_function != runtime->lastCalled) {\n        return \"function not called\";\n    }\n\n    u8* s = (u8*) runtime->stack;\n\n    for (u32 i = 0; i < ftype->numRets; ++i)\n    {\n        switch (d_FuncRetType(ftype, i)) {\n        case c_m3Type_i32:  *(i32*)o_retptrs[i] = *(i32*)(s); s += 8; break;\n        case c_m3Type_i64:  *(i64*)o_retptrs[i] = *(i64*)(s); s += 8; break;\n# if d_m3HasFloat\n        case c_m3Type_f32:  *(f32*)o_retptrs[i] = *(f32*)(s); s += 8; break;\n        case c_m3Type_f64:  *(f64*)o_retptrs[i] = *(f64*)(s); s += 8; break;\n# endif\n        default: return \"unknown return type\";\n        }\n    }\n    return m3Err_none;\n}\n\nM3Result  m3_GetResultsV  (IM3Function i_function, ...)\n{\n    va_list ap;\n    va_start(ap, i_function);\n    M3Result r = m3_GetResultsVL(i_function, ap);\n    va_end(ap);\n    return r;\n}\n\nM3Result  m3_GetResultsVL  (IM3Function i_function, va_list o_rets)\n{\n    IM3Runtime runtime = i_function->module->runtime;\n    IM3FuncType ftype = i_function->funcType;\n\n    if (i_function != runtime->lastCalled) {\n        return \"function not called\";\n    }\n\n    u8* s = (u8*) runtime->stack;\n    for (u32 i = 0; i < ftype->numRets; ++i)\n    {\n        switch (d_FuncRetType(ftype, i)) {\n        case c_m3Type_i32:  *va_arg(o_rets, i32*) = *(i32*)(s);  s += 8; break;\n        case c_m3Type_i64:  *va_arg(o_rets, i64*) = *(i64*)(s);  s += 8; break;\n# if d_m3HasFloat\n        case c_m3Type_f32:  *va_arg(o_rets, f32*) = *(f32*)(s);  s += 8; break;\n        case c_m3Type_f64:  *va_arg(o_rets, f64*) = *(f64*)(s);  s += 8; break;\n# endif\n        default: return \"unknown argument type\";\n        }\n    }\n    return m3Err_none;\n}\n\nvoid  ReleaseCodePageNoTrack (IM3Runtime i_runtime, IM3CodePage i_codePage)\n{\n    if (i_codePage)\n    {\n        IM3CodePage * list;\n\n        bool pageFull = (NumFreeLines (i_codePage) < d_m3CodePageFreeLinesThreshold);\n        if (pageFull)\n            list = & i_runtime->pagesFull;\n        else\n            list = & i_runtime->pagesOpen;\n\n        PushCodePage (list, i_codePage);                        m3log (emit, \"release page: %d to queue: '%s'\", i_codePage->info.sequence, pageFull ? \"full\" : \"open\")\n    }\n}\n\n\nIM3CodePage  AcquireCodePageWithCapacity  (IM3Runtime i_runtime, u32 i_minLineCount)\n{\n    IM3CodePage page = RemoveCodePageOfCapacity (& i_runtime->pagesOpen, i_minLineCount);\n\n    if (not page)\n    {\n        page = Environment_AcquireCodePage (i_runtime->environment, i_minLineCount);\n\n        if (not page)\n            page = NewCodePage (i_runtime, i_minLineCount);\n\n        if (page)\n            i_runtime->numCodePages++;\n    }\n\n    if (page)\n    {                                                            m3log (emit, \"acquire page: %d\", page->info.sequence);\n        i_runtime->numActiveCodePages++;\n    }\n\n    return page;\n}\n\n\nIM3CodePage  AcquireCodePage  (IM3Runtime i_runtime)\n{\n    return AcquireCodePageWithCapacity (i_runtime, d_m3CodePageFreeLinesThreshold);\n}\n\n\nvoid  ReleaseCodePage  (IM3Runtime i_runtime, IM3CodePage i_codePage)\n{\n    if (i_codePage)\n    {\n        ReleaseCodePageNoTrack (i_runtime, i_codePage);\n        i_runtime->numActiveCodePages--;\n\n#       if defined (DEBUG)\n            u32 numOpen = CountCodePages (i_runtime->pagesOpen);\n            u32 numFull = CountCodePages (i_runtime->pagesFull);\n\n            m3log (runtime, \"runtime: %p; open-pages: %d; full-pages: %d; active: %d; total: %d\", i_runtime, numOpen, numFull, i_runtime->numActiveCodePages, i_runtime->numCodePages);\n\n            d_m3Assert (numOpen + numFull + i_runtime->numActiveCodePages == i_runtime->numCodePages);\n\n#           if d_m3LogCodePages\n                dump_code_page (i_codePage, /* startPC: */ NULL);\n#           endif\n#       endif\n    }\n}\n\n\n#if d_m3VerboseErrorMessages\nM3Result  m3Error  (M3Result i_result, IM3Runtime i_runtime, IM3Module i_module, IM3Function i_function,\n                    const char * const i_file, u32 i_lineNum, const char * const i_errorMessage, ...)\n{\n    if (i_runtime)\n    {\n        i_runtime->error = (M3ErrorInfo){ .result = i_result, .runtime = i_runtime, .module = i_module,\n                                          .function = i_function, .file = i_file, .line = i_lineNum };\n        i_runtime->error.message = i_runtime->error_message;\n\n        va_list args;\n        va_start (args, i_errorMessage);\n        vsnprintf (i_runtime->error_message, sizeof(i_runtime->error_message), i_errorMessage, args);\n        va_end (args);\n    }\n\n    return i_result;\n}\n#endif\n\n\nvoid  m3_GetErrorInfo  (IM3Runtime i_runtime, M3ErrorInfo* o_info)\n{\n    if (i_runtime)\n    {\n        *o_info = i_runtime->error;\n        m3_ResetErrorInfo (i_runtime);\n    }\n}\n\n\nvoid m3_ResetErrorInfo (IM3Runtime i_runtime)\n{\n    if (i_runtime)\n    {\n        M3_INIT(i_runtime->error);\n        i_runtime->error.message = \"\";\n    }\n}\n\nuint8_t* m3_GetMemory(IM3Runtime i_runtime, uint32_t* o_memorySizeInBytes, uint32_t i_memoryIndex)\n{\n    uint8_t* memory = NULL;                                                    \n    d_m3Assert(i_memoryIndex == 0);\n\n    if (i_runtime && i_runtime->memory.segments)\n    {\n        uint32_t size = (uint32_t)i_runtime->memory.total_size;\n\n        if (o_memorySizeInBytes)\n            *o_memorySizeInBytes = size;\n\n        if (size)\n        {\n            // Alloca un blocco contiguo di memoria\n            memory = (uint8_t*)current_allocator->malloc(size);\n            \n            if (memory)\n            {\n                // Alloca tutti i segmenti necessari e copia i dati\n                for (size_t i = 0; i < i_runtime->memory.num_segments; i++)\n                {\n                    // Alloca il segmento se non è già allocato\n                    if (!i_runtime->memory.segments[i].is_allocated)\n                    {\n                        //size_t seg_size = (i == i_runtime->memory.num_segments - 1) ? (size - (i * i_runtime->memory.segment_size)) :  i_runtime->memory.segment_size;\n                        size_t seg_size = i_runtime->memory.segment_size;\n\n                        i_runtime->memory.segments[i].data = current_allocator->malloc(seg_size);\n                        if (!i_runtime->memory.segments[i].data)\n                        {\n                            // Fallimento: libera tutto e ritorna NULL\n                            for (size_t j = 0; j < i; j++) {\n                                current_allocator->free(i_runtime->memory.segments[j].data);\n                            }\n                            current_allocator->free(memory);\n                            return NULL;\n                        }\n                        i_runtime->memory.segments[i].is_allocated = true;\n                        //i_runtime->memory.segments[i].size = seg_size;\n                        memset(i_runtime->memory.segments[i].data, 0, seg_size);\n                    }\n                    \n                    // Copia i dati dal segmento al blocco contiguo\n                    size_t offset = i * i_runtime->memory.segment_size;\n                    memcpy(memory + offset, \n                           i_runtime->memory.segments[i].data,\n                           i_runtime->memory.segment_size);\n                }\n            }\n        }\n    }\n\n    return memory;\n}\n\n\nuint32_t  m3_GetMemorySize  (IM3Runtime i_runtime)\n{\n    return i_runtime->memory.total_size;\n}\n\n\nM3BacktraceInfo *  m3_GetBacktrace  (IM3Runtime i_runtime)\n{\n# if d_m3RecordBacktraces\n    return & i_runtime->backtrace;\n# else\n    return NULL;\n# endif\n}\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec_defs.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec_defs.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_exec_defs.h\n//\n//  Created by Steven Massey on 5/1/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\nd_m3BeginExternC\n\n#include \"m3_segmented_memory.h\"\n#include \"m3_exception.h\"\n#include \"m3_config.h\"\n//#include \"m3_env.h\"      \n//#include \"m3_core.h\"      \n\n//typedef double f64;\n\n/*\n# define m3MemData(mem)                 (u8*)(((M3MemoryHeader*)(mem))+1)\n# define m3MemData(mem)                 (u8*)(((M3MemoryHeader*)(mem))) // useless subtitutive macro\n# define m3MemRuntime(mem)              (((M3MemoryHeader*)(mem))->runtime)\n# define m3MemInfo(mem)                 (&(((M3MemoryHeader*)(mem))->runtime->memory))\n*/\n\n// M3MemoryHeader ignored for M3Memory\n# define m3MemData(mem)                 (u8*)(((M3Memory*)(mem))+1)\n# define m3MemData(mem)                 (u8*)(((M3Memory*)(mem))) // useless subtitutive macro\n# define m3MemRuntime(mem)              (((M3Memory*)(mem))->runtime)\n# define m3MemInfo(mem)                 (&(((M3Memory*)(mem))->runtime->memory))\n\ntypedef void* M3MemoryPoint_ptr; // it means M3MemoryPoint\ntypedef void* M3Memory_ptr; // it means M3Memory\n\n# define d_m3BaseOpSig                  pc_t _pc, M3MemoryPoint_ptr _sp, M3Memory_ptr _mem, m3reg_t _r0\n# define d_m3BaseOpArgs                 _sp, _mem, _r0\n# define d_m3BaseOpAllArgs              _pc, _sp, _mem, _r0\n# define d_m3BaseOpDefaultArgs          0\n# define d_m3BaseClearRegisters         _r0 = 0;\n# define d_m3BaseCstr                   \"\"\n\n# define d_m3ExpOpSig(...)              d_m3BaseOpSig, __VA_ARGS__\n# define d_m3ExpOpArgs(...)             d_m3BaseOpArgs, __VA_ARGS__\n# define d_m3ExpOpAllArgs(...)          d_m3BaseOpAllArgs, __VA_ARGS__\n# define d_m3ExpOpDefaultArgs(...)      d_m3BaseOpDefaultArgs, __VA_ARGS__\n# define d_m3ExpClearRegisters(...)     d_m3BaseClearRegisters; __VA_ARGS__\n\n# if d_m3HasFloat\n#   define d_m3OpSig                d_m3ExpOpSig            (f64 _fp0)\n#   define d_m3OpArgs               d_m3ExpOpArgs           (_fp0)\n#   define d_m3OpAllArgs            d_m3ExpOpAllArgs        (_fp0)\n#   define d_m3OpDefaultArgs        d_m3ExpOpDefaultArgs    (0.)\n#   define d_m3ClearRegisters       d_m3ExpClearRegisters   (_fp0 = 0.;)\n# else\n#   define d_m3OpSig                d_m3BaseOpSig\n#   define d_m3OpArgs               d_m3BaseOpArgs\n#   define d_m3OpAllArgs            d_m3BaseOpAllArgs\n#   define d_m3OpDefaultArgs        d_m3BaseOpDefaultArgs\n#   define d_m3ClearRegisters       d_m3BaseClearRegisters\n# endif\n\n//#include \"m3_env.h\"\n\n#define d_m3RetSig                  static inline m3ret_t vectorcall\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n    typedef m3ret_t (vectorcall * IM3Operation) (d_m3OpSig, cstr_t i_operationName);\n#    define d_m3Op(NAME)                M3_NO_UBSAN d_m3RetSig op_##NAME (d_m3OpSig, cstr_t i_operationName)\n\n#    define nextOpImpl()            ((IM3Operation)(* _pc))(_pc + 1, d_m3OpArgs, __FUNCTION__)\n#    define jumpOpImpl(PC)          ((IM3Operation)(*  PC))( PC + 1, d_m3OpArgs, __FUNCTION__)\n# else\n    typedef m3ret_t (vectorcall * IM3Operation) (d_m3OpSig); // was vectorcall * IM3Operation\n#    define d_m3Op(NAME)                M3_NO_UBSAN d_m3RetSig op_##NAME (d_m3OpSig)\n\n#   define nextOpImpl()             ((IM3Operation)(*_pc))(*_pc + 1, d_m3OpArgs)\n#   define jumpOpImpl(PC)           ((IM3Operation)(*  PC))( PC + 1, d_m3OpArgs)\n# endif\n\n#define nextOpDirect()              M3_MUSTTAIL return nextOpImpl()\n#define jumpOpDirect(PC)            M3_MUSTTAIL return jumpOpImpl((pc_t)(PC))\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\nd_m3RetSig  RunCode  (d_m3OpSig, cstr_t i_operationName)\n# else\nd_m3RetSig  RunCode  (d_m3OpSig)\n# endif\n{\n    nextOpDirect();\n}\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_esp_wasi.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_esp_wasi.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_esp_wasi.c\n//\n//  Created by Volodymyr Shymanskyy on 01/07/20.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#define _POSIX_C_SOURCE 200809L\n\n#include \"m3_api_esp_wasi.h\"\n\n#include \"esp_log.h\"\n\n//#if defined(ESP32)\n\ntypedef uint32_t __wasi_size_t;\n#include \"extra/wasi_core.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nstatic m3_wasi_context_t* wasi_context;\n\ntypedef struct wasi_iovec_t\n{\n    __wasi_size_t buf;\n    __wasi_size_t buf_len;\n} wasi_iovec_t;\n\n#define PREOPEN_CNT   3\n\ntypedef struct Preopen {\n    int         fd;\n    char*       path;\n} Preopen;\n\nPreopen preopen[PREOPEN_CNT] = {\n    {  0, \"<stdin>\"  },\n    {  1, \"<stdout>\" },\n    {  2, \"<stderr>\" },\n};\n\n#  define APE_SWITCH_BEG          switch (errnum) {\n#  define APE_SWITCH_END          }\n#  define APE_CASE_RET(e1,e2)     case e1:   return e2;   break;\n\nstatic\n__wasi_errno_t errno_to_wasi(int errnum) {\n    APE_SWITCH_BEG\n    APE_CASE_RET( EPERM   , __WASI_ERRNO_PERM   )\n    APE_CASE_RET( ENOENT  , __WASI_ERRNO_NOENT  )\n    APE_CASE_RET( ESRCH   , __WASI_ERRNO_SRCH   )\n    APE_CASE_RET( EINTR   , __WASI_ERRNO_INTR   )\n    APE_CASE_RET( EIO     , __WASI_ERRNO_IO     )\n    APE_CASE_RET( ENXIO   , __WASI_ERRNO_NXIO   )\n    APE_CASE_RET( E2BIG   , __WASI_ERRNO_2BIG   )\n    APE_CASE_RET( ENOEXEC , __WASI_ERRNO_NOEXEC )\n    APE_CASE_RET( EBADF   , __WASI_ERRNO_BADF   )\n    APE_CASE_RET( ECHILD  , __WASI_ERRNO_CHILD  )\n    APE_CASE_RET( EAGAIN  , __WASI_ERRNO_AGAIN  )\n    APE_CASE_RET( ENOMEM  , __WASI_ERRNO_NOMEM  )\n    APE_CASE_RET( EACCES  , __WASI_ERRNO_ACCES  )\n    APE_CASE_RET( EFAULT  , __WASI_ERRNO_FAULT  )\n    APE_CASE_RET( EBUSY   , __WASI_ERRNO_BUSY   )\n    APE_CASE_RET( EEXIST  , __WASI_ERRNO_EXIST  )\n    APE_CASE_RET( EXDEV   , __WASI_ERRNO_XDEV   )\n    APE_CASE_RET( ENODEV  , __WASI_ERRNO_NODEV  )\n    APE_CASE_RET( ENOTDIR , __WASI_ERRNO_NOTDIR )\n    APE_CASE_RET( EISDIR  , __WASI_ERRNO_ISDIR  )\n    APE_CASE_RET( EINVAL  , __WASI_ERRNO_INVAL  )\n    APE_CASE_RET( ENFILE  , __WASI_ERRNO_NFILE  )\n    APE_CASE_RET( EMFILE  , __WASI_ERRNO_MFILE  )\n    APE_CASE_RET( ENOTTY  , __WASI_ERRNO_NOTTY  )\n    APE_CASE_RET( ETXTBSY , __WASI_ERRNO_TXTBSY )\n    APE_CASE_RET( EFBIG   , __WASI_ERRNO_FBIG   )\n    APE_CASE_RET( ENOSPC  , __WASI_ERRNO_NOSPC  )\n    APE_CASE_RET( ESPIPE  , __WASI_ERRNO_SPIPE  )\n    APE_CASE_RET( EROFS   , __WASI_ERRNO_ROFS   )\n    APE_CASE_RET( EMLINK  , __WASI_ERRNO_MLINK  )\n    APE_CASE_RET( EPIPE   , __WASI_ERRNO_PIPE   )\n    APE_CASE_RET( EDOM    , __WASI_ERRNO_DOM    )\n    APE_CASE_RET( ERANGE  , __WASI_ERRNO_RANGE  )\n    APE_SWITCH_END\n    return __WASI_ERRNO_INVAL;\n}\n\nstatic inline\nint convert_clockid(__wasi_clockid_t in) {\n    switch (in) {\n    case __WASI_CLOCKID_MONOTONIC:            return CLOCK_MONOTONIC;\n    //case __WASI_CLOCKID_PROCESS_CPUTIME_ID:   return CLOCK_PROCESS_CPUTIME_ID;\n    case __WASI_CLOCKID_REALTIME:             return CLOCK_REALTIME;\n    //case __WASI_CLOCKID_THREAD_CPUTIME_ID:    return CLOCK_THREAD_CPUTIME_ID;\n    default: return -1;\n    }\n}\n\nstatic inline\n__wasi_timestamp_t convert_timespec(const struct timespec *ts) {\n    if (ts->tv_sec < 0)\n        return 0;\n    if ((__wasi_timestamp_t)ts->tv_sec >= UINT64_MAX / 1000000000)\n        return UINT64_MAX;\n    return (__wasi_timestamp_t)ts->tv_sec * 1000000000 + ts->tv_nsec;\n}\n\n\n/*\n * WASI API implementation\n */\n\nm3ApiRawFunction(m3_wasi_generic_args_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , argv)\n    m3ApiGetArgMem   (char *               , argv_buf)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    m3ApiCheckMem(argv, context->argc * sizeof(uint32_t));\n\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        m3ApiWriteMem32(&argv[i], m3ApiPtrToOffset(argv_buf));\n\n        size_t len = strlen (context->argv[i]);\n\n        m3ApiCheckMem(argv_buf, len);\n        memcpy (argv_buf, context->argv[i], len);\n        argv_buf += len;\n        * argv_buf++ = 0;\n    }\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_args_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , argc)\n    m3ApiGetArgMem   (__wasi_size_t *      , argv_buf_size)\n\n    m3ApiCheckMem(argc,             sizeof(__wasi_size_t));\n    m3ApiCheckMem(argv_buf_size,    sizeof(__wasi_size_t));\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    __wasi_size_t buf_len = 0;\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        buf_len += strlen (context->argv[i]) + 1;\n    }\n\n    m3ApiWriteMem32(argc, context->argc);\n    m3ApiWriteMem32(argv_buf_size, buf_len);\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , env)\n    m3ApiGetArgMem   (char *               , env_buf)\n\n    // TODO\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_count)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_buf_size)\n\n    m3ApiCheckMem(env_count,    sizeof(__wasi_size_t));\n    m3ApiCheckMem(env_buf_size, sizeof(__wasi_size_t));\n\n    // TODO\n    m3ApiWriteMem32(env_count,    0);\n    m3ApiWriteMem32(env_buf_size, 0);\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_dir_name)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (char *               , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    if (fd < 3 || fd >= PREOPEN_CNT) { m3ApiReturn(__WASI_ERRNO_BADF); }\n    size_t slen = strlen(preopen[fd].path) + 1;\n    memcpy(path, preopen[fd].path, M3_MIN(slen, path_len));\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 8);\n\n    if (fd < 3 || fd >= PREOPEN_CNT) { m3ApiReturn(__WASI_ERRNO_BADF); }\n\n    m3ApiWriteMem32(buf+0, __WASI_PREOPENTYPE_DIR);\n    m3ApiWriteMem32(buf+4, strlen(preopen[fd].path) + 1);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_fdstat_t *    , fdstat)\n\n    m3ApiCheckMem(fdstat, sizeof(__wasi_fdstat_t));\n\n    struct stat fd_stat;\n    int fl = fcntl(fd, F_GETFL);\n    if (fl < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    fstat(fd, &fd_stat);\n    int mode = fd_stat.st_mode;\n    fdstat->fs_filetype = (S_ISBLK(mode)   ? __WASI_FILETYPE_BLOCK_DEVICE     : 0) |\n                          (S_ISCHR(mode)   ? __WASI_FILETYPE_CHARACTER_DEVICE : 0) |\n                          (S_ISDIR(mode)   ? __WASI_FILETYPE_DIRECTORY        : 0) |\n                          (S_ISREG(mode)   ? __WASI_FILETYPE_REGULAR_FILE     : 0) |\n                          //(S_ISSOCK(mode)  ? __WASI_FILETYPE_SOCKET_STREAM    : 0) |\n                          (S_ISLNK(mode)   ? __WASI_FILETYPE_SYMBOLIC_LINK    : 0);\n    m3ApiWriteMem16(&fdstat->fs_flags,\n                       ((fl & O_APPEND)    ? __WASI_FDFLAGS_APPEND    : 0) |\n                       //((fl & O_DSYNC)     ? __WASI_FDFLAGS_DSYNC     : 0) |\n                       ((fl & O_NONBLOCK)  ? __WASI_FDFLAGS_NONBLOCK  : 0) |\n                       //((fl & O_RSYNC)     ? __WASI_FDFLAGS_RSYNC     : 0) |\n                       ((fl & O_SYNC)      ? __WASI_FDFLAGS_SYNC      : 0));\n\n    fdstat->fs_rights_base = (uint64_t)-1; // all rights\n\n    // Make descriptors 0,1,2 look like a TTY\n    if (fd <= 2) {\n        fdstat->fs_rights_base &= ~(__WASI_RIGHTS_FD_SEEK | __WASI_RIGHTS_FD_TELL);\n    }\n\n    fdstat->fs_rights_inheriting = (uint64_t)-1; // all rights\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_flags)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_fdflags_t     , flags)\n\n    // TODO\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    int whence;\n\n    switch (wasi_whence) {\n    case 0: whence = SEEK_CUR; break;\n    case 1: whence = SEEK_END; break;\n    case 2: whence = SEEK_SET; break;\n    default:                m3ApiReturn(__WASI_ERRNO_INVAL);\n    }\n\n    int64_t ret;\n    ret = lseek(fd, offset, whence);\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem64(result, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    int whence;\n\n    switch (wasi_whence) {\n    case 0: whence = SEEK_SET; break;\n    case 1: whence = SEEK_CUR; break;\n    case 2: whence = SEEK_END; break;\n    default:                m3ApiReturn(__WASI_ERRNO_INVAL);\n    }\n\n    int64_t ret;\n    ret = lseek(fd, offset, whence);\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem64(result, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\n\nm3ApiRawFunction(m3_wasi_generic_path_open)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , dirfd)\n    m3ApiGetArg      (__wasi_lookupflags_t , dirflags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n    m3ApiGetArg      (__wasi_oflags_t      , oflags)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_base)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_inheriting)\n    m3ApiGetArg      (__wasi_fdflags_t     , fs_flags)\n    m3ApiGetArgMem   (__wasi_fd_t *        , fd)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(fd,   sizeof(__wasi_fd_t));\n\n    if (path_len >= 512)\n        m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    // copy path so we can ensure it is NULL terminated\n    char host_path[path_len+1];\n\n    memcpy (host_path, path, path_len);\n    host_path[path_len] = '\\0'; // NULL terminator\n\n    // TODO\n    m3ApiReturn(__WASI_ERRNO_NOSYS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_read)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(__wasi_size_t));\n\n    ssize_t res = 0;\n    for (__wasi_size_t i = 0; i < iovs_len; i++) {\n        void* addr = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        size_t len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        if (len == 0) continue;\n\n        int ret = read (fd, addr, len);\n        if (ret < 0) m3ApiReturn(errno_to_wasi(errno));\n        res += ret;\n        if ((size_t)ret < len) break;\n    }\n    m3ApiWriteMem32(nread, res);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_write)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(__wasi_size_t));\n\n    ssize_t res = 0;\n    for (__wasi_size_t i = 0; i < iovs_len; i++) {\n        void* addr = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        size_t len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        if (len == 0) continue;\n\n        int ret = write (fd, addr, len);\n        if (ret < 0) m3ApiReturn(errno_to_wasi(errno));\n        res += ret;\n        if ((size_t)ret < len) break;\n    }\n    m3ApiWriteMem32(nwritten, res);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_close)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n    int ret = close(fd);\n    m3ApiReturn(ret == 0 ? __WASI_ERRNO_SUCCESS : ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_datasync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n    // TODO\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_random_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n    m3ApiGetArg      (__wasi_size_t        , buf_len)\n\n    m3ApiCheckMem(buf, buf_len);\n\n    while (1) {\n        ssize_t retlen = 0;\n\n#if defined(__wasi__) || defined(__APPLE__) || defined(__ANDROID_API__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)\n        size_t reqlen = M3_MIN (buf_len, 256);\n#   if defined(__APPLE__) && (TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR)\n        retlen = SecRandomCopyBytes(kSecRandomDefault, reqlen, buf) < 0 ? -1 : reqlen;\n#   else\n        retlen = getentropy(buf, reqlen) < 0 ? -1 : reqlen;\n#   endif\n#elif defined(__FreeBSD__) || defined(__linux__)\n        retlen = getrandom(buf, buf_len, 0);\n#elif defined(_WIN32)\n        if (RtlGenRandom(buf, buf_len) == TRUE) {\n            m3ApiReturn(__WASI_ERRNO_SUCCESS);\n        }\n#else\n        m3ApiReturn(__WASI_ERRNO_NOSYS);\n#endif\n        if (retlen < 0) {\n            if (errno == EINTR || errno == EAGAIN) {\n                continue;\n            }\n            m3ApiReturn(errno_to_wasi(errno));\n        } else if (retlen == buf_len) {\n            m3ApiReturn(__WASI_ERRNO_SUCCESS);\n        } else {\n            buf     += retlen;\n            buf_len -= retlen;\n        }\n    }\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_res_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , resolution)\n\n    m3ApiCheckMem(resolution, sizeof(__wasi_timestamp_t));\n\n    int clk = convert_clockid(wasi_clk_id);\n    if (clk < 0) m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    struct timespec tp;\n    if (clock_getres(clk, &tp) != 0) {\n        m3ApiWriteMem64(resolution, 1000000);\n    } else {\n        m3ApiWriteMem64(resolution, convert_timespec(&tp));\n    }\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_time_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArg      (__wasi_timestamp_t   , precision)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , time)\n\n    m3ApiCheckMem(time, sizeof(__wasi_timestamp_t));\n\n    int clk = convert_clockid(wasi_clk_id);\n    if (clk < 0) m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    struct timespec tp;\n    if (clock_gettime(clk, &tp) != 0) {\n        m3ApiReturn(errno_to_wasi(errno));\n    }\n\n    m3ApiWriteMem64(time, convert_timespec(&tp));\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_exit)\n{\n    m3ApiGetArg      (uint32_t, code)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context) {\n        context->exit_code = code;\n    }\n\n    m3ApiTrap(m3Err_trapExit);\n}\n\n\nstatic\nM3Result SuppressLookupFailure(M3Result i_result)\n{\n    if (i_result == m3Err_functionLookupFailed)\n        return m3Err_none;\n    else\n        return i_result;\n}\n\nm3_wasi_context_t* m3_GetWasiContext()\n{\n    return wasi_context;\n}\n\n\nM3Result  m3_LinkEspWASI  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    // TODO: Preopen dirs\n\n    if (!wasi_context) {\n        wasi_context = (m3_wasi_context_t*)malloc(sizeof(m3_wasi_context_t));\n        wasi_context->exit_code = 0;\n        wasi_context->argc = 0;\n        wasi_context->argv = 0;\n    }\n\n    static const char* namespaces[2] = { \"wasi_unstable\", \"wasi_snapshot_preview1\" };\n\n    // fd_seek is incompatible\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_seek\",     \"i(iIi*)\", &m3_wasi_unstable_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_seek\",     \"i(iIi*)\", &m3_wasi_snapshot_preview1_fd_seek)));\n\n    for (int i=0; i<2; i++)\n    {\n        const char* wasi = namespaces[i];\n\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_get\",           \"i(**)\",   &m3_wasi_generic_args_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_sizes_get\",     \"i(**)\",   &m3_wasi_generic_args_sizes_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_res_get\",        \"i(i*)\",   &m3_wasi_generic_clock_res_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_time_get\",       \"i(iI*)\",  &m3_wasi_generic_clock_time_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_get\",          \"i(**)\",   &m3_wasi_generic_environ_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_sizes_get\",    \"i(**)\",   &m3_wasi_generic_environ_sizes_get)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_advise\",            \"i(iIIi)\", )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_allocate\",          \"i(iII)\",  )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_close\",             \"i(i)\",    &m3_wasi_generic_fd_close)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_datasync\",          \"i(i)\",    &m3_wasi_generic_fd_datasync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_get\",        \"i(i*)\",   &m3_wasi_generic_fd_fdstat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_flags\",  \"i(ii)\",   &m3_wasi_generic_fd_fdstat_set_flags)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_rights\", \"i(iII)\",  )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_get\",      \"i(i*)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_size\", \"i(iI)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_times\",\"i(iIIi)\", )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pread\",             \"i(i*iI*)\",)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_get\",       \"i(i*)\",   &m3_wasi_generic_fd_prestat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_dir_name\",  \"i(i*i)\",  &m3_wasi_generic_fd_prestat_dir_name)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pwrite\",            \"i(i*iI*)\",)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_read\",              \"i(i*i*)\", &m3_wasi_generic_fd_read)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_readdir\",           \"i(i*iI*)\",)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_renumber\",          \"i(ii)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_sync\",              \"i(i)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_tell\",              \"i(i*)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_write\",             \"i(i*i*)\", &m3_wasi_generic_fd_write)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_create_directory\",    \"i(i*i)\",       )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_filestat_get\",        \"i(ii*i*)\",     &m3_wasi_generic_path_filestat_get)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_filestat_set_times\",  \"i(ii*iIIi)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_link\",                \"i(ii*ii*i)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_open\",                \"i(ii*iiIIi*)\", &m3_wasi_generic_path_open)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_readlink\",            \"i(i*i*i*)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_remove_directory\",    \"i(i*i)\",       )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_rename\",              \"i(i*ii*i)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_symlink\",             \"i(*ii*i)\",     )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_unlink_file\",         \"i(i*i)\",       )));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"poll_oneoff\",          \"i(**i*)\", &m3_wasi_generic_poll_oneoff)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"proc_exit\",          \"v(i)\",    &m3_wasi_generic_proc_exit, wasi_context)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"proc_raise\",           \"i(i)\",    )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"random_get\",           \"i(*i)\",   &m3_wasi_generic_random_get)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sched_yield\",          \"i()\",     )));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_recv\",            \"i(i*ii**)\",        )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_send\",            \"i(i*ii*)\",         )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_shutdown\",        \"i(ii)\",            )));\n    }\n\n_catch:\n    return result;\n}\n\n//#endif // ESP32\n\nM3Result m3_LinkEspWASI_Hello(IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    if (!wasi_context) {\n        ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: !wasi_context\");\n        wasi_context = (m3_wasi_context_t*)malloc(sizeof(m3_wasi_context_t));\n        if (!wasi_context) return m3Err_mallocFailed;\n        wasi_context->exit_code = 0;\n        wasi_context->argc = 0;\n        wasi_context->argv = 0;\n    }\n \n    // Linko solo le funzioni essenziali che ci servono\n    const char* wasi = \"wasi\";   \n\n    if(false){ // classic implementation\n        ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: link basic functions\");\n\n        // Funzioni di base per I/O\n        _(SuppressLookupFailure(m3_LinkRawFunction(module, wasi, \"fd_write\", \"i(i*i*)\", &m3_wasi_generic_fd_write)));\n        _(SuppressLookupFailure(m3_LinkRawFunction(module, wasi, \"fd_close\", \"i(i)\", &m3_wasi_generic_fd_close)));\n        //ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: done link fd_\");\n        \n        // Funzione di uscita\n        _(SuppressLookupFailure(m3_LinkRawFunctionEx(module, wasi, \"proc_exit\", \"v(i)\", &m3_wasi_generic_proc_exit, wasi_context)));\n        //ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: done link proc_\");\n\n        // Se usiamo args\n        _(SuppressLookupFailure(m3_LinkRawFunctionEx(module, wasi, \"args_get\", \"i(**)\", &m3_wasi_generic_args_get, wasi_context)));\n        _(SuppressLookupFailure(m3_LinkRawFunctionEx(module, wasi, \"args_sizes_get\", \"i(**)\", &m3_wasi_generic_args_sizes_get, wasi_context)));\n        //ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: done link args_\");\n    }\n    else {\n        ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: link basic functions with RegisterWasmFunctions\");\n\n        // Definizione della lookup table entry\n        const WasmFunctionEntry functionTable[] = {\n            { \n                .name = (const char*)\"args_get\",           \n                .func = m3_wasi_generic_args_get,   \n                .signature = (const char*)\"i(**)\"       \n            },\n            { \n                .name = (const char*)\"args_sizes_get\",           \n                .func = m3_wasi_generic_args_sizes_get,   \n                .signature = (const char*)\"i(**)\"       \n            },\n        };\n\n        M3Result result = RegisterWasmFunctions(module, functionTable, sizeof(functionTable)/sizeof(functionTable[0]));\n    }\n\n    ESP_LOGI(\"WASM3\", \"m3_LinkEspWASI: basic functions linked\");\n\n\n_catch:\n    if(result){\n        ESP_LOGE(\"WASM3\", \"m3_LinkEspWASI_Hello error: %s\", result);\n    }\n\n    return result;\n}", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_exec.c\n//\n//  Created by Steven Massey on 4/17/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n// EMPTY FOR NOW\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_function.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_function.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_function.h\n//\n//  Created by Steven Massey on 4/7/21.\n//  Copyright © 2021 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_core.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3FuncType\n{\n    struct M3FuncType *     next;\n\n    u16                     numRets;\n    u16                     numArgs;\n    u8                      types [];        // returns, then args\n}\nM3FuncType;\n\ntypedef M3FuncType *        IM3FuncType;\n\n\nM3Result    AllocFuncType                   (IM3FuncType * o_functionType, u32 i_numTypes);\nbool        AreFuncTypesEqual               (const IM3FuncType i_typeA, const IM3FuncType i_typeB);\n\nu16         GetFuncTypeNumParams            (const IM3FuncType i_funcType);\nu8          GetFuncTypeParamType            (const IM3FuncType i_funcType, u16 i_index);\n\nu16         GetFuncTypeNumResults           (const IM3FuncType i_funcType);\nu8          GetFuncTypeResultType           (const IM3FuncType i_funcType, u16 i_index);\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3Function\n{\n    struct M3Module *       module;\n\n    M3ImportInfo            import;\n\n    bytes_t                 wasm;\n    bytes_t                 wasmEnd;\n\n    cstr_t                  names[d_m3MaxDuplicateFunctionImpl];\n    cstr_t                  export_name;                            // should be a part of \"names\"\n    u16                     numNames;                               // maximum of d_m3MaxDuplicateFunctionImpl\n\n    IM3FuncType             funcType;\n\n    pc_t                    compiled;\n\n# if (d_m3EnableCodePageRefCounting)\n    IM3CodePage *           codePageRefs;                           // array of all pages used\n    u32                     numCodePageRefs;\n# endif\n\n# if defined (DEBUG)\n    u32                     hits;\n    u32                     index;\n# endif\n\n    u16                     maxStackSlots;\n\n    u16                     numRetSlots;\n    u16                     numRetAndArgSlots;\n\n    u16                     numLocals;                              // not including args\n    u16                     numLocalBytes;\n\n    bool                    ownsWasmCode;\n\n    u16                     numConstantBytes;\n    void *                  constants;\n}\nM3Function;\n\ntypedef M3Function *        IM3Function;\n\nvoid        Function_Release            (IM3Function i_function);\nvoid        Function_FreeCompiledCode   (IM3Function i_function);\n\ncstr_t      GetFunctionImportModuleName (IM3Function i_function);\ncstr_t *    GetFunctionNames            (IM3Function i_function, u16 * o_numNames);\nu16         GetFunctionNumArgs          (IM3Function i_function);\nu8          GetFunctionArgType          (IM3Function i_function, u32 i_index);\n\nu16         GetFunctionNumReturns       (IM3Function i_function);\nu8          GetFunctionReturnType       (const IM3Function i_function, u16 i_index);\n\nu32         GetFunctionNumArgsAndLocals (IM3Function i_function);\n\ncstr_t      SPrintFunctionArgList       (IM3Function i_function, m3stack_t i_sp);\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\n// Function type generation from signature\n\n// Mapping between WebAssembly type characters and WASM3 type values\n#define M3_TYPE_NONE    0\n#define M3_TYPE_I32     1\n#define M3_TYPE_I64     2\n#define M3_TYPE_F32     3\n#define M3_TYPE_F64     4\n\nM3FuncType* ParseFunctionSignature(const char* signature);\n\n// Struttura per memorizzare le informazioni della funzione\ntypedef struct {\n    const char* name;       // Nome della funzione\n    void* func;     // Puntatore alla funzione\n    const char* signature;  // Firma della funzione in formato WASM\n} WasmFunctionEntry;\n\n//M3Result addFunctionToModule(IM3Module module, const char* functionName, const char* signature);\nM3Result RegisterWasmFunction(IM3Module module, const WasmFunctionEntry* entry);\nM3Result RegisterWasmFunctions(IM3Module module, const WasmFunctionEntry* entries, size_t count);\n\n\nd_m3EndExternC\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/wasm3.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/wasm3.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  Wasm3, high performance WebAssembly interpreter\n//\n//  Copyright © 2019 Steven Massey, Volodymyr Shymanskyy.\n//  All rights reserved.\n//\n\n#pragma once\n\n#define M3_VERSION_MAJOR 0\n#define M3_VERSION_MINOR 5\n#define M3_VERSION_REV   1\n#define M3_VERSION       \"0.5.1\"\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdarg.h>\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"wasm3_defs.h\"\n\n// Constants\n#define M3_BACKTRACE_TRUNCATED      (IM3BacktraceFrame)(SIZE_MAX)\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\ntypedef const char *    M3Result;\n\nstruct M3Environment;   typedef struct M3Environment *  IM3Environment;\nstruct M3Runtime;       typedef struct M3Runtime *      IM3Runtime;\nstruct M3Module;        typedef struct M3Module *       IM3Module;\nstruct M3Function;      typedef struct M3Function *     IM3Function;\nstruct M3Global;        typedef struct M3Global *       IM3Global;\n\ntypedef struct M3ErrorInfo\n{\n    M3Result        result;\n\n    IM3Runtime      runtime;\n    IM3Module       module;\n    IM3Function     function;\n\n    const char *    file;\n    uint32_t        line;\n\n    const char *    message;\n} M3ErrorInfo;\n\ntypedef struct M3BacktraceFrame\n{\n    uint32_t                     moduleOffset;\n    IM3Function                  function;\n\n    struct M3BacktraceFrame *    next;\n}\nM3BacktraceFrame, * IM3BacktraceFrame;\n\ntypedef struct M3BacktraceInfo\n{\n    IM3BacktraceFrame      frames;\n    IM3BacktraceFrame      lastFrame;    // can be M3_BACKTRACE_TRUNCATED\n}\nM3BacktraceInfo, * IM3BacktraceInfo;\n\n\ntypedef enum M3ValueType\n{\n    c_m3Type_none   = 0,\n    c_m3Type_i32    = 1,\n    c_m3Type_i64    = 2,\n    c_m3Type_f32    = 3,\n    c_m3Type_f64    = 4,\n\n    c_m3Type_unknown\n} M3ValueType;\n\ntypedef struct M3TaggedValue\n{\n    M3ValueType type;\n    union M3ValueUnion\n    {\n        uint32_t    i32;\n        uint64_t    i64;\n        float       f32;\n        double      f64;\n    } value;\n}\nM3TaggedValue, * IM3TaggedValue;\n\ntypedef struct M3ImportInfo\n{\n    const char *    moduleUtf8;\n    const char *    fieldUtf8;\n}\nM3ImportInfo, * IM3ImportInfo;\n\n\ntypedef struct M3ImportContext\n{\n    void *          userdata;\n    IM3Function     function;\n}\nM3ImportContext, * IM3ImportContext;\n\n// -------------------------------------------------------------------------------------------------------------------------------\n//  error codes\n// -------------------------------------------------------------------------------------------------------------------------------\n\n# if defined(M3_IMPLEMENT_ERROR_STRINGS)\n#   if defined(__cplusplus)\n#     define d_m3ErrorConst(LABEL, STRING)      extern const M3Result m3Err_##LABEL = { STRING };\n#   else\n#     define d_m3ErrorConst(LABEL, STRING)      const M3Result m3Err_##LABEL = { STRING };\n#   endif\n# else\n#   define d_m3ErrorConst(LABEL, STRING)        extern const M3Result m3Err_##LABEL;\n# endif\n\n// -------------------------------------------------------------------------------------------------------------------------------\n\nd_m3ErrorConst  (none,                          NULL)\n\n// general errors\nd_m3ErrorConst  (mallocFailed,                  \"memory allocation failed\")\n\n// parse errors\nd_m3ErrorConst  (incompatibleWasmVersion,       \"incompatible Wasm binary version\")\nd_m3ErrorConst  (wasmMalformed,                 \"malformed Wasm binary\")\nd_m3ErrorConst  (m3Err_malformedUtf8,             \"malformed UTF-8\")\nd_m3ErrorConst  (misorderedWasmSection,         \"out of order Wasm section\")\nd_m3ErrorConst  (wasmUnderrun,                  \"underrun while parsing Wasm binary\")\nd_m3ErrorConst  (wasmOverrun,                   \"overrun while parsing Wasm binary\")\nd_m3ErrorConst  (wasmMissingInitExpr,           \"missing init_expr in Wasm binary\")\nd_m3ErrorConst  (lebOverflow,                   \"LEB encoded value overflow\")\nd_m3ErrorConst  (missingUTF8,                   \"invalid length UTF-8 string\")\nd_m3ErrorConst  (wasmSectionUnderrun,           \"section underrun while parsing Wasm binary\")\nd_m3ErrorConst  (wasmSectionOverrun,            \"section overrun while parsing Wasm binary\")\nd_m3ErrorConst  (invalidTypeId,                 \"unknown value_type\")\nd_m3ErrorConst  (tooManyMemorySections,         \"only one memory per module is supported\")\nd_m3ErrorConst  (tooManyArgsRets,               \"too many arguments or return values\")\n\n// link errors\nd_m3ErrorConst  (moduleNotLinked,               \"attempting to use module that is not loaded\")\nd_m3ErrorConst  (moduleAlreadyLinked,           \"attempting to bind module to multiple runtimes\")\nd_m3ErrorConst  (functionLookupFailed,          \"function lookup failed\")\nd_m3ErrorConst  (functionImportMissing,         \"missing imported function\")\n\nd_m3ErrorConst  (malformedFunctionSignature,    \"malformed function signature\")\n\n// compilation errors\nd_m3ErrorConst  (noCompiler,                    \"no compiler found for opcode\")\nd_m3ErrorConst  (unknownOpcode,                 \"unknown opcode\")\nd_m3ErrorConst  (restrictedOpcode,              \"restricted opcode\")\nd_m3ErrorConst  (functionStackOverflow,         \"compiling function overran its stack height limit\")\nd_m3ErrorConst  (functionStackUnderrun,         \"compiling function underran the stack\")\nd_m3ErrorConst  (mallocFailedCodePage,          \"memory allocation failed when acquiring a new M3 code page\")\nd_m3ErrorConst  (settingImmutableGlobal,        \"attempting to set an immutable global\")\nd_m3ErrorConst  (typeMismatch,                  \"incorrect type on stack\")\nd_m3ErrorConst  (typeCountMismatch,             \"incorrect value count on stack\")\n\n// runtime errors\nd_m3ErrorConst  (missingCompiledCode,           \"function is missing compiled m3 code\")\nd_m3ErrorConst  (wasmMemoryOverflow,            \"runtime ran out of memory\")\nd_m3ErrorConst  (globalMemoryNotAllocated,      \"global memory is missing from a module\")\nd_m3ErrorConst  (globaIndexOutOfBounds,         \"global index is too large\")\nd_m3ErrorConst  (argumentCountMismatch,         \"argument count mismatch\")\nd_m3ErrorConst  (argumentTypeMismatch,          \"argument type mismatch\")\nd_m3ErrorConst  (globalLookupFailed,            \"global lookup failed\")\nd_m3ErrorConst  (globalTypeMismatch,            \"global type mismatch\")\nd_m3ErrorConst  (globalNotMutable,              \"global is not mutable\")\nd_m3ErrorConst  (nullRuntime,                   \"runtime is null\")\n\n// traps\nd_m3ErrorConst  (trapOutOfBoundsMemoryAccess,   \"[trap] out of bounds memory access\")\nd_m3ErrorConst  (trapDivisionByZero,            \"[trap] integer divide by zero\")\nd_m3ErrorConst  (trapIntegerOverflow,           \"[trap] integer overflow\")\nd_m3ErrorConst  (trapIntegerConversion,         \"[trap] invalid conversion to integer\")\nd_m3ErrorConst  (trapIndirectCallTypeMismatch,  \"[trap] indirect call type mismatch\")\nd_m3ErrorConst  (trapTableIndexOutOfRange,      \"[trap] undefined element\")\nd_m3ErrorConst  (trapTableElementIsNull,        \"[trap] null table element\")\nd_m3ErrorConst  (trapExit,                      \"[trap] program called exit\")\nd_m3ErrorConst  (trapAbort,                     \"[trap] program called abort\")\nd_m3ErrorConst  (trapUnreachable,               \"[trap] unreachable executed\")\nd_m3ErrorConst  (trapStackOverflow,             \"[trap] stack overflow\")\n\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  configuration, can be found in m3_config.h, m3_config_platforms.h, m3_core.h)\n//-------------------------------------------------------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  global environment than can host multiple runtimes\n//-------------------------------------------------------------------------------------------------------------------------------\n    IM3Environment      m3_NewEnvironment           (void);\n\n    void                m3_FreeEnvironment          (IM3Environment i_environment);\n\n    typedef M3Result (* M3SectionHandler) (IM3Module i_module, const char* name, const uint8_t * start, const uint8_t * end);\n\n    void                m3_SetCustomSectionHandler  (IM3Environment i_environment,    M3SectionHandler i_handler);\n\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  execution context\n//-------------------------------------------------------------------------------------------------------------------------------\n\n    IM3Runtime          m3_NewRuntime               (IM3Environment         io_environment,\n                                                     uint32_t               i_stackSizeInBytes,\n                                                     void *                 i_userdata);\n\n    void                m3_FreeRuntime              (IM3Runtime             i_runtime);\n\n    // Wasm currently only supports one memory region. i_memoryIndex should be zero.\n    uint8_t *           m3_GetMemory                (IM3Runtime             i_runtime,\n                                                     uint32_t *             o_memorySizeInBytes,\n                                                     uint32_t               i_memoryIndex);\n\n    // This is used internally by Raw Function helpers\n    uint32_t            m3_GetMemorySize            (IM3Runtime             i_runtime);\n\n    void *              m3_GetUserData              (IM3Runtime             i_runtime);\n\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  modules\n//-------------------------------------------------------------------------------------------------------------------------------\n\n    // i_wasmBytes data must be persistent during the lifetime of the module\n    M3Result            m3_ParseModule              (IM3Environment         i_environment,\n                                                     IM3Module *            o_module,\n                                                     const uint8_t * const  i_wasmBytes,\n                                                     uint32_t               i_numWasmBytes);\n\n    // Only modules not loaded into a M3Runtime need to be freed. A module is considered unloaded if\n    // a. m3_LoadModule has not yet been called on that module. Or,\n    // b. m3_LoadModule returned a result.\n    void                m3_FreeModule               (IM3Module i_module);\n\n    //  LoadModule transfers ownership of a module to the runtime. Do not free modules once successfully loaded into the runtime\n    M3Result            m3_LoadModule               (IM3Runtime io_runtime,  IM3Module io_module);\n\n    // Optional, compiles all functions in the module\n    M3Result            m3_CompileModule            (IM3Module io_module);\n\n    // Calling m3_RunStart is optional\n    M3Result            m3_RunStart                 (IM3Module i_module);\n\n    // Arguments and return values are passed in and out through the stack pointer _sp.\n    // Placeholder return value slots are first and arguments after. So, the first argument is at _sp [numReturns]\n    // Return values should be written into _sp [0] to _sp [num_returns - 1]\n    typedef const void * (* M3RawCall) (IM3Runtime runtime, IM3ImportContext _ctx, uint64_t * _sp, void * _mem);\n\n    M3Result            m3_LinkRawFunction          (IM3Module              io_module,\n                                                     const char * const     i_moduleName,\n                                                     const char * const     i_functionName,\n                                                     const char * const     i_signature,\n                                                     M3RawCall              i_function);\n\n    M3Result            m3_LinkRawFunctionEx        (IM3Module              io_module,\n                                                     const char * const     i_moduleName,\n                                                     const char * const     i_functionName,\n                                                     const char * const     i_signature,\n                                                     M3RawCall              i_function,\n                                                     const void *           i_userdata);\n\n    const char*         m3_GetModuleName            (IM3Module i_module);\n    void                m3_SetModuleName            (IM3Module i_module, const char* name);\n    IM3Runtime          m3_GetModuleRuntime         (IM3Module i_module);\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  globals\n//-------------------------------------------------------------------------------------------------------------------------------\n    IM3Global           m3_FindGlobal               (IM3Module              io_module,\n                                                     const char * const     i_globalName);\n\n    M3Result            m3_GetGlobal                (IM3Global              i_global,\n                                                     IM3TaggedValue         o_value);\n\n    M3Result            m3_SetGlobal                (IM3Global              i_global,\n                                                     const IM3TaggedValue   i_value);\n\n    M3ValueType         m3_GetGlobalType            (IM3Global              i_global);\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  functions\n//-------------------------------------------------------------------------------------------------------------------------------\n    M3Result            m3_Yield                    (void);\n\n    // o_function is valid during the lifetime of the originating runtime\n    M3Result            m3_FindFunction             (IM3Function *          o_function,\n                                                     IM3Runtime             i_runtime,\n                                                     const char * const     i_functionName);\n    M3Result            m3_GetTableFunction         (IM3Function *          o_function,\n                                                     IM3Module              i_module,\n                                                     uint32_t               i_index);\n\n    uint32_t            m3_GetArgCount              (IM3Function i_function);\n    uint32_t            m3_GetRetCount              (IM3Function i_function);\n    M3ValueType         m3_GetArgType               (IM3Function i_function, uint32_t i_index);\n    M3ValueType         m3_GetRetType               (IM3Function i_function, uint32_t i_index);\n\n    M3Result            m3_CallV                    (IM3Function i_function, ...);\n    M3Result            m3_CallVL                   (IM3Function i_function, va_list i_args);\n    M3Result            m3_Call                     (IM3Function i_function, uint32_t i_argc, const void * i_argptrs[]);\n    M3Result            m3_CallArgv                 (IM3Function i_function, uint32_t i_argc, const char * i_argv[]);\n\n    M3Result            m3_GetResultsV              (IM3Function i_function, ...);\n    M3Result            m3_GetResultsVL             (IM3Function i_function, va_list o_rets);\n    M3Result            m3_GetResults               (IM3Function i_function, uint32_t i_retc, const void * o_retptrs[]);\n\n\n    void                m3_GetErrorInfo             (IM3Runtime i_runtime, M3ErrorInfo* o_info);\n    void                m3_ResetErrorInfo           (IM3Runtime i_runtime);\n\n    const char*         m3_GetFunctionName          (IM3Function i_function);\n    IM3Module           m3_GetFunctionModule        (IM3Function i_function);\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  debug info\n//-------------------------------------------------------------------------------------------------------------------------------\n\n    void                m3_PrintRuntimeInfo         (IM3Runtime i_runtime);\n    void                m3_PrintM3Info              (void);\n    void                m3_PrintProfilerInfo        (void);\n\n    // The runtime owns the backtrace, do not free the backtrace you obtain. Returns NULL if there's no backtrace.\n    IM3BacktraceInfo    m3_GetBacktrace             (IM3Runtime i_runtime);\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  raw function definition helpers\n//-------------------------------------------------------------------------------------------------------------------------------\n\n# define m3ApiOffsetToPtr(offset)   (void*)((uint8_t*)_mem + (uint32_t)(offset))\n# define m3ApiPtrToOffset(ptr)      (uint32_t)((uint8_t*)ptr - (uint8_t*)_mem)\n\n# define m3ApiReturnType(TYPE)                 TYPE* raw_return = ((TYPE*) (_sp++));\n# define m3ApiMultiValueReturnType(TYPE, NAME) TYPE* NAME = ((TYPE*) (_sp++));\n# define m3ApiGetArg(TYPE, NAME)               TYPE NAME = * ((TYPE *) (_sp++));\n# define m3ApiGetArgMem(TYPE, NAME)            TYPE NAME = (TYPE)m3ApiOffsetToPtr(* ((uint32_t *) (_sp++)));\n\n# define m3ApiIsNullPtr(addr)       ((void*)(addr) <= _mem)\n# define m3ApiCheckMem(addr, len)   { if (M3_UNLIKELY(((void*)(addr) < _mem) || ((uint64_t)(uintptr_t)(addr) + (len)) > ((uint64_t)(uintptr_t)(_mem)+m3_GetMemorySize(runtime)))) m3ApiTrap(m3Err_trapOutOfBoundsMemoryAccess); }\n\n# define m3ApiRawFunction(NAME)     const void * NAME (IM3Runtime runtime, IM3ImportContext _ctx, uint64_t * _sp, void * _mem)\n# define m3ApiReturn(VALUE)                   { *raw_return = (VALUE); return m3Err_none;}\n# define m3ApiMultiValueReturn(NAME, VALUE)   { *NAME = (VALUE); }\n# define m3ApiTrap(VALUE)                     { return VALUE; }\n# define m3ApiSuccess()                       { return m3Err_none; }\n\n# if defined(M3_BIG_ENDIAN)\n#  define m3ApiReadMem8(ptr)         (* (uint8_t *)(ptr))\n#  define m3ApiReadMem16(ptr)        m3_bswap16((* (uint16_t *)(ptr)))\n#  define m3ApiReadMem32(ptr)        m3_bswap32((* (uint32_t *)(ptr)))\n#  define m3ApiReadMem64(ptr)        m3_bswap64((* (uint64_t *)(ptr)))\n#  define m3ApiWriteMem8(ptr, val)   { * (uint8_t  *)(ptr)  = (val); }\n#  define m3ApiWriteMem16(ptr, val)  { * (uint16_t *)(ptr) = m3_bswap16((val)); }\n#  define m3ApiWriteMem32(ptr, val)  { * (uint32_t *)(ptr) = m3_bswap32((val)); }\n#  define m3ApiWriteMem64(ptr, val)  { * (uint64_t *)(ptr) = m3_bswap64((val)); }\n# else\n#  define m3ApiReadMem8(ptr)         (* (uint8_t *)(ptr))\n#  define m3ApiReadMem16(ptr)        (* (uint16_t *)(ptr))\n#  define m3ApiReadMem32(ptr)        (* (uint32_t *)(ptr))\n#  define m3ApiReadMem64(ptr)        (* (uint64_t *)(ptr))\n#  define m3ApiWriteMem8(ptr, val)   { * (uint8_t  *)(ptr) = (val); }\n#  define m3ApiWriteMem16(ptr, val)  { * (uint16_t *)(ptr) = (val); }\n#  define m3ApiWriteMem32(ptr, val)  { * (uint32_t *)(ptr) = (val); }\n#  define m3ApiWriteMem64(ptr, val)  { * (uint64_t *)(ptr) = (val); }\n# endif\n\n#if defined(__cplusplus)\n}\n#endif\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_includes.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_includes.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#pragma once\n\n// Trying to reorder the inclusion order\n#include \"m3_api_libc.h\"\n#include \"m3_env.h\"\n#include \"m3_parse.h\"\n#include \"m3_segmented_memory.h\"\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_config_platforms.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_config_platforms.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_config_platforms.h\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include \"wasm3_defs.h\"\n#include \"m3_exception.h\"\n\n// Ad hoc configuration settings for ESP32\n// m3_config_platform.h\n#include \"esp_heap_caps.h\"\n#include \"esp_log.h\"\n\n// Ridefinizione delle funzioni di gestione memoria\n#define M3_MALLOC(size)     heap_caps_malloc(size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL)\n#define M3_REALLOC(ptr, size) heap_caps_realloc(ptr, size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL)\n#define M3_FREE(ptr)        heap_caps_free(ptr)\n\n// Opzionale: Wrapper per tracciamento allocazioni\n#ifdef DEBUG_MEMORY\nstatic void* debug_malloc(size_t size) {\n    void* ptr = heap_caps_malloc(size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    ESP_LOGI(\"WASM3_MEM\", \"Malloc: %d bytes at %p\", size, ptr);\n    return ptr;\n}\n\nstatic void* debug_realloc(void* ptr, size_t size) {\n    void* new_ptr = heap_caps_realloc(ptr, size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    ESP_LOGI(\"WASM3_MEM\", \"Realloc: %p -> %p (%d bytes)\", ptr, new_ptr, size);\n    return new_ptr;\n}\n\nstatic void debug_free(void* ptr) {\n    ESP_LOGI(\"WASM3_MEM\", \"Free: %p\", ptr);\n    heap_caps_free(ptr);\n}\n\n#undef M3_MALLOC\n#undef M3_REALLOC\n#undef M3_FREE\n#define M3_MALLOC(size)     debug_malloc(size)\n#define M3_REALLOC(ptr, size) debug_realloc(ptr, size)\n#define M3_FREE(ptr)        debug_free(ptr)\n#endif\n\n// Funzione helper per verificare memoria disponibile\nstatic bool check_memory_available(size_t required_size) {\n    multi_heap_info_t info;\n    heap_caps_get_info(&info, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    \n    // Verifica sia la memoria totale che la dimensione del blocco più grande\n    if (info.total_free_bytes < required_size || \n        info.largest_free_block < required_size) {\n        ESP_LOGE(\"WASM3_MEM\", \"Not enough memory. Required: %d, Free: %d, Largest block: %d\",\n                 required_size, info.total_free_bytes, info.largest_free_block);\n        return false;\n    }\n    return true;\n}\n\n// Funzione per pre-allocare la memoria necessaria\nstatic void* preallocate_wasm_memory(size_t size) {\n    if (!check_memory_available(size)) {\n        return NULL;\n    }\n    \n    // Alloca in una regione specifica della memoria\n    void* ptr = heap_caps_malloc(size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    if (ptr) {\n        ESP_LOGI(\"WASM3_MEM\", \"Pre-allocated %d bytes at %p\", size, ptr);\n    }\n    return ptr;\n}\n\n///\n/// End of ad hoc memory management\n///\n\n/*\n * Internal helpers\n */\n\n# if !defined(__cplusplus) || defined(_MSC_VER)\n#   define not      !\n#   define and      &&\n#   define or       ||\n# endif\n\n/*\n * Detect/define features\n */\n\n# if defined(M3_COMPILER_MSVC)\n#  include <stdint.h>\n#  if UINTPTR_MAX == 0xFFFFFFFF\n#   define M3_SIZEOF_PTR 4\n#  elif UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu\n#   define M3_SIZEOF_PTR 8\n#  else\n#   error \"Pointer size not supported\"\n#  endif\n# elif defined(__SIZEOF_POINTER__)\n#  define M3_SIZEOF_PTR __SIZEOF_POINTER__\n#else\n#  error \"Pointer size not detected\"\n# endif\n\n# if defined(M3_BIG_ENDIAN)\n#  define M3_BSWAP_u8(X)  {}\n#  define M3_BSWAP_u16(X) { (X)=m3_bswap16((X)); }\n#  define M3_BSWAP_u32(X) { (X)=m3_bswap32((X)); }\n#  define M3_BSWAP_u64(X) { (X)=m3_bswap64((X)); }\n#  define M3_BSWAP_i8(X)  {}\n#  define M3_BSWAP_i16(X) M3_BSWAP_u16(X)\n#  define M3_BSWAP_i32(X) M3_BSWAP_u32(X)\n#  define M3_BSWAP_i64(X) M3_BSWAP_u64(X)\n#  define M3_BSWAP_f32(X) { union { f32 f; u32 i; } u; u.f = (X); M3_BSWAP_u32(u.i); (X) = u.f; }\n#  define M3_BSWAP_f64(X) { union { f64 f; u64 i; } u; u.f = (X); M3_BSWAP_u64(u.i); (X) = u.f; }\n# else\n#  define M3_BSWAP_u8(X)  {}\n#  define M3_BSWAP_u16(x) {}\n#  define M3_BSWAP_u32(x) {}\n#  define M3_BSWAP_u64(x) {}\n#  define M3_BSWAP_i8(X)  {}\n#  define M3_BSWAP_i16(X) {}\n#  define M3_BSWAP_i32(X) {}\n#  define M3_BSWAP_i64(X) {}\n#  define M3_BSWAP_f32(X) {}\n#  define M3_BSWAP_f64(X) {}\n# endif\n\n# if defined(M3_COMPILER_MSVC)\n#  define M3_WEAK //__declspec(selectany)\n#  define M3_NO_UBSAN\n#  define M3_NOINLINE\n# elif defined(__MINGW32__) || defined(__CYGWIN__)\n#  define M3_WEAK //__attribute__((selectany))\n#  define M3_NO_UBSAN\n#  define M3_NOINLINE   __attribute__((noinline))\n# else\n#  define M3_WEAK       __attribute__((weak))\n#  define M3_NO_UBSAN   //__attribute__((no_sanitize(\"undefined\")))\n// Workaround for Cosmopolitan noinline conflict: https://github.com/jart/cosmopolitan/issues/310\n#  if defined(noinline)\n#    define M3_NOINLINE   noinline\n#  else\n#    define M3_NOINLINE   __attribute__((noinline))\n#  endif\n# endif\n\n# if !defined(M3_HAS_TAIL_CALL)\n#  if defined(__EMSCRIPTEN__)\n#   define M3_HAS_TAIL_CALL 0\n#  else\n#   define M3_HAS_TAIL_CALL 1\n#  endif\n# endif\n\n# if M3_HAS_TAIL_CALL && M3_COMPILER_HAS_ATTRIBUTE(musttail)\n#   define M3_MUSTTAIL __attribute__((musttail))\n# else\n#   define M3_MUSTTAIL\n# endif\n\n# ifndef M3_MIN\n#  define M3_MIN(A,B) (((A) < (B)) ? (A) : (B))\n# endif\n# ifndef M3_MAX\n#  define M3_MAX(A,B) (((A) > (B)) ? (A) : (B))\n# endif\n\n#define M3_INIT(field) memset(&field, 0, sizeof(field))\n\n#define M3_COUNT_OF(x) ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))\n\n#if defined(__AVR__)\n\n#include <inttypes.h>\n\n# define PRIu64         \"llu\"\n# define PRIi64         \"lli\"\n\n# define d_m3ShortTypesDefined\ntypedef double          f64;\ntypedef float           f32;\ntypedef uint64_t        u64;\ntypedef int64_t         i64;\ntypedef uint32_t        u32;\ntypedef int32_t         i32;\ntypedef short unsigned  u16;\ntypedef short           i16;\ntypedef uint8_t         u8;\ntypedef int8_t          i8;\n\n#endif\n\n/*\n * Apply settings\n */\n\n# if defined (M3_COMPILER_MSVC)\n#   define vectorcall   // For MSVC, better not to specify any call convention\n# elif defined(__x86_64__)\n#   define vectorcall\n//# elif defined(__riscv) && (__riscv_xlen == 64)\n//#   define vectorcall\n# elif defined(__MINGW32__)\n#   define vectorcall\n# elif defined(WIN32)\n#   define vectorcall   __vectorcall\n# elif defined (ESP8266)\n#   include <c_types.h>\n#   define vectorcall   //ICACHE_FLASH_ATTR\n# elif defined (ESP32)\n#   if defined(M3_IN_IRAM)  // the interpreter is in IRAM, attribute not needed\n#     define vectorcall\n#   else\n#     include \"esp_system.h\"\n#     define vectorcall   IRAM_ATTR\n#   endif\n# elif defined (FOMU)\n#   define vectorcall   __attribute__((section(\".ramtext\")))\n# endif\n\n#ifndef vectorcall\n#define vectorcall\n#endif\n\n\n/*\n * Device-specific defaults\n */\n\n# ifndef d_m3MaxFunctionStackHeight\n#  if defined(ESP8266) || defined(ESP32) || defined(ARDUINO_AMEBA) || defined(TEENSYDUINO)\n#    define d_m3MaxFunctionStackHeight          256\n#  endif\n# endif\n\n# ifndef d_m3FixedHeap\n#  if defined(ARDUINO_AMEBA)\n#    define d_m3FixedHeap                       (128*1024)\n#  elif defined(BLUE_PILL) || defined(FOMU)\n#    define d_m3FixedHeap                       (12*1024)\n#  elif defined(ARDUINO_ARCH_ARC32) // Arduino 101\n#    define d_m3FixedHeap                       (10*1024)\n#  endif\n# endif\n\n/*\n * Platform-specific defaults\n */\n\n# if defined(ARDUINO) || defined(PARTICLE) || defined(PLATFORMIO) || defined(__MBED__) || \\\n     defined(ESP8266) || defined(ESP32) || defined(BLUE_PILL) || defined(WM_W600) || defined(FOMU)\n# ifndef d_m3CascadedOpcodes\n#   define d_m3CascadedOpcodes                  0\n# endif\n#  ifndef d_m3VerboseErrorMessages\n#    define d_m3VerboseErrorMessages            0\n#  endif\n# ifndef d_m3MaxConstantTableSize\n#   define d_m3MaxConstantTableSize             64\n# endif\n#  ifndef d_m3MaxFunctionStackHeight\n#    define d_m3MaxFunctionStackHeight          128\n#  endif\n#  ifndef d_m3CodePageAlignSize\n#    define d_m3CodePageAlignSize               1024\n#  endif\n# endif\n\n/*\n * Arch-specific defaults\n */\n#if defined(__riscv) && (__riscv_xlen == 64)\n#  ifndef d_m3Use32BitSlots\n#    define d_m3Use32BitSlots                   0\n#  endif\n#endif\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_bind.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_bind.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_bind.c\n//\n//  Created by Steven Massey on 4/29/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include \"m3_env.h\"\n#include \"m3_exception.h\"\n#include \"m3_info.h\"\n#include \"m3_pointers.h\"\n\n#include \"esp_log.h\"\n\nu8  ConvertTypeCharToTypeId (char i_code)\n{\n    switch (i_code) {\n    case 'v': return c_m3Type_none;\n    case 'i': return c_m3Type_i32;\n    case 'I': return c_m3Type_i64;\n    case 'f': return c_m3Type_f32;\n    case 'F': return c_m3Type_f64;\n    case '*': return c_m3Type_i32;\n    }\n    return c_m3Type_unknown;\n}\n\n\nM3Result  SignatureToFuncType  (IM3FuncType * o_functionType, ccstr_t i_signature)\n{\n    IM3FuncType funcType = NULL;\n\n_try {\n    if (not o_functionType)\n        _throw (\"null function type\");\n\n    if (not i_signature)\n        _throw (\"null function signature\");\n\n    cstr_t sig = i_signature;\n\n    size_t maxNumTypes = strlen (i_signature);\n\n    // assume min signature is \"()\"\n    _throwif (m3Err_malformedFunctionSignature, maxNumTypes < 2);\n    maxNumTypes -= 2;\n\n    _throwif (m3Err_tooManyArgsRets, maxNumTypes > d_m3MaxSaneFunctionArgRetCount);\n\n_   (AllocFuncType (& funcType, (u32) maxNumTypes));\n\n    u8 * typelist = funcType->types;\n\n    bool parsingRets = true;\n    while (* sig)\n    {\n        char typeChar = * sig++;\n\n        if (typeChar == '(')\n        {\n            parsingRets = false;\n            continue;\n        }\n        else if ( typeChar == ' ')\n            continue;\n        else if (typeChar == ')')\n            break;\n\n        u8 type = ConvertTypeCharToTypeId (typeChar);\n\n        _throwif (\"unknown argument type char\", c_m3Type_unknown == type);\n\n        if (type == c_m3Type_none)\n            continue;\n\n        if (parsingRets)\n        {\n            _throwif (\"malformed signature; return count overflow\", funcType->numRets >= maxNumTypes);\n            funcType->numRets++;\n            *typelist++ = type;\n        }\n        else\n        {\n            _throwif (\"malformed signature; arg count overflow\", (u32)(funcType->numRets) + funcType->numArgs >= maxNumTypes);\n            funcType->numArgs++;\n            *typelist++ = type;\n        }\n    }\n\n} _catch:\n    if (result){\n        ESP_LOGE(\"WASM3\", \"SignatureToFuncType error: %s\", result);\n        m3_Int_Free (funcType);\n    }\n\n    * o_functionType = funcType;\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////\n// Log signature\n\n// Convertiamo da type ID a char\nchar convertTypeIdToChar(u8 typeId) {\n    switch (typeId) {\n        case c_m3Type_i32: return 'i';\n        case c_m3Type_i64: return 'I';\n        case c_m3Type_f32: return 'f';\n        case c_m3Type_f64: return 'F';\n        default: return '?';\n    }\n}\n\nchar* m3_type_to_signature(const M3FuncType* type) {\n    if (!type) return NULL;\n    \n    // Calcoliamo la dimensione necessaria per la stringa\n    size_t size = 3 + type->numArgs + type->numRets;  // v() + types + \\0\n    char* signature = (char*)malloc(size);\n    if (!signature) return NULL;\n    \n    char* curr = signature;\n    \n    // Return type (sempre 'v' nel tuo caso dato che hai mostrato 'v' nell'output)\n    *curr++ = 'v';\n    \n    // Parentesi aperta\n    *curr++ = '(';\n    \n    // Tipi degli argomenti\n    for (int i = 0; i < type->numArgs; i++) {\n        *curr++ = convertTypeIdToChar(type->types[type->numRets + i]);\n    }\n    \n    // Parentesi chiusa e terminatore\n    *curr++ = ')';\n    *curr = '\\0';\n    \n    return signature;\n}\n\n////////////////////////////////////////////////////////////////\n\nstatic\nM3Result  ValidateSignature  (IM3Function i_function, ccstr_t i_linkingSignature)\n{\n    M3Result result = m3Err_none;\n\n    IM3FuncType ftype = NULL;\n_   (SignatureToFuncType (& ftype, i_linkingSignature));\n\n    if (not AreFuncTypesEqual (ftype, i_function->funcType))\n    {\n        m3log (module, \"expected: %s\", SPrintFuncTypeSignature (ftype));\n        m3log (module, \"   found: %s\", SPrintFuncTypeSignature (i_function->funcType));\n        \n        ESP_LOGE(\"WASM3\", \"Signature excepted: %s\", m3_type_to_signature (ftype));\n        ESP_LOGE(\"WASM3\", \"Signature found: %s\", m3_type_to_signature (i_function->funcType));\n\n        _throw (\"function signature mismatch\");\n    }\n\n    _catch:\n\n    if(result){\n        ESP_LOGE(\"WASM3\", \"ValidateSignature failed: %s\", result);\n        m3_Int_Free (ftype);\n    }    \n\n    return result;\n}\n\n\nstatic const bool WASM_DEBUG_FIND_LINK_FUNC = true;\nM3Result  FindAndLinkFunction      (IM3Module       io_module,\n                                    ccstr_t         i_moduleName,\n                                    ccstr_t         i_functionName,\n                                    ccstr_t         i_signature,\n                                    voidptr_t       i_function,\n                                    voidptr_t       i_userdata)\n{\n_try {\n    _throwif(m3Err_moduleNotLinked, !io_module->runtime);\n\n    const bool wildcardModule = (strcmp (i_moduleName, \"*\") == 0);\n\n    result = m3Err_functionLookupFailed;\n\n    for (u32 i = 0; i < io_module->numFunctions; ++i) // should be ++i (pay attention in case of problems)\n    {\n        const IM3Function f = & io_module->functions [i];\n\n        if (f->import.moduleUtf8 and f->import.fieldUtf8)\n        {\n            if(WASM_DEBUG_FIND_LINK_FUNC) ESP_LOGI(\"WASM3\", \"FindAndLinkFunction: Valid function: %s.%s\",  f->import.moduleUtf8, f->import.fieldUtf8);\n\n            if (strcmp (f->import.fieldUtf8, i_functionName) == 0 and\n               (wildcardModule or strcmp (f->import.moduleUtf8, i_moduleName) == 0))\n            {\n                ESP_LOGI(\"WASM3\", \"FindAndLinkFunction: Right function found!\");\n                if (i_signature) {\n_                   (ValidateSignature (f, i_signature));\n                }\n_               (CompileRawFunction (io_module, f, i_function, i_userdata));\n            }\n        }\n    }\n} _catch:\n    //ESP_LOGE(\"WASM3\", \"FindAndLinkFunction error: %s\", result);\n    return result;\n}\n\nM3Result  m3_LinkRawFunctionEx  (IM3Module            io_module,\n                                const char * const    i_moduleName,\n                                const char * const    i_functionName,\n                                const char * const    i_signature,\n                                M3RawCall             i_function,\n                                const void *          i_userdata)\n{\n    return FindAndLinkFunction (io_module, i_moduleName, i_functionName, i_signature, (voidptr_t)i_function, i_userdata);\n}\n\nM3Result  m3_LinkRawFunction  (IM3Module            io_module,\n                              const char * const    i_moduleName,\n                              const char * const    i_functionName,\n                              const char * const    i_signature,\n                              M3RawCall             i_function)\n{\n    return FindAndLinkFunction (io_module, i_moduleName, i_functionName, i_signature, (voidptr_t)i_function, NULL);\n}\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_info.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_info.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_info.c\n//\n//  Created by Steven Massey on 4/27/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include \"m3_env.h\"\n#include \"m3_info.h\"\n#include \"m3_compile.h\"\n\n#if defined(DEBUG) || (d_m3EnableStrace >= 2)\n\nsize_t  SPrintArg  (char * o_string, size_t i_stringBufferSize, voidptr_t i_sp, u8 i_type)\n{\n    int len = 0;\n\n    * o_string = 0;\n\n    if      (i_type == c_m3Type_i32)\n        len = snprintf (o_string, i_stringBufferSize, \"%\" PRIi32, * (i32 *) i_sp);\n    else if (i_type == c_m3Type_i64)\n        len = snprintf (o_string, i_stringBufferSize, \"%\" PRIi64, * (i64 *) i_sp);\n#if d_m3HasFloat\n    else if (i_type == c_m3Type_f32)\n        len = snprintf (o_string, i_stringBufferSize, \"%\" PRIf32, * (f32 *) i_sp);\n    else if (i_type == c_m3Type_f64)\n        len = snprintf (o_string, i_stringBufferSize, \"%\" PRIf64, * (f64 *) i_sp);\n#endif\n\n    len = M3_MAX (0, len);\n\n    return len;\n}\n\n\ncstr_t  SPrintFunctionArgList  (IM3Function i_function, m3stack_t i_sp)\n{\n    int ret;\n    static char string [256];\n\n    char * s = string;\n    ccstr_t e = string + sizeof(string) - 1;\n\n    ret = snprintf (s, e-s, \"(\");\n    s += M3_MAX (0, ret);\n\n    u64 * argSp = (u64 *) i_sp;\n\n    IM3FuncType funcType = i_function->funcType;\n    if (funcType)\n    {\n        u32 numArgs = funcType->numArgs;\n\n        for (u32 i = 0; i < numArgs; ++i)\n        {\n            u8 type = d_FuncArgType(funcType, i);\n\n            ret = snprintf (s, e-s, \"%s: \", c_waTypes [type]);\n            s += M3_MAX (0, ret);\n\n            s += SPrintArg (s, e-s, argSp + i, type);\n\n            if (i != numArgs - 1) {\n                ret = snprintf (s, e-s, \", \");\n                s += M3_MAX (0, ret);\n            }\n        }\n    }\n    else printf (\"null signature\");\n\n    ret = snprintf (s, e-s, \")\");\n    s += M3_MAX (0, ret);\n\n    return string;\n}\n\n#endif\n\n#ifdef DEBUG\n\n// a central function you can be breakpoint:\nvoid ExceptionBreakpoint (cstr_t i_exception, cstr_t i_message)\n{\n    printf (\"\\nexception: '%s' @ %s\\n\", i_exception, i_message);\n    return;\n}\n\n\ntypedef struct OpInfo\n{\n    IM3OpInfo   info;\n    m3opcode_t  opcode;\n}\nOpInfo;\n\nvoid  m3_PrintM3Info  ()\n{\n    printf (\"\\n-- m3 configuration --------------------------------------------\\n\");\n//  printf (\" sizeof M3CodePage    : %zu bytes  (%d slots) \\n\", sizeof (M3CodePage), c_m3CodePageNumSlots);\n    printf (\" sizeof M3MemPage     : %u bytes              \\n\", d_m3DefaultMemPageSize);\n    printf (\" sizeof M3Compilation : %zu bytes             \\n\", sizeof (M3Compilation));\n    printf (\" sizeof M3Function    : %zu bytes             \\n\", sizeof (M3Function));\n    printf (\"----------------------------------------------------------------\\n\\n\");\n}\n\n\nvoid *  v_PrintEnvModuleInfo  (IM3Module i_module, u32 * io_index)\n{\n    printf (\" module [%u]  name: '%s'; funcs: %d  \\n\", * io_index++, i_module->name, i_module->numFunctions);\n\n    return NULL;\n}\n\n\nvoid  m3_PrintRuntimeInfo  (IM3Runtime i_runtime)\n{\n    printf (\"\\n-- m3 runtime -------------------------------------------------\\n\");\n\n    printf (\" stack-size: %zu   \\n\\n\", i_runtime->numStackSlots * sizeof (m3slot_t));\n\n    u32 moduleIndex = 0;\n    ForEachModule (i_runtime, (ModuleVisitor) v_PrintEnvModuleInfo, & moduleIndex);\n\n    printf (\"----------------------------------------------------------------\\n\\n\");\n}\n\n\ncstr_t  GetTypeName  (u8 i_m3Type)\n{\n    if (i_m3Type < 5)\n        return c_waTypes [i_m3Type];\n    else\n        return \"?\";\n}\n\n\n// TODO: these 'static char string []' aren't thread-friendly.  though these functions are\n// mainly for simple diagnostics during development, it'd be nice if they were fully reliable.\n\ncstr_t  SPrintFuncTypeSignature  (IM3FuncType i_funcType)\n{\n    static char string [256];\n\n    sprintf (string, \"(\");\n\n    for (u32 i = 0; i < i_funcType->numArgs; ++i)\n    {\n        if (i != 0)\n            strcat (string, \", \");\n\n        strcat (string, GetTypeName (d_FuncArgType(i_funcType, i)));\n    }\n\n    strcat (string, \") -> \");\n\n    for (u32 i = 0; i < i_funcType->numRets; ++i)\n    {\n        if (i != 0)\n            strcat (string, \", \");\n\n        strcat (string, GetTypeName (d_FuncRetType(i_funcType, i)));\n    }\n\n    return string;\n}\n\n\ncstr_t  SPrintValue  (void * i_value, u8 i_type)\n{\n    static char string [100];\n    SPrintArg (string, 100, (m3stack_t) i_value, i_type);\n    return string;\n}\n\nstatic\nOpInfo find_operation_info  (IM3Operation i_operation)\n{\n    OpInfo opInfo = { NULL, 0 };\n\n    if (!i_operation) return opInfo;\n\n    // TODO: find also extended opcodes\n    for (u32 i = 0; i <= 0xff; ++i)\n    {\n        IM3OpInfo oi = GetOpInfo (i);\n\n        if (oi->type != c_m3Type_unknown)\n        {\n            for (u32 o = 0; o < 4; ++o)\n            {\n                if (oi->operations [o] == i_operation)\n                {\n                    opInfo.info = oi;\n                    opInfo.opcode = i;\n                    break;\n                }\n            }\n        }\n        else break;\n    }\n\n    return opInfo;\n}\n\n\n#undef fetch\n#define fetch(TYPE) (* (TYPE *) ((*o_pc)++))\n\n#define d_m3Decoder(FUNC) void Decode_##FUNC (char * o_string, u8 i_opcode, IM3Operation i_operation, IM3OpInfo i_opInfo, pc_t * o_pc)\n\nd_m3Decoder  (Call)\n{\n    void * function = fetch (void *);\n    i32 stackOffset = fetch (i32);\n\n    sprintf (o_string, \"%p; stack-offset: %d\", function, stackOffset);\n}\n\n\nd_m3Decoder (Entry)\n{\n    IM3Function function = fetch (IM3Function);\n\n    // only prints out the first registered name for the function\n    sprintf (o_string, \"%s\", m3_GetFunctionName(function));\n}\n\n\nd_m3Decoder (f64_Store)\n{\n    if (i_operation == i_opInfo->operations [0])\n    {\n        u32 operand = fetch (u32);\n        u32 offset = fetch (u32);\n\n        sprintf (o_string, \"offset= slot:%d + immediate:%d\", operand, offset);\n    }\n\n//    sprintf (o_string, \"%s\", function->name);\n}\n\n\nd_m3Decoder  (Branch)\n{\n    void * target = fetch (void *);\n    sprintf (o_string, \"%p\", target);\n}\n\nd_m3Decoder  (BranchTable)\n{\n    u32 slot = fetch (u32);\n\n    o_string += sprintf (o_string, \"slot: %\" PRIu32 \"; targets: \", slot);\n\n//    IM3Function function = fetch2 (IM3Function);\n\n    i32 targets = fetch (i32);\n\n    for (i32 i = 0; i < targets; ++i)\n    {\n        pc_t addr = fetch (pc_t);\n        o_string += sprintf (o_string, \"%\" PRIi32 \"=%p, \", i, addr);\n    }\n\n    pc_t addr = fetch (pc_t);\n    sprintf (o_string, \"def=%p \", addr);\n}\n\n\nd_m3Decoder  (Const)\n{\n    u64 value = fetch (u64); i32 offset = fetch (i32);\n    sprintf (o_string, \" slot [%d] = %\" PRIu64, offset, value);\n}\n\n\n#undef fetch\n\nvoid  DecodeOperation  (char * o_string, u8 i_opcode, IM3Operation i_operation, IM3OpInfo i_opInfo, pc_t * o_pc)\n{\n    #define d_m3Decode(OPCODE, FUNC) case OPCODE: Decode_##FUNC (o_string, i_opcode, i_operation, i_opInfo, o_pc); break;\n\n    switch (i_opcode)\n    {\n//        d_m3Decode (0xc0,                  Const)\n        d_m3Decode (0xc5,                  Entry)\n        d_m3Decode (c_waOp_call,           Call)\n        d_m3Decode (c_waOp_branch,         Branch)\n        d_m3Decode (c_waOp_branchTable,    BranchTable)\n        d_m3Decode (0x39,                  f64_Store)\n    }\n}\n\n// WARNING/TODO: this isn't fully implemented. it blindly assumes each word is a Operation pointer\n// and, if an operation happens to missing from the c_operations table it won't be recognized here\nvoid  dump_code_page  (IM3CodePage i_codePage, pc_t i_startPC)\n{\n        m3log (code, \"code page seq: %d\", i_codePage->info.sequence);\n\n        pc_t pc = i_startPC ? i_startPC : GetPageStartPC (i_codePage);\n        pc_t end = GetPagePC (i_codePage);\n\n        m3log (code, \"---------------------------------------------------------------------------------------\");\n\n        while (pc < end)\n        {\n            pc_t operationPC = pc;\n            IM3Operation op = (IM3Operation) (* pc++);\n\n                OpInfo i = find_operation_info (op);\n\n                if (i.info)\n                {\n                    char infoString [8*1024] = { 0 };\n\n                    DecodeOperation (infoString, i.opcode, op, i.info, & pc);\n\n                    m3log (code, \"%p | %20s  %s\", operationPC, i.info->name, infoString);\n                }\n                else\n                    m3log (code, \"%p | %p\", operationPC, op);\n\n        }\n\n        m3log (code, \"---------------------------------------------------------------------------------------\");\n\n        m3log (code, \"free-lines: %d\", i_codePage->info.numLines - i_codePage->info.lineIndex);\n}\n\n\nvoid  dump_type_stack  (IM3Compilation o)\n{\n    /* Reminders about how the stack works! :)\n     -- args & locals remain on the type stack for duration of the function. Denoted with a constant 'A' and 'L' in this dump.\n     -- the initial stack dumps originate from the CompileLocals () function, so these identifiers won't/can't be\n     applied until this compilation stage is finished\n     -- constants are not statically represented in the type stack (like args & constants) since they don't have/need\n     write counts\n\n     -- the number shown for static args and locals (value in wasmStack [i]) represents the write count for the variable\n\n     -- (does Wasm ever write to an arg? I dunno/don't remember.)\n     -- the number for the dynamic stack values represents the slot number.\n     -- if the slot index points to arg, local or constant it's denoted with a lowercase 'a', 'l' or 'c'\n\n     */\n\n    // for the assert at end of dump:\n    i32 regAllocated [2] = { (i32) IsRegisterAllocated (o, 0), (i32) IsRegisterAllocated (o, 1) };\n\n    // display whether r0 or fp0 is allocated. these should then also be reflected somewhere in the stack too.\n    d_m3Log(stack, \"\\n\");\n    d_m3Log(stack, \"        \");\n    printf (\"%s %s    \", regAllocated [0] ? \"(r0)\" : \"    \", regAllocated [1] ? \"(fp0)\" : \"     \");\n    printf(\"\\n\");\n\n    for (u32 p = 1; p <= 2; ++p)\n    {\n        d_m3Log(stack, \"        \");\n\n        for (u16 i = 0; i < o->stackIndex; ++i)\n        {\n            if (i > 0 and i == o->stackFirstDynamicIndex)\n                printf (\"#\");\n\n            if (i == o->block.blockStackIndex)\n                printf (\">\");\n\n            const char * type = c_waCompactTypes [o->typeStack [i]];\n\n            const char * location = \"\";\n\n            i32 slot = o->wasmStack [i];\n\n            if (IsRegisterSlotAlias (slot))\n            {\n                bool isFp = IsFpRegisterSlotAlias (slot);\n                location = isFp ? \"/f\" : \"/r\";\n\n                regAllocated [isFp]--;\n                slot = -1;\n            }\n            else\n            {\n                if (slot < o->slotFirstDynamicIndex)\n                {\n                    if (slot >= o->slotFirstConstIndex)\n                        location = \"c\";\n                    else if (slot >= o->function->numRetAndArgSlots)\n                        location = \"L\";\n                    else\n                        location = \"a\";\n                }\n            }\n\n            char item [100];\n\n            if (slot >= 0)\n                sprintf (item, \"%s%s%d\", type, location, slot);\n            else\n                sprintf (item, \"%s%s\", type, location);\n\n            if (p == 1)\n            {\n                size_t s = strlen (item);\n\n                sprintf (item, \"%d\", i);\n\n                while (strlen (item) < s)\n                    strcat (item, \" \");\n            }\n\n            printf (\"|%s \", item);\n\n        }\n        printf (\"\\n\");\n    }\n\n//    for (u32 r = 0; r < 2; ++r)\n//        d_m3Assert (regAllocated [r] == 0);         // reg allocation & stack out of sync\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    if (maxSlot > o->slotFirstDynamicIndex)\n    {\n        d_m3Log (stack, \"                      -\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"----\");\n\n        printf (\"\\n\");\n\n        d_m3Log (stack, \"                 slot |\");\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"%3d|\", i);\n\n        printf (\"\\n\");\n        d_m3Log (stack, \"                alloc |\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n        {\n            printf (\"%3d|\", o->m3Slots [i]);\n        }\n\n        printf (\"\\n\");\n    }\n    d_m3Log(stack, \"\\n\");\n}\n\n\nstatic const char *  GetOpcodeIndentionString  (i32 blockDepth)\n{\n    blockDepth += 1;\n\n    if (blockDepth < 0)\n        blockDepth = 0;\n\n    static const char * s_spaces = \".......................................................................................\";\n    const char * indent = s_spaces + strlen (s_spaces);\n    indent -= (blockDepth * 2);\n    if (indent < s_spaces)\n        indent = s_spaces;\n\n    return indent;\n}\n\n\nconst char *  get_indention_string  (IM3Compilation o)\n{\n    return GetOpcodeIndentionString (o->block.depth+4);\n}\n\n\nvoid  log_opcode  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    i32 depth = o->block.depth;\n    if (i_opcode == c_waOp_end or i_opcode == c_waOp_else)\n        depth--;\n\n    m3log (compile, \"%4d | 0x%02x  %s %s\", o->numOpcodes++, i_opcode, GetOpcodeIndentionString (depth), GetOpInfo(i_opcode)->name);\n}\n\n\nvoid  log_emit  (IM3Compilation o, IM3Operation i_operation)\n{\n    OpInfo i = find_operation_info (i_operation);\n\n    d_m3Log(emit, \"\");\n    if (i.info)\n    {\n        printf (\"%p: %s\\n\", GetPagePC (o->page),  i.info->name);\n    }\n    else printf (\"not found: %p\\n\", i_operation);\n}\n\n#endif // DEBUG\n\n\n# if d_m3EnableOpProfiling\n\ntypedef struct M3ProfilerSlot\n{\n    cstr_t      opName;\n    u64         hitCount;\n}\nM3ProfilerSlot;\n\nstatic M3ProfilerSlot s_opProfilerCounts [d_m3ProfilerSlotMask + 1] = {};\n\nvoid  ProfileHit  (cstr_t i_operationName)\n{\n    u64 ptr = (u64) i_operationName;\n\n    M3ProfilerSlot * slot = & s_opProfilerCounts [ptr & d_m3ProfilerSlotMask];\n\n    if (slot->opName)\n    {\n        if (slot->opName != i_operationName)\n        {\n            m3_Abort (\"profiler slot collision; increase d_m3ProfilerSlotMask\");\n        }\n    }\n\n    slot->opName = i_operationName;\n    slot->hitCount++;\n}\n\n\nvoid  m3_PrintProfilerInfo  ()\n{\n    M3ProfilerSlot dummy;\n    M3ProfilerSlot * maxSlot = & dummy;\n\n    do\n    {\n        maxSlot->hitCount = 0;\n\n        for (u32 i = 0; i <= d_m3ProfilerSlotMask; ++i)\n        {\n            M3ProfilerSlot * slot = & s_opProfilerCounts [i];\n\n            if (slot->opName)\n            {\n                if (slot->hitCount > maxSlot->hitCount)\n                    maxSlot = slot;\n            }\n        }\n\n        if (maxSlot->opName)\n        {\n            fprintf (stderr, \"%13llu  %s\\n\", maxSlot->hitCount, maxSlot->opName);\n            maxSlot->opName = NULL;\n        }\n    }\n    while (maxSlot->hitCount);\n}\n\n# else\n\nvoid  m3_PrintProfilerInfo  () {}\n\n# endif\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_code.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_code.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_code.h\n//\n//  Created by Steven Massey on 4/19/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n//d_m3BeginExternC\n\ntypedef struct M3CodePage;\nstruct M3CodeMappingPage;\ntypedef struct M3CodePageHeader\n{\n    struct M3CodePage *           next;\n\n    u32                           lineIndex;\n    u32                           numLines;\n    u32                           sequence;       // this is just used for debugging; could be removed\n    u32                           usageCount;\n\n# if d_m3RecordBacktraces\n    struct M3CodeMappingPage *    mapping;\n# endif // d_m3RecordBacktraces\n}\nM3CodePageHeader;\n\ntypedef struct M3CodePage\n{\n    M3CodePageHeader        info;\n    code_t                  code                [1];\n}\nM3CodePage;\n\ntypedef M3CodePage *    IM3CodePage;\n\nIM3CodePage             NewCodePage             (IM3Runtime i_runtime, u32 i_minNumLines);\n\nvoid                    FreeCodePages           (IM3CodePage * io_list);\n\nu32                     NumFreeLines            (IM3CodePage i_page);\npc_t                    GetPageStartPC          (IM3CodePage i_page);\npc_t                    GetPagePC               (IM3CodePage i_page);\nvoid                    EmitWord_impl           (IM3CodePage i_page, void* i_word);\nvoid                    EmitWord32              (IM3CodePage i_page, u32 i_word);\nvoid                    EmitWord64              (IM3CodePage i_page, u64 i_word);\n# if d_m3RecordBacktraces\nvoid                    EmitMappingEntry        (IM3CodePage i_page, u32 i_moduleOffset);\n# endif // d_m3RecordBacktraces\n\nvoid                    PushCodePage            (IM3CodePage * io_list, IM3CodePage i_codePage);\nIM3CodePage             PopCodePage             (IM3CodePage * io_list);\n\nIM3CodePage             GetEndCodePage          (IM3CodePage i_list); // i_list = NULL is valid\nu32                     CountCodePages          (IM3CodePage i_list); // i_list = NULL is valid\n\n# if d_m3RecordBacktraces\nbool                    ContainsPC              (IM3CodePage i_page, pc_t i_pc);\nbool                    MapPCToOffset           (IM3CodePage i_page, pc_t i_pc, u32 * o_moduleOffset);\n# endif // d_m3RecordBacktraces\n\n# ifdef DEBUG\nvoid                    dump_code_page            (IM3CodePage i_codePage, pc_t i_startPC);\n# endif\n\n#define EmitWord(page, val) EmitWord_impl(page, (void*)(val))\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\n# if d_m3RecordBacktraces\n\ntypedef struct M3CodeMapEntry\n{\n    u32          pcOffset;\n    u32          moduleOffset;\n}\nM3CodeMapEntry;\n\ntypedef struct M3CodeMappingPage\n{\n    pc_t              basePC;\n    u32               size;\n    u32               capacity;\n    M3CodeMapEntry    entries     [];\n}\nM3CodeMappingPage;\n\n# endif // d_m3RecordBacktraces\n\n//d_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_parse.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_parse.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_parse.c\n//\n//  Created by Steven Massey on 4/19/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include \"m3_parse.h\"\n\nstatic const bool WASM_DEBUG_PARSE = false;\n\nM3Result  ParseType_Table  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    return result;\n}\n\n\nM3Result  ParseType_Memory  (M3MemoryInfo * o_memory, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u8 flag;\n\n_   (ReadLEB_u7 (& flag, io_bytes, i_end));                   // really a u1\n_   (ReadLEB_u32 (& o_memory->initPages, io_bytes, i_end));\n\n    o_memory->maxPages = 0;\n    if (flag & (1u << 0))\n_       (ReadLEB_u32 (& o_memory->maxPages, io_bytes, i_end));\n\n    o_memory->pageSize = 0;\n    if (flag & (1u << 3)) {\n        u32 logPageSize;\n_       (ReadLEB_u32 (& logPageSize, io_bytes, i_end));\n        o_memory->pageSize = 1u << logPageSize;\n    }\n\n    _catch: return result;\n}\n\n\nM3Result  ParseSection_Type  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    IM3FuncType ftype = NULL;\n\n_try {\n    u32 numTypes;\n_   (ReadLEB_u32 (& numTypes, & i_bytes, i_end));                                   m3log (parse, \"** Type [%d]\", numTypes);\n\n    _throwif(\"too many types\", numTypes > d_m3MaxSaneTypesCount);\n\n    if (numTypes)\n    {\n        // table of IM3FuncType (that point to the actual M3FuncType struct in the Environment)\n        io_module->funcTypes = m3_Int_AllocArray (IM3FuncType, numTypes);\n        _throwifnull (io_module->funcTypes);\n        io_module->numFuncTypes = numTypes;\n\n        for (u32 i = 0; i < numTypes; ++i)\n        {\n            i8 form;\n_           (ReadLEB_i7 (& form, & i_bytes, i_end));\n            _throwif (m3Err_wasmMalformed, form != -32); // for Wasm MVP\n\n            u32 numArgs;\n_           (ReadLEB_u32 (& numArgs, & i_bytes, i_end));\n\n            _throwif (m3Err_tooManyArgsRets, numArgs > d_m3MaxSaneFunctionArgRetCount);\n#if defined(M3_COMPILER_MSVC)\n            u8 argTypes [d_m3MaxSaneFunctionArgRetCount];\n#else\n            u8 argTypes[numArgs+1]; // make ubsan happy\n#endif\n            for (u32 a = 0; a < numArgs; ++a)\n            {\n                i8 wasmType;\n                u8 argType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& argType, wasmType));\n\n                argTypes[a] = argType;\n            }\n\n            u32 numRets;\n_           (ReadLEB_u32 (& numRets, & i_bytes, i_end));\n            _throwif (m3Err_tooManyArgsRets, (u64)(numRets) + numArgs > d_m3MaxSaneFunctionArgRetCount);\n\n_           (AllocFuncType (& ftype, numRets + numArgs));\n            ftype->numArgs = numArgs;\n            ftype->numRets = numRets;\n\n            for (u32 r = 0; r < numRets; ++r)\n            {\n                i8 wasmType;\n                u8 retType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& retType, wasmType));\n\n                ftype->types[r] = retType;\n            }\n            memcpy (ftype->types + numRets, argTypes, numArgs);                                 m3log (parse, \"    type %2d: %s\", i, SPrintFuncTypeSignature (ftype));\n\n            Environment_AddFuncType (io_module->environment, & ftype);\n            io_module->funcTypes [i] = ftype;\n            ftype = NULL; // ownership transferred to environment\n        }\n    }\n\n} _catch:\n\n    if (result)\n    {\n        m3_Int_Free (ftype);\n        // FIX: M3FuncTypes in the table are leaked\n        m3_Int_Free (io_module->funcTypes);\n        io_module->numFuncTypes = 0;\n    }\n\n    return result;\n}\n\n\nM3Result  ParseSection_Function  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u32 numFunctions;\n_   (ReadLEB_u32 (& numFunctions, & i_bytes, i_end));                               m3log (parse, \"** Function [%d]\", numFunctions);\n\n    _throwif(\"too many functions\", numFunctions > d_m3MaxSaneFunctionsCount);\n\n_   (Module_PreallocFunctions(io_module, io_module->numFunctions + numFunctions));\n\n    for (u32 i = 0; i < numFunctions; ++i)\n    {\n        u32 funcTypeIndex;\n_       (ReadLEB_u32 (& funcTypeIndex, & i_bytes, i_end));\n\n_       (Module_AddFunction (io_module, funcTypeIndex, NULL /* import info */));\n    }\n\n    _catch: return result;\n}\n\n\nstatic const bool WASM_DEBUG_PARSE_SECTION = false;\nM3Result  ParseSection_Import  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    M3ImportInfo import = { NULL, NULL }, clearImport = { NULL, NULL };\n\n    u32 numImports;\n_   (ReadLEB_u32 (& numImports, & i_bytes, i_end));                                 m3log (parse, \"** Import [%d]\", numImports);\n\n    _throwif(\"too many imports\", numImports > d_m3MaxSaneImportsCount);\n\n    // Most imports are functions, so we won't waste much space anyway (if any)\n_   (Module_PreallocFunctions(io_module, numImports));\n\n    for (u32 i = 0; i < numImports; ++i)\n    {\n        u8 importKind;\n\n_       (Read_utf8 (& import.moduleUtf8, & i_bytes, i_end));\n_       (Read_utf8 (& import.fieldUtf8, & i_bytes, i_end));\n_       (Read_u8 (& importKind, & i_bytes, i_end));                                 m3log (parse, \"    kind: %d '%s.%s' \",\n                                                                                                (u32) importKind, import.moduleUtf8, import.fieldUtf8);\n        switch (importKind)\n        {\n            case d_externalKind_function:\n            {\n                u32 typeIndex;\n_               (ReadLEB_u32 (& typeIndex, & i_bytes, i_end))\n\n_               (Module_AddFunction (io_module, typeIndex, & import))\n                import = clearImport;\n\n                io_module->numFuncImports++;\n            }\n            break;\n\n            case d_externalKind_table:\n//                  result = ParseType_Table (& i_bytes, i_end);\n                break;\n\n            case d_externalKind_memory:\n            {\n_               (ParseType_Memory (& io_module->memoryInfo, & i_bytes, i_end));\n                io_module->memoryImported = true;\n                io_module->memoryImport = import;\n                import = clearImport;\n            }\n            break;\n\n            case d_externalKind_global:\n            {\n                i8 waType;\n                u8 type, isMutable;\n\n_               (ReadLEB_i7 (& waType, & i_bytes, i_end));\n_               (NormalizeType (& type, waType));\n_               (ReadLEB_u7 (& isMutable, & i_bytes, i_end));                     m3log (parse, \"     global: %s mutable=%d\", c_waTypes [type], (u32) isMutable);\n\n                IM3Global global;\n_               (Module_AddGlobal (io_module, & global, type, isMutable, true /* isImport */));\n                global->import = import;\n                import = clearImport;\n            }\n            break;\n\n            default:\n                _throw (m3Err_wasmMalformed);\n        }\n\n        FreeImportInfo (& import);\n    }\n\n    _catch:\n\n    FreeImportInfo (& import);\n\n    return result;\n}\n\n\nM3Result  ParseSection_Export  (IM3Module io_module, bytes_t i_bytes, cbytes_t  i_end)\n{\n    M3Result result = m3Err_none;\n    const char * utf8 = NULL;\n\n    u32 numExports;\n_   (ReadLEB_u32 (& numExports, & i_bytes, i_end));                                 m3log (parse, \"** Export [%d]\", numExports);\n\n    _throwif(\"too many exports\", numExports > d_m3MaxSaneExportsCount);\n\n    for (u32 i = 0; i < numExports; ++i)\n    {\n        u8 exportKind;\n        u32 index;\n\n_       (Read_utf8 (& utf8, & i_bytes, i_end));\n_       (Read_u8 (& exportKind, & i_bytes, i_end));\n_       (ReadLEB_u32 (& index, & i_bytes, i_end));                                  m3log (parse, \"    index: %3d; kind: %d; export: '%s'; \", index, (u32) exportKind, utf8);\n\n        if (exportKind == d_externalKind_function)\n        {\n            _throwif(m3Err_wasmMalformed, index >= io_module->numFunctions);\n            IM3Function func = &(io_module->functions [index]);\n            if (func->numNames < d_m3MaxDuplicateFunctionImpl)\n            {\n                func->names[func->numNames++] = utf8;\n                func->export_name = utf8;\n                utf8 = NULL; // ownership transferred to M3Function\n            }\n        }\n        else if (exportKind == d_externalKind_global)\n        {\n            _throwif(m3Err_wasmMalformed, index >= io_module->numGlobals);\n            IM3Global global = &(io_module->globals [index]);\n            m3_Int_Free (global->name);\n            global->name = utf8;\n            utf8 = NULL; // ownership transferred to M3Global\n        }\n        else if (exportKind == d_externalKind_memory)\n        {\n            m3_Int_Free (io_module->memoryExportName);\n            io_module->memoryExportName = utf8;\n            utf8 = NULL; // ownership transferred to M3Module\n        }\n        else if (exportKind == d_externalKind_table)\n        {\n            m3_Int_Free (io_module->table0ExportName);\n            io_module->table0ExportName = utf8;\n            utf8 = NULL; // ownership transferred to M3Module\n        }\n\n        m3_Int_Free (utf8);\n    }\n\n_catch:\n    m3_Int_Free (utf8);\n    return result;\n}\n\n\nM3Result  ParseSection_Start  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u32 startFuncIndex;\n_   (ReadLEB_u32 (& startFuncIndex, & i_bytes, i_end));                               m3log (parse, \"** Start Function: %d\", startFuncIndex);\n\n    if (startFuncIndex < io_module->numFunctions)\n    {\n        io_module->startFunction = startFuncIndex;\n    }\n    else result = \"start function index out of bounds\";\n\n    _catch: return result;\n}\n\n\nM3Result  Parse_InitExpr  (M3Module * io_module, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // this doesn't generate code pages. just walks the wasm bytecode to find the end\n\n#if defined(d_m3PreferStaticAlloc)\n    static M3Compilation compilation;\n#else\n    M3Compilation compilation;\n#endif\n    compilation = (M3Compilation){ .runtime = NULL, .module = io_module, .wasm = * io_bytes, .wasmEnd = i_end };\n\n    result = CompileBlockStatements (& compilation);\n\n    * io_bytes = compilation.wasm;\n\n    return result;\n}\n\n\nM3Result  ParseSection_Element  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u32 numSegments;\n_   (ReadLEB_u32 (& numSegments, & i_bytes, i_end));                         m3log (parse, \"** Element [%d]\", numSegments);\n\n    _throwif (\"too many element segments\", numSegments > d_m3MaxSaneElementSegments);\n\n    io_module->elementSection = i_bytes;\n    io_module->elementSectionEnd = i_end;\n    io_module->numElementSegments = numSegments;\n\n    _catch: return result;\n}\n\n\nM3Result  ParseSection_Code  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result;\n\n    u32 numFunctions;\n_   (ReadLEB_u32 (& numFunctions, & i_bytes, i_end));                               m3log (parse, \"** Code [%d]\", numFunctions);\n\n    if (numFunctions != io_module->numFunctions - io_module->numFuncImports)\n    {\n        _throw (\"mismatched function count in code section\");\n    }\n\n    for (u32 f = 0; f < numFunctions; ++f)\n    {\n        const u8 * start = i_bytes;\n\n        u32 size;\n_       (ReadLEB_u32 (& size, & i_bytes, i_end));\n\n        if (size)\n        {\n            const u8 * ptr = i_bytes;\n            i_bytes += size;\n\n            if (i_bytes <= i_end)\n            {\n                /*\n                u32 numLocalBlocks;\n_               (ReadLEB_u32 (& numLocalBlocks, & ptr, i_end));                                      m3log (parse, \"    code size: %-4d\", size);\n\n                u32 numLocals = 0;\n\n                for (u32 l = 0; l < numLocalBlocks; ++l)\n                {\n                    u32 varCount;\n                    i8 wasmType;\n                    u8 normalType;\n\n_                   (ReadLEB_u32 (& varCount, & ptr, i_end));\n_                   (ReadLEB_i7 (& wasmType, & ptr, i_end));\n_                   (NormalizeType (& normalType, wasmType));\n\n                    numLocals += varCount;                                                      m3log (parse, \"      %2d locals; type: '%s'\", varCount, c_waTypes [normalType]);\n                }\n                 */\n\n                IM3Function func = Module_GetFunction (io_module, f + io_module->numFuncImports);\n\n                func->module = io_module;\n                func->wasm = start;\n                func->wasmEnd = i_bytes;\n                //func->ownsWasmCode = io_module->hasWasmCodeCopy;\n//                func->numLocals = numLocals;\n            }\n            else _throw (m3Err_wasmSectionOverrun);\n        }\n    }\n\n    _catch:\n\n    if (not result and i_bytes != i_end)\n        result = m3Err_wasmSectionUnderrun;\n\n    return result;\n}\n\n\nM3Result  ParseSection_Data  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u32 numDataSegments;\n_   (ReadLEB_u32 (& numDataSegments, & i_bytes, i_end));                            m3log (parse, \"** Data [%d]\", numDataSegments);\n\n    _throwif(\"too many data segments\", numDataSegments > d_m3MaxSaneDataSegments);\n\n    io_module->dataSegments = m3_Int_AllocArray (M3DataSegment, numDataSegments);\n    _throwifnull(io_module->dataSegments);\n    io_module->numDataSegments = numDataSegments;\n\n    for (u32 i = 0; i < numDataSegments; ++i)\n    {\n        M3DataSegment * segment = & io_module->dataSegments [i];\n\n_       (ReadLEB_u32 (& segment->memoryRegion, & i_bytes, i_end));\n\n        segment->initExpr = i_bytes;\n_       (Parse_InitExpr (io_module, & i_bytes, i_end));\n        segment->initExprSize = (u32) (i_bytes - segment->initExpr);\n\n        _throwif (m3Err_wasmMissingInitExpr, segment->initExprSize <= 1);\n\n_       (ReadLEB_u32 (& segment->size, & i_bytes, i_end));\n        segment->data = i_bytes;                                                    m3log (parse, \"    segment [%u]  memory: %u;  expr-size: %d;  size: %d\",\n                                                                                       i, segment->memoryRegion, segment->initExprSize, segment->size);\n        i_bytes += segment->size;\n\n        _throwif(\"data segment underflow\", i_bytes > i_end);\n    }\n\n    _catch:\n\n    return result;\n}\n\n\nM3Result  ParseSection_Memory  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // TODO: MVP; assert no memory imported\n\n    u32 numMemories;\n_   (ReadLEB_u32 (& numMemories, & i_bytes, i_end));                             m3log (parse, \"** Memory [%d]\", numMemories);\n\n    _throwif (m3Err_tooManyMemorySections, numMemories != 1);\n\n    ParseType_Memory (& io_module->memoryInfo, & i_bytes, i_end);\n\n    _catch: return result;\n}\n\n\nM3Result  ParseSection_Global  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    u32 numGlobals;\n_   (ReadLEB_u32 (& numGlobals, & i_bytes, i_end));                                 m3log (parse, \"** Global [%d]\", numGlobals);\n\n    _throwif(\"too many globals\", numGlobals > d_m3MaxSaneGlobalsCount);\n\n    for (u32 i = 0; i < numGlobals; ++i)\n    {\n        i8 waType;\n        u8 type, isMutable;\n\n_       (ReadLEB_i7 (& waType, & i_bytes, i_end));\n_       (NormalizeType (& type, waType));\n_       (ReadLEB_u7 (& isMutable, & i_bytes, i_end));                                 m3log (parse, \"    global: [%d] %s mutable: %d\", i, c_waTypes [type],   (u32) isMutable);\n\n        IM3Global global;\n_       (Module_AddGlobal (io_module, & global, type, isMutable, false /* isImport */));\n\n        global->initExpr = i_bytes;\n_       (Parse_InitExpr (io_module, & i_bytes, i_end));\n        global->initExprSize = (u32) (i_bytes - global->initExpr);\n\n        _throwif (m3Err_wasmMissingInitExpr, global->initExprSize <= 1);\n    }\n\n    _catch: return result;\n}\n\n\nM3Result  ParseSection_Name  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result;\n\n    cstr_t name;\n\n    while (i_bytes < i_end)\n    {\n        u8 nameType;\n        u32 payloadLength;\n\n_       (ReadLEB_u7 (& nameType, & i_bytes, i_end));\n_       (ReadLEB_u32 (& payloadLength, & i_bytes, i_end));\n\n        bytes_t start = i_bytes;\n        if (nameType == 1)\n        {\n            u32 numNames;\n_           (ReadLEB_u32 (& numNames, & i_bytes, i_end));\n\n            _throwif(\"too many names\", numNames > d_m3MaxSaneFunctionsCount);\n\n            for (u32 i = 0; i < numNames; ++i)\n            {\n                u32 index;\n_               (ReadLEB_u32 (& index, & i_bytes, i_end));\n_               (Read_utf8 (& name, & i_bytes, i_end));\n\n                if (index < io_module->numFunctions)\n                {\n                    IM3Function func = &(io_module->functions [index]);\n                    if (func->numNames == 0)\n                    {\n                        func->names[0] = name;        m3log (parse, \"    naming function%5d:  %s\", index, name);\n                        func->numNames = 1;\n                        name = NULL; // transfer ownership\n                    }\n//                          else m3log (parse, \"prenamed: %s\", io_module->functions [index].name);\n                }\n\n                m3_Int_Free (name);\n            }\n        }\n\n        i_bytes = start + payloadLength;\n    }\n\n    _catch: return result;\n}\n\n\nM3Result  ParseSection_Custom  (M3Module * io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result;\n\n    cstr_t name;\n_   (Read_utf8 (& name, & i_bytes, i_end));\n                                                                                    m3log (parse, \"** Custom: '%s'\", name);\n    if (strcmp (name, \"name\") == 0) {\n_       (ParseSection_Name(io_module, i_bytes, i_end));\n    } else if (io_module->environment->customSectionHandler) {\n_       (io_module->environment->customSectionHandler(io_module, name, i_bytes, i_end));\n    }\n\n    m3_Int_Free (name);\n\n    _catch: return result;\n}\n\n\nstatic const bool WASM_DEBUG_PARSEMODULESECTION = false;\nM3Result  ParseModuleSection  (M3Module * o_module, u8 i_sectionType, bytes_t i_bytes, u32 i_numBytes)\n{\n    if(WASM_DEBUG_PARSEMODULESECTION){\n        ESP_LOGI(\"WASM3\", \"ParseModuleSection called\");\n        ESP_LOGI(\"WASM3\", \"ParseModuleSection: Section Type: %d\", i_sectionType);\n        ESP_LOGI(\"WASM3\", \"ParseModuleSection: Bytes: %lu\", i_numBytes);\n    }\n\n    M3Result result = m3Err_none;\n\n    typedef M3Result (* M3Parser) (M3Module *, bytes_t, cbytes_t);\n\n    static M3Parser s_parsers [] =\n    {\n        ParseSection_Custom,    // 0\n        ParseSection_Type,      // 1\n        ParseSection_Import,    // 2\n        ParseSection_Function,  // 3\n        NULL,                   // 4: TODO Table\n        ParseSection_Memory,    // 5\n        ParseSection_Global,    // 6\n        ParseSection_Export,    // 7\n        ParseSection_Start,     // 8\n        ParseSection_Element,   // 9\n        ParseSection_Code,      // 10\n        ParseSection_Data,      // 11\n        NULL,                   // 12: TODO DataCount\n    };\n\n    M3Parser parser = NULL;\n\n    if (i_sectionType <= 12)\n        parser = s_parsers [i_sectionType];\n\n    if (parser)\n    {\n        cbytes_t end = i_bytes + i_numBytes;\n        result = parser (o_module, i_bytes, end);\n    }\n    else\n    {\n        m3log (parse, \" skipped section type: %d\", (u32) i_sectionType);\n    }\n\n    return result;\n}\n\nstatic const bool WASM_DEBUG_PARSE_MODULE = false;\nM3Result  m3_ParseModule  (IM3Environment i_environment, IM3Module * o_module, cbytes_t i_bytes, u32 i_numBytes)\n{\n    IM3Module module;                                                               m3log (parse, \"load module: %d bytes\", i_numBytes);\n_try {\n    if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule start\");\n    module = m3_Int_AllocStruct(M3Module);\n    if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule: module allocated\");\n    _throwifnull (module);\n    module->name = \".unnamed\";                                                      m3log (parse, \"load module: %d bytes\", i_numBytes);\n    module->startFunction = -1;\n    //module->hasWasmCodeCopy = false;\n    module->environment = i_environment;\n\n    const u8 * pos = i_bytes;\n    const u8 * end = pos + i_numBytes;\n\n    module->wasmStart = pos;\n    module->wasmEnd = end;\n\n    u32 magic, version;\n_   (Read_u32 (& magic, & pos, end));\n_   (Read_u32 (& version, & pos, end));\n\n    _throwif (m3Err_wasmMalformed, magic != 0x6d736100);\n    _throwif (m3Err_incompatibleWasmVersion, version != 1);\n\n    static const u8 sectionsOrder[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 10, 11, 0 }; // 0 is a placeholder\n    u8 expectedSection = 0;\n\n    if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule: cycling...\");\n    while (pos < end)\n    {\n        if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule: cycle: ReadLEB_u7\");\n        u8 section;\n_       (ReadLEB_u7 (& section, & pos, end));\n\n        if (section != 0) {\n            // Ensure sections appear only once and in order\n            while (sectionsOrder[expectedSection++] != section) {\n                _throwif(m3Err_misorderedWasmSection, expectedSection >= 12);\n            }\n        }\n\n        if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule: cycle: ReadLEB_u32\");\n        u32 sectionLength;\n_       (ReadLEB_u32 (& sectionLength, & pos, end));\n        _throwif(m3Err_wasmMalformed, pos + sectionLength > end);\n\n        if(WASM_DEBUG_PARSE_MODULE) ESP_LOGI(\"WASM3\", \"m3_ParseModule: cycle: ParseModuleSection\");\n_       (ParseModuleSection (module, section, pos, sectionLength));\n\n        pos += sectionLength;\n    }\n\n} _catch:\n\n    if (result)\n    {\n        if(WASM_DEBUG_PARSE){\n            const char* error_type;\n            if (result == m3Err_wasmMalformed) {\n                error_type = \"WASM malformato\";\n            } else if (result == m3Err_incompatibleWasmVersion) {\n                error_type = \"Versione WASM incompatibile\";\n            } else if (result == m3Err_misorderedWasmSection) {\n                error_type = \"Sezioni WASM in ordine errato\";\n            } else {\n                error_type = \"Errore sconosciuto\";\n            }\n            \n            ESP_LOGE(\"WASM3\", \"Errore nel parsing del modulo: %s (%s)\", result, error_type);\n        }\n\n        m3_FreeModule (module);\n        module = NULL;\n    }\n\n    * o_module = module;\n\n    return result;\n}\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/esp_try.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/esp_try.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#ifndef m3_esp_try_h\n#define m3_esp_try_h\n\n#include <setjmp.h>\n#include \"esp_err.h\"\n#include \"esp_log.h\"\n\n#define TC_TAG \"TC_WASM3\"\n\n// Variabile globale per salvare l'ultimo errore\nstatic esp_err_t last_error;\n\n// Definizione delle macro TRY-CATCH\n#define TRY do { jmp_buf buf; if (!setjmp(buf)) {\n#define CATCH } else {\n#define END_TRY } } while (0)\n#define THROW longjmp(buf, 1)\n\n// Macro per controllare errori e lanciare un'eccezione\n#define ESP_TRY_CHECK(x) do { \\\n    esp_err_t err_rc_ = (x); \\\n    if (err_rc_ != ESP_OK) { \\\n        last_error = err_rc_; /* Salva l'errore globale */ \\\n        THROW; \\\n    } \\\n} while (0)\n\nvoid backtrace(){\n    esp_backtrace_print(100);\n}\n\n// Esempio di funzione che restituisce un errore\nesp_err_t faulty_function() {\n    return ESP_FAIL; // Simula un errore\n}\n\nvoid example_function_trycatch() {\n    TRY {\n        ESP_LOGI(TC_TAG, \"Inizio del blocco TRY\");\n        ESP_TRY_CHECK(faulty_function()); // Controllo e gestione errori\n        ESP_LOGI(TC_TAG, \"Questo messaggio non verrà mostrato se c'è un errore.\");\n    }\n    CATCH {\n        // Accesso all'ultimo errore e alla sua stringa\n        ESP_LOGE(TC_TAG, \"Eccezione catturata! Errore: %s (%d)\", esp_err_to_name(last_error), last_error);\n    }\n    END_TRY;\n\n    ESP_LOGI(TC_TAG, \"Fine della funzione.\");\n}\n\n#endif", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_math_utils.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_math_utils.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_math_utils.h\n//\n//  Created by Volodymyr Shymanksyy on 8/10/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#ifndef m3_math_utils_h\n#define m3_math_utils_h\n\n#include <limits.h>\n#include <math.h>\n\n#include \"m3_core.h\"\n//#include \"m3_exception.h\"\n\n#if defined(M3_COMPILER_MSVC)\n\n#define __builtin_popcount    __popcnt\n\nstatic inline\nint __builtin_ctz(uint32_t x) {\n    unsigned long ret;\n    _BitScanForward(&ret, x);\n    return (int)ret;\n}\n\nstatic inline\nint __builtin_clz(uint32_t x) {\n    unsigned long ret;\n    _BitScanReverse(&ret, x);\n    return (int)(31 ^ ret);\n}\n\n\n\n#ifdef _WIN64\n\n#define __builtin_popcountll  __popcnt64\n\nstatic inline\nint __builtin_ctzll(uint64_t value) {\n    unsigned long ret;\n     _BitScanForward64(&ret, value);\n    return (int)ret;\n}\n\nstatic inline\nint __builtin_clzll(uint64_t value) {\n    unsigned long ret;\n    _BitScanReverse64(&ret, value);\n    return (int)(63 ^ ret);\n}\n\n#else // _WIN64\n\n#define __builtin_popcountll(x)  (__popcnt((x) & 0xFFFFFFFF) + __popcnt((x) >> 32))\n\nstatic inline\nint __builtin_ctzll(uint64_t value) {\n    //if (value == 0) return 64; // Note: ctz(0) result is undefined anyway\n    uint32_t msh = (uint32_t)(value >> 32);\n    uint32_t lsh = (uint32_t)(value & 0xFFFFFFFF);\n    if (lsh != 0) return __builtin_ctz(lsh);\n    return 32 + __builtin_ctz(msh);\n}\n\nstatic inline\nint __builtin_clzll(uint64_t value) {\n    //if (value == 0) return 64; // Note: clz(0) result is undefined anyway\n    uint32_t msh = (uint32_t)(value >> 32);\n    uint32_t lsh = (uint32_t)(value & 0xFFFFFFFF);\n    if (msh != 0) return __builtin_clz(msh);\n    return 32 + __builtin_clz(lsh);\n}\n\n#endif // _WIN64\n\n#endif // defined(M3_COMPILER_MSVC)\n\n\n// TODO: not sure why, signbit is actually defined in math.h\n#if (defined(ESP8266) || defined(ESP32)) && !defined(signbit)\n    #define signbit(__x) \\\n            ((sizeof(__x) == sizeof(float))  ?  __signbitf(__x) : __signbitd(__x))\n#endif\n\n#if defined(__AVR__)\n\nstatic inline\nfloat rintf( float arg ) {\n  union { float f; uint32_t i; } u;\n  u.f = arg;\n  uint32_t ux = u.i & 0x7FFFFFFF;\n  if (M3_UNLIKELY(ux == 0 || ux > 0x5A000000)) {\n    return arg;\n  }\n  return (float)lrint(arg);\n}\n\nstatic inline\ndouble rint( double arg ) {\n  union { double f; uint32_t i[2]; } u;\n  u.f = arg;\n  uint32_t ux = u.i[1] & 0x7FFFFFFF;\n  if (M3_UNLIKELY((ux == 0 && u.i[0] == 0) || ux > 0x433FFFFF)) {\n    return arg;\n  }\n  return (double)lrint(arg);\n}\n\n//TODO\nstatic inline\nuint64_t strtoull(const char* str, char** endptr, int base) {\n  return 0;\n}\n\n#endif\n\n/*\n * Rotr, Rotl\n */\n\nstatic inline\nu32 rotl32(u32 n, unsigned c) {\n    const unsigned mask = CHAR_BIT * sizeof(n) - 1;\n    c &= mask & 31;\n    return (n << c) | (n >> ((-c) & mask));\n}\n\nstatic inline\nu32 rotr32(u32 n, unsigned c) {\n    const unsigned mask = CHAR_BIT * sizeof(n) - 1;\n    c &= mask & 31;\n    return (n >> c) | (n << ((-c) & mask));\n}\n\nstatic inline\nu64 rotl64(u64 n, unsigned c) {\n    const unsigned mask = CHAR_BIT * sizeof(n) - 1;\n    c &= mask & 63;\n    return (n << c) | (n >> ((-c) & mask));\n}\n\nstatic inline\nu64 rotr64(u64 n, unsigned c) {\n    const unsigned mask = CHAR_BIT * sizeof(n) - 1;\n    c &= mask & 63;\n    return (n >> c) | (n << ((-c) & mask));\n}\n\n/*\n * Integer Div, Rem\n */\n\n#define OP_DIV_U(RES, A, B)                                      \\\n    if (M3_UNLIKELY(B == 0)) newTrap (m3Err_trapDivisionByZero);    \\\n    RES = A / B;\n\n#define OP_REM_U(RES, A, B)                                      \\\n    if (M3_UNLIKELY(B == 0)) newTrap (m3Err_trapDivisionByZero);    \\\n    RES = A % B;\n\n// 2's complement detection\n#if (INT_MIN != -INT_MAX)\n\n    #define OP_DIV_S(RES, A, B, TYPE_MIN)                         \\\n        if (M3_UNLIKELY(B == 0)) newTrap (m3Err_trapDivisionByZero); \\\n        if (M3_UNLIKELY(B == -1 and A == TYPE_MIN)) {                \\\n            newTrap (m3Err_trapIntegerOverflow);                  \\\n        }                                                         \\\n        RES = A / B;\n\n    #define OP_REM_S(RES, A, B, TYPE_MIN)                         \\\n        if (M3_UNLIKELY(B == 0)) newTrap (m3Err_trapDivisionByZero); \\\n        if (M3_UNLIKELY(B == -1 and A == TYPE_MIN)) RES = 0;         \\\n        else RES = A % B;\n\n#else\n\n    #define OP_DIV_S(RES, A, B, TYPE_MIN) OP_DIV_U(RES, A, B)\n    #define OP_REM_S(RES, A, B, TYPE_MIN) OP_REM_U(RES, A, B)\n\n#endif\n\n/*\n * Trunc\n */\n\n#define OP_TRUNC(RES, A, TYPE, RMIN, RMAX) \\\n    if (M3_UNLIKELY(isnan(A))) { \\\n        newTrap (m3Err_trapIntegerConversion); \\\n    } \\\n    if (M3_UNLIKELY(A <= RMIN or A >= RMAX)) { \\\n        newTrap (m3Err_trapIntegerOverflow); \\\n    } \\\n    RES = (TYPE)A;\n\n\n#define OP_I32_TRUNC_F32(RES, A)    OP_TRUNC(RES, A, i32, -2147483904.0f, 2147483648.0f)\n#define OP_U32_TRUNC_F32(RES, A)    OP_TRUNC(RES, A, u32,          -1.0f, 4294967296.0f)\n#define OP_I32_TRUNC_F64(RES, A)    OP_TRUNC(RES, A, i32, -2147483649.0 , 2147483648.0 )\n#define OP_U32_TRUNC_F64(RES, A)    OP_TRUNC(RES, A, u32,          -1.0 , 4294967296.0 )\n\n#define OP_I64_TRUNC_F32(RES, A)    OP_TRUNC(RES, A, i64, -9223373136366403584.0f,  9223372036854775808.0f)\n#define OP_U64_TRUNC_F32(RES, A)    OP_TRUNC(RES, A, u64,                   -1.0f, 18446744073709551616.0f)\n#define OP_I64_TRUNC_F64(RES, A)    OP_TRUNC(RES, A, i64, -9223372036854777856.0 ,  9223372036854775808.0 )\n#define OP_U64_TRUNC_F64(RES, A)    OP_TRUNC(RES, A, u64,                   -1.0 , 18446744073709551616.0 )\n\n#define OP_TRUNC_SAT(RES, A, TYPE, RMIN, RMAX, IMIN, IMAX) \\\n    if (M3_UNLIKELY(isnan(A))) { \\\n        RES = 0; \\\n    } else if (M3_UNLIKELY(A <= RMIN)) { \\\n        RES = IMIN; \\\n    } else if (M3_UNLIKELY(A >= RMAX)) { \\\n        RES = IMAX; \\\n    } else { \\\n        RES = (TYPE)A; \\\n    }\n\n#define OP_I32_TRUNC_SAT_F32(RES, A)    OP_TRUNC_SAT(RES, A, i32, -2147483904.0f, 2147483648.0f,   INT32_MIN,  INT32_MAX)\n#define OP_U32_TRUNC_SAT_F32(RES, A)    OP_TRUNC_SAT(RES, A, u32,          -1.0f, 4294967296.0f,         0UL, UINT32_MAX)\n#define OP_I32_TRUNC_SAT_F64(RES, A)    OP_TRUNC_SAT(RES, A, i32, -2147483649.0 , 2147483648.0,    INT32_MIN,  INT32_MAX)\n#define OP_U32_TRUNC_SAT_F64(RES, A)    OP_TRUNC_SAT(RES, A, u32,          -1.0 , 4294967296.0,          0UL, UINT32_MAX)\n\n#define OP_I64_TRUNC_SAT_F32(RES, A)    OP_TRUNC_SAT(RES, A, i64, -9223373136366403584.0f,  9223372036854775808.0f, INT64_MIN,  INT64_MAX)\n#define OP_U64_TRUNC_SAT_F32(RES, A)    OP_TRUNC_SAT(RES, A, u64,                   -1.0f, 18446744073709551616.0f,      0ULL, UINT64_MAX)\n#define OP_I64_TRUNC_SAT_F64(RES, A)    OP_TRUNC_SAT(RES, A, i64, -9223372036854777856.0 ,  9223372036854775808.0,  INT64_MIN,  INT64_MAX)\n#define OP_U64_TRUNC_SAT_F64(RES, A)    OP_TRUNC_SAT(RES, A, u64,                   -1.0 , 18446744073709551616.0,       0ULL, UINT64_MAX)\n\n/*\n * Min, Max\n */\n\n#if d_m3HasFloat\n\n#include <math.h>\n\nstatic inline\nf32 min_f32(f32 a, f32 b) {\n    if (M3_UNLIKELY(isnan(a) or isnan(b))) return NAN;\n    if (M3_UNLIKELY(a == 0 and a == b)) return signbit(a) ? a : b;\n    return a > b ? b : a;\n}\n\nstatic inline\nf32 max_f32(f32 a, f32 b) {\n    if (M3_UNLIKELY(isnan(a) or isnan(b))) return NAN;\n    if (M3_UNLIKELY(a == 0 and a == b)) return signbit(a) ? b : a;\n    return a > b ? a : b;\n}\n\nstatic inline\nf64 min_f64(f64 a, f64 b) {\n    if (M3_UNLIKELY(isnan(a) or isnan(b))) return NAN;\n    if (M3_UNLIKELY(a == 0 and a == b)) return signbit(a) ? a : b;\n    return a > b ? b : a;\n}\n\nstatic inline\nf64 max_f64(f64 a, f64 b) {\n    if (M3_UNLIKELY(isnan(a) or isnan(b))) return NAN;\n    if (M3_UNLIKELY(a == 0 and a == b)) return signbit(a) ? b : a;\n    return a > b ? a : b;\n}\n#endif\n\n#endif // m3_math_utils_h\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_module.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_module.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_module.c\n//\n//  Created by Steven Massey on 5/7/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include \"m3_module.h\"\n\n#include \"esp_log.h\"\n#include \"esp_debug_helpers.h\"\n\nvoid Module_FreeFunctions (IM3Module i_module)\n{\n    for (u32 i = 0; i < i_module->numFunctions; ++i)\n    {\n        IM3Function func = & i_module->functions [i];\n        Function_Release (func);\n    }\n}\n\n\nvoid  m3_FreeModule  (IM3Module i_module)\n{\n    if (i_module)\n    {\n        m3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\n               i_module->name, i_module->numFunctions, i_module->numDataSegments);\n\n        Module_FreeFunctions (i_module);\n\n        m3_Int_Free (i_module->functions);\n        //m3_Int_Free (i_module->imports);\n        m3_Int_Free (i_module->funcTypes);\n        m3_Int_Free (i_module->dataSegments);\n        m3_Int_Free (i_module->table0);\n\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            m3_Int_Free (i_module->globals[i].name);\n            FreeImportInfo(&(i_module->globals[i].import));\n        }\n        m3_Int_Free (i_module->globals);\n        m3_Int_Free (i_module->memoryExportName);\n        m3_Int_Free (i_module->table0ExportName);\n\n        FreeImportInfo(&i_module->memoryImport);\n\n        m3_Int_Free (i_module);\n    }\n}\n\n\nM3Result  Module_AddGlobal  (IM3Module io_module, IM3Global * o_global, u8 i_type, bool i_mutable, bool i_isImported)\n{\n_try {\n    u32 index = io_module->numGlobals++;\n    io_module->globals = m3_Int_ReallocArray (M3Global, io_module->globals, io_module->numGlobals, index);\n    _throwifnull (io_module->globals);\n    M3Global * global = & io_module->globals [index];\n\n    global->type = i_type;\n    global->imported = i_isImported;\n    global->isMutable = i_mutable;\n\n    if (o_global)\n        * o_global = global;\n\n} _catch:\n    return result;\n}\n\nstatic const bool WASM_DEBUG_PREALLOCFUNCTIONS = true;\nstatic const int PreallocFunctions_PageSize = 8;\nM3Result  Module_PreallocFunctions  (IM3Module io_module, u32 i_totalFunctions)\n{\n    if(WASM_DEBUG_PREALLOCFUNCTIONS && false){\n        if(i_totalFunctions > 10000){\n            esp_backtrace_print(100);\n        }\n    }\n\n_try {\n\n    i_totalFunctions = ((i_totalFunctions/PreallocFunctions_PageSize) + 1) * PreallocFunctions_PageSize;\n\n    if(WASM_DEBUG_PREALLOCFUNCTIONS) ESP_LOGI(\"WASM\", \"PreallocFunctions: (Total Funcs: %lu, All Funcs: %lu)\", i_totalFunctions, io_module->allFunctions);\n    if (i_totalFunctions > io_module->allFunctions) {\n        if(WASM_DEBUG_PREALLOCFUNCTIONS) ESP_LOGI(\"WASM\", \"PreallocFunctions: m3_Int_ReallocArray\");\n\n        if(WASM_DEBUG_PREALLOCFUNCTIONS && io_module->functions == NULL){\n            ESP_LOGI(\"WASM\", \"PreallocFunctions: first time module->functions allocation\");\n        }\n\n        io_module->functions = m3_Int_ReallocArray (M3Function, io_module->functions, i_totalFunctions, io_module->allFunctions);\n        io_module->allFunctions = i_totalFunctions;\n\n        if(WASM_DEBUG_PREALLOCFUNCTIONS) ESP_LOGI(\"WASM\", \"PreallocFunctions: allFunctions updated to %lu\", io_module->allFunctions);\n\n        if(io_module->functions) return NULL; // ...\n\n        _throwifnull (io_module->functions);\n    }\n    else {\n        return result; // nothing to do\n    }\n} _catch:\n    ESP_LOGE(\"WASM\", \"PreallocFunctions error\");\n    return result;\n}\n\nM3Result  Module_AddFunction  (IM3Module io_module, u32 i_typeIndex, IM3ImportInfo i_importInfo)\n{\n_try {\n\n    u32 index = io_module->numFunctions++;\n_   (Module_PreallocFunctions(io_module, io_module->numFunctions));\n\n    _throwif (\"type sig index out of bounds\", i_typeIndex >= io_module->numFuncTypes);\n\n    IM3FuncType ft = io_module->funcTypes [i_typeIndex];\n\n    IM3Function func = Module_GetFunction (io_module, index);\n    \n    if(func == NULL){\n        func = m3_Int_AllocStruct(M3Function);\n    }\n\n    func->funcType = ft;\n\n\n#   ifdef DEBUG\n    func->index = index;\n#   endif\n\n    if (i_importInfo and func->numNames == 0)\n    {\n        func->import = * i_importInfo;\n        func->names[0] = i_importInfo->fieldUtf8;\n        func->numNames = 1;\n    }\n\n    m3log (module, \"   added function: %3d; sig: %d\", index, i_typeIndex);\n\n} _catch:\n    return result;\n}\n\n#ifdef DEBUG\nvoid  Module_GenerateNames  (IM3Module i_module)\n{\n    for (u32 i = 0; i < i_module->numFunctions; ++i)\n    {\n        IM3Function func = & i_module->functions [i];\n\n        if (func->numNames == 0)\n        {\n            char* buff = m3_Int_AllocArray(char, 16);\n            snprintf(buff, 16, \"$func%d\", i);\n            func->names[0] = buff;\n            func->numNames = 1;\n        }\n    }\n    for (u32 i = 0; i < i_module->numGlobals; ++i)\n    {\n        IM3Global global = & i_module->globals [i];\n\n        if (global->name == NULL)\n        {\n            char* buff = m3_Int_AllocArray(char, 16);\n            snprintf(buff, 16, \"$global%d\", i);\n            global->name = buff;\n        }\n    }\n}\n#endif\n\nIM3Function  Module_GetFunction  (IM3Module i_module, u32 i_functionIndex)\n{\n    IM3Function func = NULL;\n\n    if (i_functionIndex < i_module->numFunctions)\n    {\n        /*if(is_ptr_valid(& i_module->functions [i_functionIndex]))\n        {\n            func = & i_module->functions [i_functionIndex];\n            //func->module = i_module;\n        }\n        else {\n            ESP_LOGE(\"WASM\", \"Module_GetFunction: invalid function pointer\");\n        }*/\n\n       func = &i_module->functions [i_functionIndex];        \n    }  \n    else {\n        ESP_LOGE(\"WASM\", \"Module_GetFunction: i_functionIndex >= i_module->numFunctions (%lu, %lu)\", i_functionIndex, i_module->numFunctions );\n    }  \n\n    return func;\n}\n\n\nconst char*  m3_GetModuleName  (IM3Module i_module)\n{\n    if (!i_module || !i_module->name)\n        return \".unnamed\";\n\n    return i_module->name;\n}\n\nvoid  m3_SetModuleName  (IM3Module i_module, const char* name)\n{\n    if (i_module) i_module->name = name;\n}\n\nIM3Runtime  m3_GetModuleRuntime  (IM3Module i_module)\n{\n    return i_module ? i_module->runtime : NULL;\n}\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exception.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exception.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_exception.h\n//\n//  Created by Steven Massey on 7/5/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n//  some macros to emulate try/catch\n\n#pragma once\n\n#include <stdarg.h>\n#include \"m3_config.h\"\n\n# if d_m3EnableExceptionBreakpoint\n\n// declared in m3_info.c\nvoid ExceptionBreakpoint (cstr_t i_exception, cstr_t i_message);\n\n#   define EXCEPTION_PRINT(ERROR) ExceptionBreakpoint (ERROR, (__FILE__ \":\" M3_STR(__LINE__)))\n\n# else\n#   define EXCEPTION_PRINT(...)\n# endif\n\n\n#define _try                                M3Result result = m3Err_none;\n#define _(TRY)                              { result = TRY; if (M3_UNLIKELY(result)) { EXCEPTION_PRINT (result); goto _catch; } }\n#define _throw(ERROR)                       { result = ERROR; EXCEPTION_PRINT (result); goto _catch; }\n#define _throwif(ERROR, COND)               if (M3_UNLIKELY(COND)) { _throw(ERROR); }\n\n#define _throwifnull(PTR)                   _throwif (m3Err_mallocFailed, !(PTR))\n\nchar* error_details(const char* base_error, const char* format, ...);\n\n// const char* err2 = error_details(trapStackOverflow, \"Errore alla linea %d\", line_number);\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_segmented_memory.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_segmented_memory.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#include \"m3_segmented_memory.h\"\n#include \"esp_log.h\"\n\n#include \"m3_pointers.h\"\n\nIM3Memory m3_NewMemory(){\n    IM3Memory memory = m3_Int_AllocStruct (M3Memory);\n    memory->segment_size = WASM_SEGMENT_SIZE;\n\n    if(memory == NULL){\n        ESP_LOGE(\"WASM3\", \"m3_NewMemory: Memory allocation failed\");\n        return NULL;\n    }\n\n    memory->segments = NULL; //m3_NewArray (MemorySegment, WASM_MAX_SEGMENTS);    \n    memory->max_size = 0; \n    memory->num_segments = 0;\n    memory->total_size = 0;\n    //memory->point = 0;\n\n    // What are used for pages?\n    memory->numPages = 0;\n    memory->maxPages = M3Memory_MaxPages;\n\n    return memory;\n}\n\nIM3MemoryPoint m3_GetMemoryPoint(IM3Memory mem){\n    IM3MemoryPoint point = m3_Int_AllocStruct (M3MemoryPoint);\n\n    if(point == NULL){\n        ESP_LOGE(\"WASM3\", \"m3_GetMemoryPoint: Memory allocation failed\");\n        return NULL;\n    }\n\n    point->memory = mem;\n    point->offset = 0;\n    return point;\n}\n\n///\n/// Memory fragmentation\n///\n\n// Funzioni di gestione della memoria\n/*M3Result InitMemory(M3Memory* memory, size_t initial_stack, size_t initial_linear) {\n    size_t total = initial_stack + initial_linear;\n    memory->memory = m3_malloc(total);\n    if (!memory->memory) return M3Result_mallocFailed;\n    \n    memory->total_size = total;\n    \n    // Inizializza la memoria lineare dal basso\n    memory->linear.base = memory->memory;\n    memory->linear.size = initial_linear;\n    memory->linear.max_size = initial_linear * 2; // esempio\n    \n    // Inizializza lo stack dall'alto\n    memory->stack.base = memory->memory + total;\n    memory->stack.size = initial_stack;\n    memory->stack.max_size = initial_stack * 2; // esempio\n    \n    // Stack pointer parte dall'alto\n    memory->stack_pointer = memory->stack.base;\n    \n    return NULL;\n}*/\n\n// Funzione per verificare se un indirizzo appartiene allo stack\n/*bool IsStackAddress(M3Memory* memory, u8* addr) {\n    return (addr <= memory->stack.base && \n            addr >= (memory->stack.base - memory->stack.size));\n}*/\n\n// Funzione per verificare se un indirizzo appartiene alla memoria lineare\nbool IsLinearAddress(M3Memory* memory, u8* addr) {\n    return (addr >= memory->linear.base && \n            addr < (memory->linear.base + memory->linear.size));\n}\n\n// Funzione per convertire offset stack in indirizzo assoluto\nu8* GetStackAddress(M3Memory* memory, size_t offset) {\n    return memory->stack.base - offset;\n}\n\n// Funzione per la crescita dello stack\n/*M3Result GrowStack(M3Memory* memory, size_t additional_size) {\n    // Calcola nuovo punto di incontro\n    size_t new_stack_size = memory->stack.size + additional_size;\n    u8* new_stack_limit = memory->stack.base - new_stack_size;\n    u8* linear_limit = memory->linear.base + memory->linear.size;\n    \n    // Verifica collisione\n    if (new_stack_limit <= linear_limit) {\n        // Necessaria riallocazione\n        size_t new_total = memory->total_size * 2;\n        u8* new_memory = m3_realloc(memory->memory, new_total);\n        if (!new_memory) return M3Result_mallocFailed;\n        \n        // Aggiorna tutti i puntatori\n        size_t stack_offset = memory->stack.base - memory->memory;\n        size_t sp_offset = memory->stack_pointer - memory->memory;\n        \n        memory->memory = new_memory;\n        memory->total_size = new_total;\n        memory->stack.base = new_memory + stack_offset;\n        memory->stack_pointer = new_memory + sp_offset;\n        memory->linear.base = new_memory;\n    }\n    \n    memory->stack.size = new_stack_size;\n    return NULL;\n}*/\n\n/* // Example implementation\n\n// Modifiche alle operazioni dello stack\nd_m3Operation(Push_i32) {\n    i32 value = *(i32*)(runtime->stack_pointer);\n    \n    // Verifica spazio disponibile\n    if ((runtime->stack_pointer - sizeof(i32)) < \n        (runtime->memory.stack.base - runtime->memory.stack.size)) {\n        if (GrowStack(&runtime->memory, PAGE_SIZE) != NULL) {\n            return 0; // o gestione errore\n        }\n    }\n    \n    runtime->stack_pointer -= sizeof(i32);\n    *(i32*)(runtime->stack_pointer) = value;\n    return 0;\n}\n\nd_m3Operation(Pop_i32) {\n    i32 value = *(i32*)(runtime->stack_pointer);\n    runtime->stack_pointer += sizeof(i32);\n    \n    // Verifica overflow\n    if (runtime->stack_pointer > runtime->memory.stack.base) {\n        // Gestione errore stack overflow\n        return 0;\n    }\n    \n    return (m3reg_t)value;\n}\n*/\n\n///\n/// Stack/linear differation\n///\n\n// Funzione per aggiungere un nuovo segmento\nM3Result AddSegment(M3Memory* memory) {\n    size_t new_size = (memory->num_segments + 1) * sizeof(MemorySegment);\n    MemorySegment* new_segments = m3_realloc(memory->segments, new_size);\n    if (!new_segments) return m3Err_mallocFailed;\n    \n    memory->segments = new_segments;\n    \n    // Inizializza il nuovo segmento\n    size_t new_idx = memory->num_segments;\n    memory->segments[new_idx].data = m3_malloc(memory->segment_size);\n    if (!memory->segments[new_idx].data) return m3Err_mallocFailed;\n    \n    memory->segments[new_idx].is_allocated = true;\n    memory->num_segments++;\n    memory->total_size += memory->segment_size;\n    \n    return NULL; // aka success\n}\n\n// Funzione per trovare l'indirizzo effettivo dato un offset\nu8* GetEffectiveAddress(M3Memory* memory, size_t offset) {\n    size_t segment_idx = offset / memory->segment_size;\n    size_t segment_offset = offset % memory->segment_size;\n    \n    if (segment_idx >= memory->num_segments) return NULL;\n    \n    return (u8*)memory->segments[segment_idx].data + segment_offset;\n}\n\n// Funzione per verificare se un indirizzo appartiene allo stack\nbool IsStackAddress(M3Memory* memory, u8* addr) {\n    for (size_t i = 0; i < memory->num_segments; i++) {\n        u8* seg_start = memory->segments[i].data;\n        u8* seg_end = seg_start + memory->segment_size;\n        \n        if (addr >= seg_start && addr < seg_end) {\n            size_t offset = addr - seg_start;\n            size_t total_offset = i * memory->segment_size + offset;\n            \n            // Verifica se l'offset totale è nella regione stack\n            return total_offset >= memory->total_size - memory->stack.size;\n        }\n    }\n    return false;\n}\n\n// Funzione per la crescita dello stack\n/*M3Result GrowStack(M3Memory* memory, size_t additional_size) {\n    size_t new_stack_size = memory->stack.size + additional_size;\n    \n    // Verifica se serve un nuovo segmento\n    if (memory->linear.size + new_stack_size > memory->total_size) {\n        M3Result result = AddSegment(memory);\n        if (result != NULL) return result;\n        \n        // Aggiorna i puntatori dello stack nella nuova configurazione\n        memory->stack.base = (u8*)memory->segments[memory->num_segments-1].data + \n                            memory->segment_size;\n    }\n    \n    memory->stack.size = new_stack_size;\n    return NULL;\n}*/\n\n///\n/// From m3_env\n///\n\nstatic const int DEBUG_TOP_MEMORY = 1;\n\n/*\n// old implementation. even older ones in m3_env\nM3Result InitMemory(IM3Runtime io_runtime, IM3Module i_module) {\n    if(DEBUG_TOP_MEMORY) ESP_LOGI(\"WASM3\", \"InitMemory called\");\n\n    if (i_module->memoryInfo.pageSize == 0) {\n        i_module->memoryInfo.pageSize = 65536;  // Standard WebAssembly page size\n        ESP_LOGI(\"WASM3\", \"InitMemory - Fixed pageSize to standard 64KB\");\n    }\n\n    M3Result result = m3Err_none;\n\n    if (!i_module->memoryImported) {\n        io_runtime->memory.maxPages = i_module->memoryInfo.maxPages ? \n                                    i_module->memoryInfo.maxPages : 65536;\n        io_runtime->memory.pageSize = i_module->memoryInfo.pageSize;\n        io_runtime->memory.segment_size = WASM_SEGMENT_SIZE;  // Usa la page size come segment size\n        \n        result = ResizeMemory(io_runtime, i_module->memoryInfo.initPages);\n    }\n    else {\n        if(io_runtime->memory.segment_size == 0) {\n            ESP_LOGW(\"WASM3\", \"InitMemory: io_runtime->memory.segment_size == 0\");\n            io_runtime->memory.segment_size = WASM_SEGMENT_SIZE;\n        }\n    }\n\n    return result;\n}*/\n\n// Trying to implement stack/linear memory differentiation\n/*M3Result InitMemory(M3Memory* memory, size_t initial_stack, size_t initial_linear) {\n    memory->segment_size = WASM_SEGMENT_SIZE;  // es: 64KB (dimensione pagina WebAssembly)\n    memory->num_segments = 1;  // Inizia con un segmento\n    memory->segments = m3_malloc(sizeof(MemorySegment));\n    if (!memory->segments) return m3Err_mallocFailed;\n    \n    // Alloca il primo segmento\n    memory->segments[0].data = m3_malloc(memory->segment_size);\n    if (!memory->segments[0].data) {\n        m3_free(memory->segments);\n        return m3Err_mallocFailed;\n    }\n    memory->segments[0].is_allocated = true;\n    \n    // Inizializza le regioni all'interno del primo segmento\n    memory->linear.base = memory->segments[0].data;\n    memory->linear.size = initial_linear;\n    \n    memory->stack.base = (u8*)memory->segments[0].data + memory->segment_size;\n    memory->stack.size = initial_stack;\n    \n    memory->total_size = memory->segment_size;\n    \n    return NULL; // aka success\n}*/\n\nM3Result ResizeMemory(IM3Runtime io_runtime, u32 i_numPages) {\n    if (!io_runtime) return m3Err_nullRuntime;\n    \n    M3Memory* memory = &io_runtime->memory;\n    if (!memory) return m3Err_mallocFailed;\n\n    // Validate page count against maximum\n    if (i_numPages > memory->maxPages) {\n        return m3Err_wasmMemoryOverflow;\n    }\n\n    // Calculate new total size in bytes\n    size_t newPageBytes = (size_t)i_numPages * memory->pageSize;\n    if (newPageBytes / memory->pageSize != i_numPages) {\n        return m3Err_mallocFailed;  // Overflow check\n    }\n\n    #if d_m3MaxLinearMemoryPages > 0\n    if (i_numPages > d_m3MaxLinearMemoryPages) {\n        return m3Err_mallocFailed;\n    }\n    #endif\n\n    // Apply memory limit if set\n    if (io_runtime->memoryLimit && newPageBytes > io_runtime->memoryLimit) {\n        newPageBytes = io_runtime->memoryLimit;\n        i_numPages = newPageBytes / memory->pageSize;\n    }\n\n    // Calculate required segments based on new size\n    size_t new_num_segments = (newPageBytes + memory->segment_size - 1) / memory->segment_size;\n    \n    // Handle initial allocation\n    if (!memory->segments) {\n        memory->segments = current_allocator->malloc(new_num_segments * sizeof(MemorySegment));\n        if (!memory->segments) {\n            return m3Err_mallocFailed;\n        }\n        \n        // Initialize new segments\n        for (size_t i = 0; i < new_num_segments; i++) {\n            memory->segments[i].data = NULL;\n            memory->segments[i].is_allocated = false;\n            memory->segments[i].stack_size = 0;\n            memory->segments[i].linear_size = 0;\n        }\n    }\n    // Handle resize\n    else if (new_num_segments != memory->num_segments) {\n        // Reallocate segment array\n        MemorySegment* new_segments = current_allocator->realloc(\n            memory->segments,\n            new_num_segments * sizeof(MemorySegment)\n        );\n        \n        if (!new_segments) {\n            return m3Err_mallocFailed;\n        }\n        \n        memory->segments = new_segments;\n\n        if (new_num_segments > memory->num_segments) {\n            // Initialize newly added segments\n            for (size_t i = memory->num_segments; i < new_num_segments; i++) {\n                memory->segments[i].data = NULL;\n                memory->segments[i].is_allocated = false;\n                memory->segments[i].stack_size = 0;\n                memory->segments[i].linear_size = 0;\n            }\n        } else {\n            // Free memory from removed segments\n            for (size_t i = new_num_segments; i < memory->num_segments; i++) {\n                if (memory->segments[i].is_allocated && memory->segments[i].data) {\n                    current_allocator->free(memory->segments[i].data);\n                    memory->segments[i].is_allocated = false;\n                    memory->segments[i].data = NULL;\n                }\n            }\n        }\n    }\n\n    // Update memory regions\n    size_t total_linear_size = newPageBytes * 3/4;  // 75% for linear memory\n    size_t total_stack_size = newPageBytes - total_linear_size;  // 25% for stack\n\n    // Update linear memory region\n    memory->linear.size = total_linear_size;\n    if (memory->linear.current_offset > total_linear_size) {\n        memory->linear.current_offset = total_linear_size;\n    }\n\n    // Update stack region\n    memory->stack.size = total_stack_size;\n    if (memory->stack.current_offset > total_stack_size) {\n        memory->stack.current_offset = total_stack_size;\n    }\n    \n    // Update memory metadata\n    memory->num_segments = new_num_segments;\n    memory->numPages = i_numPages;\n    memory->total_size = newPageBytes;\n\n    return m3Err_none;\n}\n\n\nvoid FreeMemory(IM3Runtime io_runtime) {\n    if(DEBUG_TOP_MEMORY) ESP_LOGI(\"WASM3\", \"FreeMemory called\");\n    \n    M3Memory* memory = &io_runtime->memory;\n\n    if (memory->segments) {\n        // Libera la memoria di ogni segmento allocato\n        for (size_t i = 0; i < memory->num_segments; i++) {\n            if (memory->segments[i].is_allocated && memory->segments[i].data) {\n                m3_Free_Impl(memory->segments[i].data, false);\n            }\n        }\n        // Libera l'array dei segmenti\n        m3_Free_Impl(memory->segments, false);\n        memory->segments = NULL;\n        memory->num_segments = 0;\n    }\n\n    memory->numPages = 0;\n    memory->maxPages = 0;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Segmented memory management\n\n#define WASM_DEBUG_SEGMENTED_MEM_MAN 1\n\nbool allocate_segment(M3Memory* memory, size_t segment_index) {\n    if (!memory || segment_index >= memory->num_segments) {\n        return false;\n    }\n\n    // Se il segmento è già allocato, restituisci true\n    if (memory->segments[segment_index].is_allocated) {\n        return true;\n    }\n\n    if (WASM_DEBUG_SEGMENTED_MEM_MAN) {\n        ESP_LOGI(\"WASM3\", \"Allocating segment %zu of size %zu\", \n                 segment_index, memory->segment_size);\n    }\n\n    // Prima prova ad allocare in SPIRAM se abilitata\n    void* ptr = WASM_ENABLE_SPI_MEM ? \n                heap_caps_malloc(memory->segment_size, MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM) : \n                NULL;\n\n    // Se l'allocazione in SPIRAM fallisce o non è disponibile, prova la memoria interna\n    if (!ptr) {\n        ptr = heap_caps_malloc(memory->segment_size, \n                             MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n        \n        if (WASM_DEBUG_SEGMENTED_MEM_MAN && !ptr) {\n            ESP_LOGE(\"WASM3\", \"Failed to allocate segment in internal memory\");\n        }\n    }\n    else if (WASM_DEBUG_SEGMENTED_MEM_MAN) {\n        ESP_LOGI(\"WASM3\", \"Segment allocated in SPIRAM\");\n    }\n\n    if (ptr) {\n        // Inizializza il segmento con zeri\n        memset(ptr, 0, memory->segment_size);\n        \n        memory->segments[segment_index].data = ptr;\n        memory->segments[segment_index].is_allocated = true;\n        \n        if (WASM_DEBUG_SEGMENTED_MEM_MAN) {\n            ESP_LOGI(\"WASM3\", \"Segment %zu successfully allocated\", segment_index);\n        }\n        \n        return true;\n    }\n\n    return false;\n}\n\n/*static inline void* GetMemorySegment(IM3Memory memory, u32 offset)\n{\n    size_t segment_index = offset / memory->segment_size;\n    size_t segment_offset = offset % memory->segment_size;\n    MemorySegment segment = memory->segments[segment_index];\n    return (u8*)segment.data + segment_offset;\n}\n\nstatic inline i32 m3_LoadInt(IM3Memory memory, u32 offset)\n{\n    void* ptr = GetMemorySegment(memory, offset);\n    return *(i32*)ptr;\n}\n\nstatic inline void m3_StoreInt(IM3Memory memory, u32 offset, i32 value)\n{\n    void* ptr = GetMemorySegment(memory, offset);\n    *(i32*)ptr = value;\n}*/\n\n////////////////////////////////////////////////////////////////\n\n///\n/// New implementation\n///\n\n\n// Get segment and offset for a given address\nstatic bool GetSegmentAndOffset(M3Memory* memory, u8* addr, size_t* seg_idx, size_t* offset) {\n    for (size_t i = 0; i < memory->num_segments; i++) {\n        if (!memory->segments[i].is_allocated) continue;\n        \n        u8* seg_start = memory->segments[i].data;\n        u8* seg_end = seg_start + memory->segment_size;\n        \n        if (addr >= seg_start && addr < seg_end) {\n            *seg_idx = i;\n            *offset = addr - seg_start;\n            return true;\n        }\n    }\n    return false;\n}\n\n// Unified function to check address type\nAddressType GetAddressType(M3Memory* memory, u8* addr) {\n    size_t seg_idx, offset;\n    \n    if (!GetSegmentAndOffset(memory, addr, &seg_idx, &offset)) {\n        return ADDRESS_INVALID;\n    }\n    \n    MemorySegment* segment = &memory->segments[seg_idx];\n    size_t total_offset = seg_idx * memory->segment_size + offset;\n    \n    if (total_offset >= memory->total_size - memory->stack.size) {\n        return ADDRESS_STACK;\n    }\n    \n    if (total_offset < memory->linear.size) {\n        return ADDRESS_LINEAR;\n    }\n    \n    return ADDRESS_INVALID;\n}\n\n// Unified stack growth function\nM3Result GrowStack(M3Memory* memory, size_t additional_size) {\n    size_t new_stack_size = memory->stack.size + additional_size;\n    \n    // Check if we need a new segment\n    if (memory->linear.size + new_stack_size > memory->total_size) {\n        // Try to allocate new segment first\n        M3Result result = AddSegment(memory);\n        if (result != NULL) {\n            return result;\n        }\n        \n        // Update stack base to end of new segment\n        size_t last_seg = memory->num_segments - 1;\n        memory->stack.base = (u8*)memory->segments[last_seg].data + memory->segment_size;\n        \n        // Update segment metadata\n        memory->segments[last_seg].stack_size = additional_size;\n    } else {\n        // Find segment containing stack top\n        size_t seg_idx = (memory->total_size - memory->stack.size) / memory->segment_size;\n        memory->segments[seg_idx].stack_size += additional_size;\n    }\n    \n    memory->stack.size = new_stack_size;\n    return NULL;\n}\n\n// Get effective address with bounds checking\nu8* GetEffectiveAddress(M3Memory* memory, size_t offset) {\n    size_t segment_idx = offset / memory->segment_size;\n    size_t segment_offset = offset % memory->segment_size;\n    \n    if (segment_idx >= memory->num_segments || \n        !memory->segments[segment_idx].is_allocated) {\n        return NULL;\n    }\n    \n    // Check if address is in valid region\n    if (offset >= memory->linear.size && \n        offset < memory->total_size - memory->stack.size) {\n        return NULL;\n    }\n    \n    return (u8*)memory->segments[segment_idx].data + segment_offset;\n}\n\n// Memory initialization with proper segmentation\nM3Result InitMemory(M3Memory* memory, size_t initial_stack, size_t initial_linear) {\n    memory->segment_size = WASM_SEGMENT_SIZE;\n    \n    // Calculate required segments\n    size_t total_size = initial_stack + initial_linear;\n    size_t num_segments = (total_size + memory->segment_size - 1) / memory->segment_size;\n    \n    memory->segments = m3_malloc(num_segments * sizeof(MemorySegment));\n    if (!memory->segments) return M3Result_mallocFailed;\n    \n    // Initialize segments\n    for (size_t i = 0; i < num_segments; i++) {\n        memory->segments[i].data = NULL;\n        memory->segments[i].is_allocated = false;\n        memory->segments[i].stack_size = 0;\n        memory->segments[i].linear_size = 0;\n    }\n    \n    // Allocate first segment\n    if (!allocate_segment(memory, 0)) {\n        m3_free(memory->segments);\n        return M3Result_mallocFailed;\n    }\n    \n    // Setup memory regions\n    memory->linear.base = memory->segments[0].data;\n    memory->linear.size = initial_linear;\n    memory->linear.current_offset = 0;\n    \n    memory->stack.base = (u8*)memory->segments[num_segments-1].data + memory->segment_size;\n    memory->stack.size = initial_stack;\n    memory->stack.current_offset = 0;\n    \n    memory->num_segments = num_segments;\n    memory->total_size = num_segments * memory->segment_size;\n    \n    return NULL;\n}\n\n// Memory access helpers\nstatic inline void* GetMemorySegment(IM3Memory memory, u32 offset) {\n    u8* addr = GetEffectiveAddress(memory, offset);\n    if (!addr) {\n        // Handle error - could throw exception or return error code\n        return NULL;\n    }\n    return addr;\n}\n\nstatic inline i32 m3_LoadInt(IM3Memory memory, u32 offset) {\n    void* ptr = GetMemorySegment(memory, offset);\n    if (!ptr) return 0; // Or handle error\n    return *(i32*)ptr;\n}\n\nstatic inline void m3_StoreInt(IM3Memory memory, u32 offset, i32 value) {\n    void* ptr = GetMemorySegment(memory, offset);\n    if (ptr) {\n        *(i32*)ptr = value;\n    }\n    // else handle error\n}", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/wasm3_defs.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/wasm3_defs.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  wasm3_defs.h\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include <stdint.h>\n\n#define M3_STR__(x) #x\n#define M3_STR(x)   M3_STR__(x)\n\n#define M3_CONCAT__(a,b) a##b\n#define M3_CONCAT(a,b)   M3_CONCAT__(a,b)\n\n/*\n * Detect compiler\n */\n\n# if defined(__clang__)\n#  define M3_COMPILER_CLANG 1\n# elif defined(__INTEL_COMPILER)\n#  define M3_COMPILER_ICC 1\n# elif defined(__GNUC__) || defined(__GNUG__)\n#  define M3_COMPILER_GCC 1\n# elif defined(_MSC_VER)\n#  define M3_COMPILER_MSVC 1\n# else\n#  warning \"Compiler not detected\"\n# endif\n\n# if defined(M3_COMPILER_CLANG)\n#  if defined(WIN32)\n#   define M3_COMPILER_VER __VERSION__ \" for Windows\"\n#  else\n#   define M3_COMPILER_VER __VERSION__\n#  endif\n# elif defined(M3_COMPILER_GCC)\n#  define M3_COMPILER_VER \"GCC \" __VERSION__\n# elif defined(M3_COMPILER_ICC)\n#  define M3_COMPILER_VER __VERSION__\n# elif defined(M3_COMPILER_MSVC)\n#  define M3_COMPILER_VER \"MSVC \" M3_STR(_MSC_VER)\n# else\n#  define M3_COMPILER_VER \"unknown\"\n# endif\n\n# ifdef __has_feature\n#  define M3_COMPILER_HAS_FEATURE(x) __has_feature(x)\n# else\n#  define M3_COMPILER_HAS_FEATURE(x) 0\n# endif\n\n# ifdef __has_builtin\n#  define M3_COMPILER_HAS_BUILTIN(x) __has_builtin(x)\n# else\n#  define M3_COMPILER_HAS_BUILTIN(x) 0\n# endif\n\n# ifdef __has_attribute\n#  define M3_COMPILER_HAS_ATTRIBUTE(x) __has_attribute(x)\n# else\n#  define M3_COMPILER_HAS_ATTRIBUTE(x) 0\n# endif\n\n/*\n * Detect endianness\n */\n\n# if defined(M3_COMPILER_MSVC)\n#  define M3_LITTLE_ENDIAN\n# elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#  define M3_LITTLE_ENDIAN\n# elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#  define M3_BIG_ENDIAN\n# else\n#  error \"Byte order not detected\"\n# endif\n\n/*\n * Detect platform\n */\n\n# if defined(M3_COMPILER_CLANG) || defined(M3_COMPILER_GCC) || defined(M3_COMPILER_ICC)\n#  if defined(__wasm__)\n#   define M3_ARCH \"wasm\"\n\n#  elif defined(__x86_64__)\n#   define M3_ARCH \"x86_64\"\n\n#  elif defined(__i386__)\n#   define M3_ARCH \"i386\"\n\n#  elif defined(__aarch64__)\n#   define M3_ARCH \"arm64-v8a\"\n\n#  elif defined(__arm__)\n#   if defined(__ARM_ARCH_7A__)\n#    if defined(__ARM_NEON__)\n#     if defined(__ARM_PCS_VFP)\n#      define M3_ARCH \"arm-v7a/NEON hard-float\"\n#     else\n#      define M3_ARCH \"arm-v7a/NEON\"\n#     endif\n#    else\n#     if defined(__ARM_PCS_VFP)\n#      define M3_ARCH \"arm-v7a hard-float\"\n#     else\n#      define M3_ARCH \"arm-v7a\"\n#     endif\n#    endif\n#   else\n#    define M3_ARCH \"arm\"\n#   endif\n\n#  elif defined(__riscv)\n#   if defined(__riscv_32e)\n#    define _M3_ARCH_RV \"rv32e\"\n#   elif __riscv_xlen == 128\n#    define _M3_ARCH_RV \"rv128i\"\n#   elif __riscv_xlen == 64\n#    define _M3_ARCH_RV \"rv64i\"\n#   elif __riscv_xlen == 32\n#    define _M3_ARCH_RV \"rv32i\"\n#   endif\n#   if defined(__riscv_muldiv)\n#    define _M3_ARCH_RV_M _M3_ARCH_RV \"m\"\n#   else\n#    define _M3_ARCH_RV_M _M3_ARCH_RV\n#   endif\n#   if defined(__riscv_atomic)\n#    define _M3_ARCH_RV_A _M3_ARCH_RV_M \"a\"\n#   else\n#    define _M3_ARCH_RV_A _M3_ARCH_RV_M\n#   endif\n#   if defined(__riscv_flen)\n#    define _M3_ARCH_RV_F _M3_ARCH_RV_A \"f\"\n#   else\n#    define _M3_ARCH_RV_F _M3_ARCH_RV_A\n#   endif\n#   if defined(__riscv_flen) && __riscv_flen >= 64\n#    define _M3_ARCH_RV_D _M3_ARCH_RV_F \"d\"\n#   else\n#    define _M3_ARCH_RV_D _M3_ARCH_RV_F\n#   endif\n#   if defined(__riscv_compressed)\n#    define _M3_ARCH_RV_C _M3_ARCH_RV_D \"c\"\n#   else\n#    define _M3_ARCH_RV_C _M3_ARCH_RV_D\n#   endif\n#   define M3_ARCH _M3_ARCH_RV_C\n\n#  elif defined(__mips__)\n#   if defined(__MIPSEB__) && defined(__mips64)\n#    define M3_ARCH \"mips64 \" _MIPS_ARCH\n#   elif defined(__MIPSEL__) && defined(__mips64)\n#    define M3_ARCH \"mips64el \" _MIPS_ARCH\n#   elif defined(__MIPSEB__)\n#    define M3_ARCH \"mips \" _MIPS_ARCH\n#   elif defined(__MIPSEL__)\n#    define M3_ARCH \"mipsel \" _MIPS_ARCH\n#   endif\n\n#  elif defined(__PPC__)\n#   if defined(__PPC64__) && defined(__LITTLE_ENDIAN__)\n#    define M3_ARCH \"ppc64le\"\n#   elif defined(__PPC64__)\n#    define M3_ARCH \"ppc64\"\n#   else\n#    define M3_ARCH \"ppc\"\n#   endif\n\n#  elif defined(__sparc__)\n#   if defined(__arch64__)\n#    define M3_ARCH \"sparc64\"\n#   else\n#    define M3_ARCH \"sparc\"\n#   endif\n\n#  elif defined(__s390x__)\n#   define M3_ARCH \"s390x\"\n\n#  elif defined(__alpha__)\n#   define M3_ARCH \"alpha\"\n\n#  elif defined(__m68k__)\n#   define M3_ARCH \"m68k\"\n\n#  elif defined(__xtensa__)\n#   define M3_ARCH \"xtensa\"\n\n#  elif defined(__arc__)\n#   define M3_ARCH \"arc32\"\n\n#  elif defined(__AVR__)\n#   define M3_ARCH \"avr\"\n#  endif\n# endif\n\n# if defined(M3_COMPILER_MSVC)\n#  if defined(_M_X64)\n#   define M3_ARCH \"x86_64\"\n#  elif defined(_M_IX86)\n#   define M3_ARCH \"i386\"\n#  elif defined(_M_ARM64)\n#   define M3_ARCH \"arm64\"\n#  elif defined(_M_ARM)\n#   define M3_ARCH \"arm\"\n#  endif\n# endif\n\n# if !defined(M3_ARCH)\n#  warning \"Architecture not detected\"\n#  define M3_ARCH \"unknown\"\n# endif\n\n/*\n * Byte swapping (for Big-Endian systems only)\n */\n\n# if defined(M3_COMPILER_MSVC)\n#  define m3_bswap16(x)     _byteswap_ushort((x))\n#  define m3_bswap32(x)     _byteswap_ulong((x))\n#  define m3_bswap64(x)     _byteswap_uint64((x))\n# elif defined(M3_COMPILER_GCC) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n// __builtin_bswap32/64 added in gcc 4.3, __builtin_bswap16 added in gcc 4.8\n#  define m3_bswap16(x)     __builtin_bswap16((x))\n#  define m3_bswap32(x)     __builtin_bswap32((x))\n#  define m3_bswap64(x)     __builtin_bswap64((x))\n# elif defined(M3_COMPILER_CLANG) && M3_COMPILER_HAS_BUILTIN(__builtin_bswap16)\n#  define m3_bswap16(x)     __builtin_bswap16((x))\n#  define m3_bswap32(x)     __builtin_bswap32((x))\n#  define m3_bswap64(x)     __builtin_bswap64((x))\n# elif defined(M3_COMPILER_ICC)\n#  define m3_bswap16(x)     __builtin_bswap16((x))\n#  define m3_bswap32(x)     __builtin_bswap32((x))\n#  define m3_bswap64(x)     __builtin_bswap64((x))\n# else\n#  ifdef __linux__\n#   include <endian.h>\n#  else\n#   include <stdint.h>\n#  endif\n#  if defined(__bswap_16)\n#   define m3_bswap16(x)     __bswap_16((x))\n#   define m3_bswap32(x)     __bswap_32((x))\n#   define m3_bswap64(x)     __bswap_64((x))\n#  else\n#   warning \"Using naive (probably slow) bswap operations\"\n    static inline\n    uint16_t m3_bswap16(uint16_t x) {\n      return ((( x  >> 8 ) & 0xffu ) | (( x  & 0xffu ) << 8 ));\n    }\n    static inline\n    uint32_t m3_bswap32(uint32_t x) {\n      return ((( x & 0xff000000u ) >> 24 ) |\n              (( x & 0x00ff0000u ) >> 8  ) |\n              (( x & 0x0000ff00u ) << 8  ) |\n              (( x & 0x000000ffu ) << 24 ));\n    }\n    static inline\n    uint64_t m3_bswap64(uint64_t x) {\n      return ((( x & 0xff00000000000000ull ) >> 56 ) |\n              (( x & 0x00ff000000000000ull ) >> 40 ) |\n              (( x & 0x0000ff0000000000ull ) >> 24 ) |\n              (( x & 0x000000ff00000000ull ) >> 8  ) |\n              (( x & 0x00000000ff000000ull ) << 8  ) |\n              (( x & 0x0000000000ff0000ull ) << 24 ) |\n              (( x & 0x000000000000ff00ull ) << 40 ) |\n              (( x & 0x00000000000000ffull ) << 56 ));\n    }\n#  endif\n# endif\n\n/*\n * Bit ops\n */\n#define m3_isBitSet(val, pos)           ((val & (1 << pos)) != 0)\n\n/*\n * Other\n */\n\n# if defined(M3_COMPILER_GCC) || defined(M3_COMPILER_CLANG) || defined(M3_COMPILER_ICC)\n#  define M3_UNLIKELY(x) __builtin_expect(!!(x), 0)\n#  define M3_LIKELY(x)   __builtin_expect(!!(x), 1)\n# else\n#  define M3_UNLIKELY(x) (x)\n#  define M3_LIKELY(x)   (x)\n# endif\n\n///\n/// Moved from core.h\n///\n\n\n# if defined(__cplusplus)\n#   define d_m3BeginExternC     extern \"C\" {\n#   define d_m3EndExternC       }\n# else\n#   define d_m3BeginExternC\n#   define d_m3EndExternC\n# endif\n\nd_m3BeginExternC\n\n#define d_m3ImplementFloat (d_m3HasFloat || d_m3NoFloatDynamic)\n\n#if !defined(d_m3ShortTypesDefined)\n\ntypedef uint64_t        u64;\ntypedef int64_t         i64;\ntypedef uint32_t        u32;\ntypedef int32_t         i32;\ntypedef uint16_t        u16;\ntypedef int16_t         i16;\ntypedef uint8_t         u8;\ntypedef int8_t          i8;\n\n//#if d_m3ImplementFloat\ntypedef double          f64;\ntypedef float           f32;\n//#endif\n\n#endif // d_m3ShortTypesDefined\n\n#define PRIf32          \"f\"\n#define PRIf64          \"lf\"\n\ntypedef const void *            m3ret_t;\ntypedef const void *            voidptr_t;\ntypedef const char *            cstr_t;\ntypedef const char * const      ccstr_t;\ntypedef const u8 *              bytes_t;\ntypedef const u8 * const        cbytes_t;\n\ntypedef u16                     m3opcode_t;\n\ntypedef i64                     m3reg_t;\n\n# if d_m3Use32BitSlots\ntypedef u32                     m3slot_t;\n# else\ntypedef u64                     m3slot_t;\n# endif\n\ntypedef m3slot_t *              m3stack_t;\n\ntypedef\nconst void * const  cvptr_t;\n\n# if defined (DEBUG)\n\n#   define d_m3Log(CATEGORY, FMT, ...)                  printf (\" %8s  |  \" FMT, #CATEGORY, ##__VA_ARGS__);\n\n#   if d_m3LogParse\n#       define m3log_parse(CATEGORY, FMT, ...)          d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_parse(...) {}\n#   endif\n\n#   if d_m3LogCompile\n#       define m3log_compile(CATEGORY, FMT, ...)        d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_compile(...) {}\n#   endif\n\n#   if d_m3LogEmit\n#       define m3log_emit(CATEGORY, FMT, ...)           d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_emit(...) {}\n#   endif\n\n#   if d_m3LogCodePages\n#       define m3log_code(CATEGORY, FMT, ...)           d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_code(...) {}\n#   endif\n\n#   if d_m3LogModule\n#       define m3log_module(CATEGORY, FMT, ...)         d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_module(...) {}\n#   endif\n\n#   if d_m3LogRuntime\n#       define m3log_runtime(CATEGORY, FMT, ...)        d_m3Log(CATEGORY, FMT, ##__VA_ARGS__)\n#   else\n#       define m3log_runtime(...) {}\n#   endif\n\n#   define m3log(CATEGORY, FMT, ...)                    m3log_##CATEGORY (CATEGORY, FMT \"\\n\", ##__VA_ARGS__)\n# else\n#   define d_m3Log(CATEGORY, FMT, ...)                  {}\n#   define m3log(CATEGORY, FMT, ...)                    {}\n# endif\n\n\n# if defined(ASSERTS) || (defined(DEBUG) && !defined(NASSERTS))\n#   define d_m3Assert(ASS)  if (!(ASS)) { printf(\"Assertion failed at %s:%d : %s\\n\", __FILE__, __LINE__, #ASS); abort(); }\n# else\n#   define d_m3Assert(ASS)\n# endif\n\ntypedef void /*const*/ *                    code_t;\ntypedef code_t const * /*__restrict__*/     pc_t;\n\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_tracer.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_tracer.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_tracer.c\n//\n//  Created by Volodymyr Shymanskyy on 02/18/20.\n//  Copyright © 2020 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#include \"m3_api_tracer.h\"\n\n#if defined(d_m3HasTracer)\n\n\nstatic FILE* trace = NULL;\n\nm3ApiRawFunction(m3_env_log_execution)\n{\n    m3ApiGetArg      (uint32_t, id)\n    fprintf(trace, \"exec;%d\\n\", id);\n    m3ApiSuccess();\n}\n\nm3ApiRawFunction(m3_env_log_exec_enter)\n{\n    m3ApiGetArg      (uint32_t, id)\n    m3ApiGetArg      (uint32_t, func)\n    fprintf(trace, \"enter;%d;%d\\n\", id, func);\n    m3ApiSuccess();\n}\n\nm3ApiRawFunction(m3_env_log_exec_exit)\n{\n    m3ApiGetArg      (uint32_t, id)\n    m3ApiGetArg      (uint32_t, func)\n    fprintf(trace, \"exit;%d;%d\\n\", id, func);\n    m3ApiSuccess();\n}\n\nm3ApiRawFunction(m3_env_log_exec_loop)\n{\n    m3ApiGetArg      (uint32_t, id)\n    fprintf(trace, \"loop;%d\\n\", id);\n    m3ApiSuccess();\n}\n\nm3ApiRawFunction(m3_env_load_ptr)\n{\n    m3ApiReturnType (uint32_t)\n    m3ApiGetArg      (uint32_t, id)\n    m3ApiGetArg      (uint32_t, align)\n    m3ApiGetArg      (uint32_t, offset)\n    m3ApiGetArg      (uint32_t, address)\n    fprintf(trace, \"load ptr;%d;%d;%d;%d\\n\", id, align, offset, address);\n    m3ApiReturn(address);\n}\n\nm3ApiRawFunction(m3_env_store_ptr)\n{\n    m3ApiReturnType (uint32_t)\n    m3ApiGetArg      (uint32_t, id)\n    m3ApiGetArg      (uint32_t, align)\n    m3ApiGetArg      (uint32_t, offset)\n    m3ApiGetArg      (uint32_t, address)\n    fprintf(trace, \"store ptr;%d;%d;%d;%d\\n\", id, align, offset, address);\n    m3ApiReturn(address);\n}\n\n\n#define d_m3TraceMemory(FUNC, NAME, TYPE, FMT)                \\\nm3ApiRawFunction(m3_env_##FUNC)                               \\\n{                                                             \\\n    m3ApiReturnType (TYPE)                                    \\\n    m3ApiGetArg      (uint32_t, id)                           \\\n    m3ApiGetArg      (TYPE,     val)                          \\\n    fprintf(trace, NAME \";%d;\" FMT \"\\n\", id, val);            \\\n    m3ApiReturn(val);                                         \\\n}\n\nd_m3TraceMemory( load_val_i32,  \"load i32\", int32_t, \"%\" PRIi32)\nd_m3TraceMemory(store_val_i32, \"store i32\", int32_t, \"%\" PRIi32)\nd_m3TraceMemory( load_val_i64,  \"load i64\", int64_t, \"%\" PRIi64)\nd_m3TraceMemory(store_val_i64, \"store i64\", int64_t, \"%\" PRIi64)\nd_m3TraceMemory( load_val_f32,  \"load f32\", float,   \"%\" PRIf32)\nd_m3TraceMemory(store_val_f32, \"store f32\", float,   \"%\" PRIf32)\nd_m3TraceMemory( load_val_f64,  \"load f64\", double,  \"%\" PRIf64)\nd_m3TraceMemory(store_val_f64, \"store f64\", double,  \"%\" PRIf64)\n\n\n#define d_m3TraceLocal(FUNC, NAME, TYPE, FMT)                 \\\nm3ApiRawFunction(m3_env_##FUNC)                               \\\n{                                                             \\\n    m3ApiReturnType (TYPE)                                    \\\n    m3ApiGetArg      (uint32_t, id)                           \\\n    m3ApiGetArg      (uint32_t, local)                        \\\n    m3ApiGetArg      (TYPE,     val)                          \\\n    fprintf(trace, NAME \";%d;%d;\" FMT \"\\n\", id, local, val); \\\n    m3ApiReturn(val);                                         \\\n}\n\n\nd_m3TraceLocal(get_i32, \"get i32\", int32_t, \"%\" PRIi32)\nd_m3TraceLocal(set_i32, \"set i32\", int32_t, \"%\" PRIi32)\nd_m3TraceLocal(get_i64, \"get i64\", int64_t, \"%\" PRIi64)\nd_m3TraceLocal(set_i64, \"set i64\", int64_t, \"%\" PRIi64)\nd_m3TraceLocal(get_f32, \"get f32\", float,   \"%\" PRIf32)\nd_m3TraceLocal(set_f32, \"set f32\", float,   \"%\" PRIf32)\nd_m3TraceLocal(get_f64, \"get f64\", double,  \"%\" PRIf64)\nd_m3TraceLocal(set_f64, \"set f64\", double,  \"%\" PRIf64)\n\n\nstatic\nM3Result SuppressLookupFailure(M3Result i_result)\n{\n    if (i_result == m3Err_none) {\n        // If any trace function is found in the module, open the trace file\n        if (!trace) {\n            trace = fopen (\"wasm3_trace.csv\",\"w\");\n        }\n    } else if (i_result == m3Err_functionLookupFailed) {\n        i_result = m3Err_none;\n    }\n    return i_result;\n}\n\n\nM3Result  m3_LinkTracer  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    const char* env  = \"env\";\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"log_execution\",       \"v(i)\",     &m3_env_log_execution)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"log_exec_enter\",      \"v(ii)\",    &m3_env_log_exec_enter)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"log_exec_exit\",       \"v(ii)\",    &m3_env_log_exec_exit)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"log_exec_loop\",       \"v(i)\",     &m3_env_log_exec_loop)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"load_ptr\",            \"i(iiii)\",  &m3_env_load_ptr)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"store_ptr\",           \"i(iiii)\",  &m3_env_store_ptr)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"load_val_i32\",        \"i(ii)\",    &m3_env_load_val_i32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"load_val_i64\",        \"I(iI)\",    &m3_env_load_val_i64)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"load_val_f32\",        \"f(if)\",    &m3_env_load_val_f32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"load_val_f64\",        \"F(iF)\",    &m3_env_load_val_f64)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"store_val_i32\",       \"i(ii)\",    &m3_env_store_val_i32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"store_val_i64\",       \"I(iI)\",    &m3_env_store_val_i64)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"store_val_f32\",       \"f(if)\",    &m3_env_store_val_f32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"store_val_f64\",       \"F(iF)\",    &m3_env_store_val_f64)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"get_i32\",             \"i(iii)\",   &m3_env_get_i32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"get_i64\",             \"I(iiI)\",   &m3_env_get_i64)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"get_f32\",             \"f(iif)\",   &m3_env_get_f32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"get_f64\",             \"F(iiF)\",   &m3_env_get_f64)));\n\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"set_i32\",             \"i(iii)\",   &m3_env_set_i32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"set_i64\",             \"I(iiI)\",   &m3_env_set_i64)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"set_f32\",             \"f(iif)\",   &m3_env_set_f32)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, env, \"set_f64\",             \"F(iiF)\",   &m3_env_set_f64)));\n\n_catch:\n    return result;\n}\n\n#endif // d_m3HasTracer\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_core.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_core.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_core.c\n//\n//  Created by Steven Massey on 4/15/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#define M3_IMPLEMENT_ERROR_STRINGS\n\n#include \"m3_core.h\"\n\n#include \"esp_debug_helpers.h\"\n#include \"esp_heap_caps.h\"\n#include \"esp_try.h\"\n\nvoid m3_Abort(const char* message) {\n#ifdef DEBUG\n    fprintf(stderr, \"Error: %s\\n\", message);\n#endif\n    abort();\n}\n\nM3_WEAK\nM3Result m3_Yield ()\n{\n    return m3Err_none;\n}\n\n#if d_m3LogTimestamps\n\n#include <time.h>\n\n#define SEC_TO_US(sec) ((sec)*1000000)\n#define NS_TO_US(ns)    ((ns)/1000)\n\nstatic uint64_t initial_ts = -1;\n\nuint64_t m3_GetTimestamp()\n{\n    if (initial_ts == -1) {\n        initial_ts = 0;\n        initial_ts = m3_GetTimestamp();\n    }\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    uint64_t us = SEC_TO_US((uint64_t)ts.tv_sec) + NS_TO_US((uint64_t)ts.tv_nsec);\n    return us - initial_ts;\n}\n\n#endif\n\n#if d_m3FixedHeap\n\nstatic u8 fixedHeap[d_m3FixedHeap];\nstatic u8* fixedHeapPtr = fixedHeap;\nstatic u8* const fixedHeapEnd = fixedHeap + d_m3FixedHeap;\nstatic u8* fixedHeapLast = NULL;\n\n#if d_m3FixedHeapAlign > 1\n#   define HEAP_ALIGN_PTR(P) P = (u8*)(((size_t)(P)+(d_m3FixedHeapAlign-1)) & ~ (d_m3FixedHeapAlign-1));\n#else\n#   define HEAP_ALIGN_PTR(P)\n#endif\n\n/*void *  m3_Malloc_Impl  (size_t i_size)\n{\n    u8 * ptr = fixedHeapPtr;\n\n    fixedHeapPtr += i_size;\n    HEAP_ALIGN_PTR(fixedHeapPtr);\n\n    if (fixedHeapPtr >= fixedHeapEnd)\n    {\n        return NULL;\n    }\n\n    memset (ptr, 0x0, i_size);\n    fixedHeapLast = ptr;\n\n    return ptr;\n}\n\nvoid  m3_Free_Impl  (void * i_ptr)\n{\n    // Handle the last chunk\n    if (i_ptr && i_ptr == fixedHeapLast) {\n        fixedHeapPtr = fixedHeapLast;\n        fixedHeapLast = NULL;\n    } else {\n        //printf(\"== free %p [failed]\\n\", io_ptr);\n    }\n}\n\nvoid *  m3_Realloc_Impl  (void * i_ptr, size_t i_newSize, size_t i_oldSize)\n{\n    if (M3_UNLIKELY(i_newSize == i_oldSize)) return i_ptr;\n\n    void * newPtr;\n\n    // Handle the last chunk\n    if (i_ptr && i_ptr == fixedHeapLast) {\n        fixedHeapPtr = fixedHeapLast + i_newSize;\n        HEAP_ALIGN_PTR(fixedHeapPtr);\n        if (fixedHeapPtr >= fixedHeapEnd)\n        {\n            return NULL;\n        }\n        newPtr = i_ptr;\n    } else {\n        newPtr = m3_Malloc_Impl(i_newSize);\n        if (!newPtr) {\n            return NULL;\n        }\n        if (i_ptr) {\n            memcpy(newPtr, i_ptr, i_oldSize);\n        }\n    }\n\n    if (i_newSize > i_oldSize) {\n        memset ((u8 *) newPtr + i_oldSize, 0x0, i_newSize - i_oldSize);\n    }\n\n    return newPtr;\n}*/\n\n#else\n\n#define DEBUG_MEMORY 1\n\n/*void* m3_Malloc_Impl(size_t i_size)\n{\n    if(DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_Malloc_Impl of size %d\", i_size);\n    return heap_caps_calloc(1, i_size, MALLOC_CAP_8BIT);\n\n    // Usa MALLOC_CAP_8BIT per memoria generale\n    // Prima prova con PSRAM se disponibile\n    void* ptr = heap_caps_malloc(i_size, MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM);\n    \n    if (!ptr) {\n        ESP_LOGW(\"WASM3\", \"SPIRAM realloc failed, trying internal memory\");\n        ptr = heap_caps_malloc(i_size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n    }\n\n    if (ptr) {\n        // Stessa pulizia incrementale\n        const size_t block_size = 1024;\n        uint8_t* p = (uint8_t*)ptr;\n        size_t remaining = i_size;\n        \n        while (remaining > 0) {\n            size_t to_clear = (remaining < block_size) ? remaining : block_size;\n            memset(p, 0, to_clear);\n            p += to_clear;\n            remaining -= to_clear;\n        }\n    }\n    return ptr;\n}\n\nvoid  m3_Free_Impl  (void * io_ptr)\n{\n    if(DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_Free_Impl\");\n    heap_caps_free(io_ptr);\n}*/\n\n/*void* m3_Realloc_Impl_old(void* i_ptr, size_t i_newSize, size_t i_oldSize)\n{\n    if(DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_Realloc_Impl from %d to %d bytes\", i_oldSize, i_newSize);\n    \n    if (M3_UNLIKELY(i_newSize == i_oldSize)) return i_ptr;\n\n    // Usa gli stessi flag di allocazione del malloc\n    void* newPtr = heap_caps_realloc(i_ptr, i_newSize, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL);\n\n    if (M3_LIKELY(newPtr))\n    {\n        if (i_newSize > i_oldSize) {\n            // Pulizia incrementale per blocchi grandi\n            const size_t remainingSize = i_newSize - i_oldSize;\n            const size_t block_size = 1024;\n            uint8_t* p = (uint8_t*)newPtr + i_oldSize;\n            size_t remaining = remainingSize;\n            \n            while (remaining > 0) {\n                size_t to_clear = (remaining < block_size) ? remaining : block_size;\n                memset(p, 0, to_clear);\n                p += to_clear;\n                remaining -= to_clear;\n            }\n        }\n        return newPtr;\n    }\n    return NULL;\n}*/\n\n/*void* m3_Realloc_Impl(void* i_ptr, size_t i_newSize, size_t i_oldSize)\n{\n    ESP_LOGI(\"WASM3\", \"Requesting realloc: old=%d new=%d\", i_oldSize, i_newSize);\n    \n    // Dimensione massima di un segmento\n    const size_t MAX_SEGMENT_SIZE = 32*1024; // 32KB\n    \n    // Se la richiesta è più piccola di un segmento, usa realloc normale\n    if (i_newSize <= MAX_SEGMENT_SIZE) {\n        return heap_caps_realloc(i_ptr, i_newSize, MALLOC_CAP_INTERNAL);\n    }\n    \n    // Calcola quanti segmenti servono\n    size_t num_segments = (i_newSize + MAX_SEGMENT_SIZE - 1) / MAX_SEGMENT_SIZE;\n    \n    // Alloca array di segmenti\n    void** segments = heap_caps_malloc(sizeof(void*) * num_segments, MALLOC_CAP_INTERNAL);\n    if (!segments) return NULL;\n    \n    bool success = true;\n    for (size_t i = 0; i < num_segments && success; i++) {\n        size_t segment_size = (i == num_segments-1) ? \n            (i_newSize - (i * MAX_SEGMENT_SIZE)) : MAX_SEGMENT_SIZE;\n            \n        segments[i] = heap_caps_malloc(segment_size, MALLOC_CAP_INTERNAL);\n        success = (segments[i] != NULL);\n    }\n    \n    if (!success) {\n        // Cleanup in caso di fallimento\n        for (size_t i = 0; i < num_segments; i++) {\n            if (segments[i]) heap_caps_free(segments[i]);\n        }\n        heap_caps_free(segments);\n        return NULL;\n    }\n    \n    // Copia i dati vecchi se necessario\n    if (i_ptr) {\n        size_t remaining = i_oldSize;\n        size_t offset = 0;\n        \n        while (remaining > 0) {\n            size_t seg_idx = offset / MAX_SEGMENT_SIZE;\n            size_t copy_size = (remaining > MAX_SEGMENT_SIZE) ? \n                MAX_SEGMENT_SIZE : remaining;\n                \n            memcpy(segments[seg_idx], \n                   (uint8_t*)i_ptr + offset, \n                   copy_size);\n                   \n            remaining -= copy_size;\n            offset += copy_size;\n        }\n        \n        heap_caps_free(i_ptr);\n    }\n    \n    return segments[0];  // Ritorna il primo segmento\n}*/\n\n#endif\n\n/*void *  m3_CopyMem  (const void * i_from, size_t i_size)\n{\n    if(DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_CopyMem\");\n    void * ptr = m3_Malloc(\"CopyMem\", i_size);\n    if (ptr) {\n        memcpy (ptr, i_from, i_size);\n    }\n    return ptr;\n}*/\n\n///\n/// General functions\n///\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\n///\n/// Segmented memory implementation\n///\n\nvoid print_memory_info(){\n    // Ottenere memoria libera totale e più grande blocco contiguo\n    size_t free_heap = heap_caps_get_free_size(MALLOC_CAP_DEFAULT);\n    size_t largest_block = heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT);\n\n    ESP_LOGI(\"WASM3\", \"Memoria totale libera: %d bytes\\n\", free_heap);\n    ESP_LOGI(\"WASM3\", \"Blocco contiguo più grande: %d bytes\\n\", largest_block);\n\n    // Per memoria interna (IRAM)\n    size_t free_internal = heap_caps_get_free_size(MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);\n    ESP_LOGI(\"WASM3\", \"Memoria interna libera: %d bytes\\n\", free_internal);\n\n    // Per vedere la frammentazione\n    multi_heap_info_t info;\n    heap_caps_get_info(&info, MALLOC_CAP_DEFAULT);\n    ESP_LOGI(\"WASM3\", \"Totale blocchi liberi: %d\\n\", info.total_free_bytes);\n    ESP_LOGI(\"WASM3\", \"Minima memoria libera: %d bytes\\n\", info.minimum_free_bytes);  \n}\n\nstatic const int CHECK_MEMORY_AVAILABLE = 0;\n//static const int WASM_ENABLE_SPI_MEM = 0;\n\nvoid *  m3_Int_CopyMem  (const void * i_from, size_t i_size)\n{\n    if(DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_CopyMem\");\n    void * ptr = m3_Malloc(\"CopyMem\", i_size);\n    if (ptr) {\n        memcpy (ptr, i_from, i_size);\n    }\n    return ptr;\n}\n\n// Allocatore di default che usa heap_caps\nstatic const int ALLOC_SHIFT_OF = 0; // 4\nstatic const bool WASM_DEBUG_ALLOCS = true;\n\nvoid* default_malloc(size_t size) {\n    if(WASM_DEBUG_ALLOCS) ESP_LOGI(\"WASM3\", \"default_malloc called size: %u\", size);\n\n    TRY {\n        if(CHECK_MEMORY_AVAILABLE){\n            print_memory_info();\n        }\n\n        void* ptr = WASM_ENABLE_SPI_MEM ? heap_caps_malloc(size, MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM) : NULL;\n        if (ptr == NULL) {\n            ptr = heap_caps_malloc(size + ALLOC_SHIFT_OF, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL); // | MALLOC_CAP_INTERNAL\n\n            if (ptr) {\n                memset(ptr, 0, size + ALLOC_SHIFT_OF);  // Zero-fill con padding\n            }\n        }\n\n        if(ptr == NULL){\n            ESP_LOGE(\"WASM3\", \"Failed to allocate memory of size %d\", size);\n            esp_backtrace_print(100);\n        }\n\n        return ptr;\n\n    } CATCH {\n        ESP_LOGE(\"WASM3\", \"default_malloc: Exception occurred during malloc: %s\", esp_err_to_name(last_error));\n        return NULL;\n    } \n    END_TRY;\n}\n\nstatic const bool WASM_DEBUG_DEFAULT_FREE = false;\nstatic const bool WAMS_DEFAULT_FREE_CHECK_FREEEABLE = true;\nvoid default_free(void* ptr) {\n    if(WASM_DEBUG_ALLOCS) ESP_LOGI(\"WASM3\", \"default_free called for %p\", ptr);\n\n    TRY {\n        if (!ptr) return;\n        \n        // Logging del puntatore prima della free\n        if(WASM_DEBUG_DEFAULT_FREE) ESP_LOGD(\"WASM3\", \"Attempting to free memory at %p\", ptr);\n        \n        bool notFreeToFree = false;\n        if (WAMS_DEFAULT_FREE_CHECK_FREEEABLE && !is_ptr_freeable(ptr)) {            \n            ESP_LOGW(\"WASM3\", \"default_free: is_ptr_freeable check failed for pointer\");\n            backtrace();\n            //notFreeToFree = true;\n            //return;\n        }\n\n        if(notFreeToFree) ESP_LOGW(\"WASM3\", \"default_free: theoretically, is_ptr_freeable check failed for pointer\");\n\n        if (!ultra_safe_free((void**)&ptr)) {\n            ESP_LOGW(\"WASM3\", \"Skipped unsafe free operation\");\n            return;\n        }\n    } CATCH {\n        ESP_LOGE(\"WASM3\", \"default_free: Exception occurred during free: %s\", esp_err_to_name(last_error));\n        //return ESP_FAIL;\n    }\n    END_TRY;\n}\n\nstatic const bool REALLOC_USE_MALLOC_IF_NEW = false;\nvoid* default_realloc(void* ptr, size_t new_size) {\n    if(WASM_DEBUG_ALLOCS) ESP_LOGI(\"WASM3\", \"default_realloc called for %p (size: %u)\", ptr, new_size);\n\n    TRY {\n        if((!ptr) || !ultra_safe_ptr_valid(ptr)){\n            ptr = default_malloc(new_size);\n            return ptr;\n        }\n\n        void* new_ptr = WASM_ENABLE_SPI_MEM ? heap_caps_realloc(ptr, new_size, MALLOC_CAP_8BIT | MALLOC_CAP_SPIRAM) : NULL;\n        if (new_ptr == NULL) {\n            if(REALLOC_USE_MALLOC_IF_NEW && ptr == NULL){\n                new_ptr = default_malloc(new_size);\n            }\n            else {\n                new_ptr = heap_caps_realloc(ptr, new_size, MALLOC_CAP_8BIT | MALLOC_CAP_INTERNAL); //  \n            }\n\n            if(new_ptr) {\n                memset(new_ptr, 0, new_size);\n            }\n        }\n\n        if (new_ptr == NULL){\n            ESP_LOGE(\"WASM3\", \"Failed to reallocate memory of size %zu\", new_size);\n            //esp_backtrace_print(100);\n        }\n\n        ptr = new_ptr;\n        return new_ptr;\n\n    } CATCH {\n        ESP_LOGE(\"WASM3\", \"default_realloc: Exception occurred during realloc: %s\", esp_err_to_name(last_error));\n        return ptr;\n    }\n    END_TRY;\n}\n\nvoid m3_SetMemoryAllocator(MemoryAllocator* allocator) {\n    current_allocator = allocator ? allocator : &default_allocator;\n}\n\n// Funzione per allocare un segmento specifico\n/*bool allocate_segment(M3Memory* memory, size_t segment_index) {\n    if (segment_index >= memory->num_segments || \n        memory->segments[segment_index].is_allocated) {\n        return false;\n    }\n\n    size_t segment_size = (segment_index == memory->num_segments - 1) ?\n        (memory->total_size - (segment_index * memory->segment_size)) :\n        memory->segment_size;\n\n    void* data = current_allocator->malloc(segment_size);\n    if (!data) return false;\n\n    memory->segments[segment_index].data = data;\n    memory->segments[segment_index].is_allocated = true;\n    memory->segments[segment_index].size = segment_size;\n    memset(data, 0, segment_size);\n\n    return true;\n}*/\n\nstatic const bool WASM_DEBUG_MALLOC_IMPL_BACKTRACE = false;\nvoid* m3_Malloc_Impl(size_t i_size) {\n    if(WASM_DEBUG_MALLOC_IMPL_BACKTRACE) esp_backtrace_print(100);\n\n    if (DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_Malloc_Impl of size %zu\", i_size);\n\n    M3Memory* memory = (M3Memory*)current_allocator->malloc(sizeof(M3Memory));\n    if (!memory) {\n        ESP_LOGE(\"WASM3\", \"Null M3Memory pointer\");\n        return NULL;\n    }\n\n    memory->segment_size = WASM_SEGMENT_SIZE;    \n    memory->total_size = i_size;\n    memory->num_segments = (i_size + memory->segment_size - 1) / memory->segment_size;\n    //memory->point = 0; // Moved to M3MemoryPoint\n\n    ESP_LOGI(\"WASM3\", \"m3_Malloc_Imp memory->segment_size = %zu\", memory->segment_size);\n\n    // Alloca array di strutture MemorySegment\n    memory->segments = (MemorySegment*)current_allocator->malloc(\n        memory->num_segments * sizeof(MemorySegment)\n    );\n    \n    if (!memory->segments) {\n        current_allocator->free(memory);\n        return NULL;\n    }\n\n    // Inizializza tutti i segmenti come non allocati\n    for (size_t i = 0; i < memory->num_segments; i++) {\n        memory->segments[i].data = NULL;\n        memory->segments[i].is_allocated = false;\n        //memory->segment_size = 0; //???\n    }\n\n    if (DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Returning memory pointer\");\n    //esp_backtrace_print(100); \n\n    return memory;\n}\n\nvoid m3_Free_Impl(void* io_ptr, bool isMemory) {\n    if (DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_Free_Impl\");\n\n    if (!is_ptr_freeable(&io_ptr) || io_ptr == NULL) return;\n\n    if (isMemory) {\n        M3Memory* memory = (M3Memory*)io_ptr;\n        \n        if (memory->segments) {\n            // Libera solo i segmenti effettivamente allocati\n            for (size_t i = 0; i < memory->num_segments; i++) {\n                if (memory->segments[i].is_allocated && memory->segments[i].data) {\n                    if(is_ptr_freeable(&memory->segments[i].data))\n                        current_allocator->free(memory->segments[i].data);\n                }\n            }\n\n            if(is_ptr_freeable(&memory->segments))\n                current_allocator->free(memory->segments);\n        }\n        \n        if(!is_ptr_freeable(&memory)){\n            ESP_LOGI(\"WASM3\", \"m3_Free_Impl: not safe to free memory\");\n        }\n\n        //current_allocator->free(memory); // DON'T do it (why?)\n    } else {\n        current_allocator->free(io_ptr);\n    }\n}\n\nvoid* m3_Realloc_Impl(void* i_ptr, size_t i_newSize, size_t i_oldSize) {\n    ESP_LOGI(\"WASM3\", \"Requesting realloc: old=%zu new=%zu\", i_oldSize, i_newSize);\n\n    //if (!i_ptr) return m3_Malloc_Impl(i_newSize); // this is kinda of stupid\n\n    if(i_ptr){\n        if (validate_pointer(i_ptr, sizeof(M3Memory)) == PTR_CHECK_OK) {\n            M3Memory* memory = (M3Memory*)i_ptr;\n            size_t new_num_segments = (i_newSize + memory->segment_size - 1) / memory->segment_size;\n\n            // Riallocare l'array dei segmenti se necessario\n            if (new_num_segments != memory->num_segments) {\n                MemorySegment* new_segments = current_allocator->realloc(\n                    memory->segments,\n                    new_num_segments * sizeof(MemorySegment)\n                );\n\n                if (!new_segments) return NULL;\n                \n                // Inizializza i nuovi segmenti se stiamo crescendo\n                for (size_t i = memory->num_segments; i < new_num_segments; i++) {\n                    new_segments[i].data = NULL;\n                    new_segments[i].is_allocated = false;\n                    //new_segments[i].size = 0;\n                }\n\n                // Libera i segmenti in eccesso se stiamo riducendo\n                for (size_t i = new_num_segments; i < memory->num_segments; i++) {\n                    if (new_segments[i].is_allocated && new_segments[i].data) {\n                        current_allocator->free(new_segments[i].data);\n                    }\n                }\n\n                memory->segments = new_segments;\n                memory->num_segments = new_num_segments;\n                memory->total_size = i_newSize;\n            }\n\n            return i_ptr;\n        }\n        else {\n            if(is_ptr_freeable(i_ptr)) current_allocator->free(i_ptr);\n            return current_allocator->realloc(i_ptr, i_newSize);\n        }        \n    }\n\n    return m3_Malloc_Impl(i_newSize);\n}\n\nvoid* m3_CopyMem(const void* i_from, size_t i_size) {\n    if (DEBUG_MEMORY) ESP_LOGI(\"WASM3\", \"Calling m3_CopyMem\");\n    if (!i_from) return NULL;\n\n    M3Memory* src_memory = (M3Memory*)i_from;\n    M3Memory* dst_memory = (M3Memory*)m3_Malloc_Impl(i_size);\n    \n    if (!dst_memory) return NULL;\n\n    // Copia i metadati\n    dst_memory->segment_size = src_memory->segment_size;\n    dst_memory->total_size = i_size;\n\n    // Copia solo i segmenti che sono effettivamente allocati\n    for (size_t i = 0; i < src_memory->num_segments && i < dst_memory->num_segments; i++) {\n        if (src_memory->segments[i].is_allocated) {\n            // Alloca e copia il segmento\n            if (allocate_segment(dst_memory, i)) {\n                size_t copy_size = M3_MIN(\n                    src_memory->segment_size,\n                    dst_memory->segment_size\n                );\n                memcpy(dst_memory->segments[i].data,\n                       src_memory->segments[i].data,\n                       copy_size);\n            }\n        }\n    }\n\n    return dst_memory;\n}\n\n//--------------------------------------------------------------------------------------------\n\n#if d_m3LogNativeStack\n\nstatic size_t stack_start;\nstatic size_t stack_end;\n\nvoid        m3StackCheckInit ()\n{\n    char stack;\n    stack_end = stack_start = (size_t)&stack;\n}\n\nvoid        m3StackCheck ()\n{\n    char stack;\n    size_t addr = (size_t)&stack;\n\n    size_t stackEnd = stack_end;\n    stack_end = M3_MIN (stack_end, addr);\n\n//    if (stackEnd != stack_end)\n//        printf (\"maxStack: %ld\\n\", m3StackGetMax ());\n}\n\nint      m3StackGetMax  ()\n{\n    return stack_start - stack_end;\n}\n\n#endif\n\n//--------------------------------------------------------------------------------------------\n\nM3Result NormalizeType (u8 * o_type, i8 i_convolutedWasmType)\n{\n    M3Result result = m3Err_none;\n\n    u8 type = -i_convolutedWasmType;\n\n    if (type == 0x40)\n        type = c_m3Type_none;\n    else if (type < c_m3Type_i32 or type > c_m3Type_f64)\n        result = m3Err_invalidTypeId;\n\n    * o_type = type;\n\n    return result;\n}\n\n\nbool  IsFpType  (u8 i_m3Type)\n{\n    return (i_m3Type == c_m3Type_f32 or i_m3Type == c_m3Type_f64);\n}\n\n\nbool  IsIntType  (u8 i_m3Type)\n{\n    return (i_m3Type == c_m3Type_i32 or i_m3Type == c_m3Type_i64);\n}\n\n\nbool  Is64BitType  (u8 i_m3Type)\n{\n    if (i_m3Type == c_m3Type_i64 or i_m3Type == c_m3Type_f64)\n        return true;\n    else if (i_m3Type == c_m3Type_i32 or i_m3Type == c_m3Type_f32 or i_m3Type == c_m3Type_none)\n        return false;\n    else\n        return (sizeof (voidptr_t) == 8); // all other cases are pointers\n}\n\nu32  SizeOfType  (u8 i_m3Type)\n{\n    if (i_m3Type == c_m3Type_i32 or i_m3Type == c_m3Type_f32)\n        return sizeof (i32);\n\n    return sizeof (i64);\n}\n\n\n//-- Binary Wasm parsing utils  ------------------------------------------------------------------------------------------\n\n\nM3Result  Read_u64  (u64 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n    ptr += sizeof (u64);\n\n    if (ptr <= i_end)\n    {\n        memcpy(o_value, * io_bytes, sizeof(u64));\n        M3_BSWAP_u64(*o_value);\n        * io_bytes = ptr;\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\n\nM3Result  Read_u32  (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n    ptr += sizeof (u32);\n\n    if (ptr <= i_end)\n    {\n        memcpy(o_value, * io_bytes, sizeof(u32));\n        M3_BSWAP_u32(*o_value);\n        * io_bytes = ptr;\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\n#if d_m3ImplementFloat\n\nM3Result  Read_f64  (f64 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n    ptr += sizeof (f64);\n\n    if (ptr <= i_end)\n    {\n        memcpy(o_value, * io_bytes, sizeof(f64));\n        M3_BSWAP_f64(*o_value);\n        * io_bytes = ptr;\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\n\nM3Result  Read_f32  (f32 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n    ptr += sizeof (f32);\n\n    if (ptr <= i_end)\n    {\n        memcpy(o_value, * io_bytes, sizeof(f32));\n        M3_BSWAP_f32(*o_value);\n        * io_bytes = ptr;\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\n#endif\n\nM3Result  Read_u8  (u8 * o_value, bytes_t  * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n\n    if (ptr < i_end)\n    {\n        * o_value = * ptr;\n        * io_bytes = ptr + 1;\n\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\nM3Result  Read_opcode  (m3opcode_t * o_value, bytes_t  * io_bytes, cbytes_t i_end)\n{\n    const u8 * ptr = * io_bytes;\n\n    if (ptr < i_end)\n    {\n        m3opcode_t opcode = * ptr++;\n\n#if d_m3CascadedOpcodes == 0\n        if (M3_UNLIKELY(opcode == c_waOp_extended))\n        {\n            if (ptr < i_end)\n            {\n                opcode = (opcode << 8) | (* ptr++);\n            }\n            else return m3Err_wasmUnderrun;\n        }\n#endif\n        * o_value = opcode;\n        * io_bytes = ptr;\n\n        return m3Err_none;\n    }\n    else return m3Err_wasmUnderrun;\n}\n\n\nM3Result  ReadLebUnsigned  (u64 * o_value, u32 i_maxNumBits, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_wasmUnderrun;\n\n    u64 value = 0;\n\n    u32 shift = 0;\n    const u8 * ptr = * io_bytes;\n\n    while (ptr < i_end)\n    {\n        u64 byte = * (ptr++);\n\n        value |= ((byte & 0x7f) << shift);\n        shift += 7;\n\n        if ((byte & 0x80) == 0)\n        {\n            result = m3Err_none;\n            break;\n        }\n\n        if (shift >= i_maxNumBits)\n        {\n            result = m3Err_lebOverflow;\n            break;\n        }\n    }\n\n    * o_value = value;\n    * io_bytes = ptr;\n\n    return result;\n}\n\n\nM3Result  ReadLebSigned  (i64 * o_value, u32 i_maxNumBits, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_wasmUnderrun;\n\n    i64 value = 0;\n\n    u32 shift = 0;\n    const u8 * ptr = * io_bytes;\n\n    while (ptr < i_end)\n    {\n        u64 byte = * (ptr++);\n\n        value |= ((byte & 0x7f) << shift);\n        shift += 7;\n\n        if ((byte & 0x80) == 0)\n        {\n            result = m3Err_none;\n\n            if ((byte & 0x40) and (shift < 64))    // do sign extension\n            {\n                u64 extend = 0;\n                value |= (~extend << shift);\n            }\n\n            break;\n        }\n\n        if (shift >= i_maxNumBits)\n        {\n            result = m3Err_lebOverflow;\n            break;\n        }\n    }\n\n    * o_value = value;\n    * io_bytes = ptr;\n\n    return result;\n}\n\n\nM3Result  ReadLEB_u32  (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    u64 value;\n    M3Result result = ReadLebUnsigned (& value, 32, io_bytes, i_end);\n    * o_value = (u32) value;\n\n    return result;\n}\n\n\nM3Result  ReadLEB_u7  (u8 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    u64 value;\n    M3Result result = ReadLebUnsigned (& value, 7, io_bytes, i_end);\n    * o_value = (u8) value;\n\n    return result;\n}\n\n\nM3Result  ReadLEB_i7  (i8 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    i64 value;\n    M3Result result = ReadLebSigned (& value, 7, io_bytes, i_end);\n    * o_value = (i8) value;\n\n    return result;\n}\n\n\nM3Result  ReadLEB_i32  (i32 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    i64 value;\n    M3Result result = ReadLebSigned (& value, 32, io_bytes, i_end);\n    * o_value = (i32) value;\n\n    return result;\n}\n\n\nM3Result  ReadLEB_i64  (i64 * o_value, bytes_t * io_bytes, cbytes_t i_end)\n{\n    i64 value;\n    M3Result result = ReadLebSigned (& value, 64, io_bytes, i_end);\n    * o_value = value;\n\n    return result;\n}\n\n\nM3Result  Read_utf8  (cstr_t * o_utf8, bytes_t * io_bytes, cbytes_t i_end)\n{\n    *o_utf8 = NULL;\n\n    u32 utf8Length;\n    M3Result result = ReadLEB_u32 (& utf8Length, io_bytes, i_end);\n\n    if (not result)\n    {\n        if (utf8Length <= d_m3MaxSaneUtf8Length)\n        {\n            const u8 * ptr = * io_bytes;\n            const u8 * end = ptr + utf8Length;\n\n            if (end <= i_end)\n            {\n                char * utf8 = (char *)m3_Int_Malloc (\"UTF8\", utf8Length + 1);\n\n                if (utf8)\n                {\n                    memcpy (utf8, ptr, utf8Length);\n                    utf8 [utf8Length] = 0;\n                    * o_utf8 = utf8;\n                }\n\n                * io_bytes = end;\n            }\n            else result = m3Err_wasmUnderrun;\n        }\n        else result = m3Err_missingUTF8;\n    }\n\n    return result;\n}\n\n#if d_m3RecordBacktraces\nu32  FindModuleOffset  (IM3Runtime i_runtime, pc_t i_pc)\n{\n    // walk the code pages\n    IM3CodePage curr = i_runtime->pagesOpen;\n    bool pageFound = false;\n\n    while (curr)\n    {\n        if (ContainsPC (curr, i_pc))\n        {\n            pageFound = true;\n            break;\n        }\n        curr = curr->info.next;\n    }\n\n    if (!pageFound)\n    {\n        curr = i_runtime->pagesFull;\n        while (curr)\n        {\n            if (ContainsPC (curr, i_pc))\n            {\n                pageFound = true;\n                break;\n            }\n            curr = curr->info.next;\n        }\n    }\n\n    if (pageFound)\n    {\n        u32 result = 0;\n\n        bool pcFound = MapPCToOffset (curr, i_pc, & result);\n                                                                                d_m3Assert (pcFound);\n\n        return result;\n    }\n    else return 0;\n}\n\n\nvoid  PushBacktraceFrame  (IM3Runtime io_runtime, pc_t i_pc)\n{\n    // don't try to push any more frames if we've already had an alloc failure\n    if (M3_UNLIKELY (io_runtime->backtrace.lastFrame == M3_BACKTRACE_TRUNCATED))\n        return;\n\n    M3BacktraceFrame * newFrame = m3_AllocStruct(M3BacktraceFrame);\n\n    if (!newFrame)\n    {\n        io_runtime->backtrace.lastFrame = M3_BACKTRACE_TRUNCATED;\n        return;\n    }\n\n    newFrame->moduleOffset = FindModuleOffset (io_runtime, i_pc);\n\n    if (!io_runtime->backtrace.frames || !io_runtime->backtrace.lastFrame)\n        io_runtime->backtrace.frames = newFrame;\n    else\n        io_runtime->backtrace.lastFrame->next = newFrame;\n    io_runtime->backtrace.lastFrame = newFrame;\n}\n\n\nvoid  FillBacktraceFunctionInfo  (IM3Runtime io_runtime, IM3Function i_function)\n{\n    // If we've had an alloc failure then the last frame doesn't refer to the\n    // frame we want to fill in the function info for.\n    if (M3_UNLIKELY (io_runtime->backtrace.lastFrame == M3_BACKTRACE_TRUNCATED))\n        return;\n\n    if (!io_runtime->backtrace.lastFrame)\n        return;\n\n    io_runtime->backtrace.lastFrame->function = i_function;\n}\n\n\nvoid  ClearBacktrace  (IM3Runtime io_runtime)\n{\n    M3BacktraceFrame * currentFrame = io_runtime->backtrace.frames;\n    while (currentFrame)\n    {\n        M3BacktraceFrame * nextFrame = currentFrame->next;\n        m3_Free (currentFrame);\n        currentFrame = nextFrame;\n    }\n\n    io_runtime->backtrace.frames = NULL;\n    io_runtime->backtrace.lastFrame = NULL;\n}\n#endif // d_m3RecordBacktraces\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_wasi.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_wasi.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_wasi.c\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#define _POSIX_C_SOURCE 200809L\n\n#include \"m3_api_wasi.h\"\n\n#if defined(d_m3HasWASI)\n\n// Fixup wasi_core.h\n#if defined (M3_COMPILER_MSVC)\n#  define _Static_assert(...)\n#  define __attribute__(...)\n#  define _Noreturn\n#endif\n\n#include \"extra/wasi_core.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#if defined(APE)\n// Actually Portable Executable\n// All functions are already included in cosmopolitan.h\n#elif defined(__wasi__) || defined(__APPLE__) || defined(__ANDROID_API__) || defined(__OpenBSD__) || defined(__linux__) || defined(__EMSCRIPTEN__) || defined(__CYGWIN__)\n#  include <unistd.h>\n#  include <sys/uio.h>\n#  if defined(__APPLE__)\n#      include <TargetConditionals.h>\n#      if TARGET_OS_OSX // TARGET_OS_MAC includes iOS\n#          include <sys/random.h>\n#      else // iOS / Simulator\n#          include <Security/Security.h>\n#      endif\n#  else\n#      include <sys/random.h>\n#  endif\n#  define HAS_IOVEC\n#elif defined(_WIN32)\n#  include <Windows.h>\n#  include <io.h>\n// See http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx\n#  define SystemFunction036 NTAPI SystemFunction036\n#  include <NTSecAPI.h>\n#  undef SystemFunction036\n#  define ssize_t SSIZE_T\n\n#  define open  _open\n#  define read  _read\n#  define write _write\n#  define close _close\n#endif\n\nstatic m3_wasi_context_t* wasi_context;\n\ntypedef struct wasi_iovec_t\n{\n    __wasi_size_t buf;\n    __wasi_size_t buf_len;\n} wasi_iovec_t;\n\n#define PREOPEN_CNT   5\n\ntypedef struct Preopen {\n    int         fd;\n    const char* path;\n    const char* real_path;\n} Preopen;\n\nPreopen preopen[PREOPEN_CNT] = {\n    {  0, \"<stdin>\" , \"\" },\n    {  1, \"<stdout>\", \"\" },\n    {  2, \"<stderr>\", \"\" },\n    { -1, \"/\"       , \".\" },\n    { -1, \"./\"      , \".\" },\n};\n\n#if defined(APE)\n#  define APE_SWITCH_BEG\n#  define APE_SWITCH_END          {}\n#  define APE_CASE_RET(e1,e2)     if (errnum == e1)    return e2;   else\n#else\n#  define APE_SWITCH_BEG          switch (errnum) {\n#  define APE_SWITCH_END          }\n#  define APE_CASE_RET(e1,e2)     case e1:   return e2;   break;\n#endif\n\nstatic\n__wasi_errno_t errno_to_wasi(int errnum) {\n    APE_SWITCH_BEG\n    APE_CASE_RET( EPERM   , __WASI_ERRNO_PERM   )\n    APE_CASE_RET( ENOENT  , __WASI_ERRNO_NOENT  )\n    APE_CASE_RET( ESRCH   , __WASI_ERRNO_SRCH   )\n    APE_CASE_RET( EINTR   , __WASI_ERRNO_INTR   )\n    APE_CASE_RET( EIO     , __WASI_ERRNO_IO     )\n    APE_CASE_RET( ENXIO   , __WASI_ERRNO_NXIO   )\n    APE_CASE_RET( E2BIG   , __WASI_ERRNO_2BIG   )\n    APE_CASE_RET( ENOEXEC , __WASI_ERRNO_NOEXEC )\n    APE_CASE_RET( EBADF   , __WASI_ERRNO_BADF   )\n    APE_CASE_RET( ECHILD  , __WASI_ERRNO_CHILD  )\n    APE_CASE_RET( EAGAIN  , __WASI_ERRNO_AGAIN  )\n    APE_CASE_RET( ENOMEM  , __WASI_ERRNO_NOMEM  )\n    APE_CASE_RET( EACCES  , __WASI_ERRNO_ACCES  )\n    APE_CASE_RET( EFAULT  , __WASI_ERRNO_FAULT  )\n    APE_CASE_RET( EBUSY   , __WASI_ERRNO_BUSY   )\n    APE_CASE_RET( EEXIST  , __WASI_ERRNO_EXIST  )\n    APE_CASE_RET( EXDEV   , __WASI_ERRNO_XDEV   )\n    APE_CASE_RET( ENODEV  , __WASI_ERRNO_NODEV  )\n    APE_CASE_RET( ENOTDIR , __WASI_ERRNO_NOTDIR )\n    APE_CASE_RET( EISDIR  , __WASI_ERRNO_ISDIR  )\n    APE_CASE_RET( EINVAL  , __WASI_ERRNO_INVAL  )\n    APE_CASE_RET( ENFILE  , __WASI_ERRNO_NFILE  )\n    APE_CASE_RET( EMFILE  , __WASI_ERRNO_MFILE  )\n    APE_CASE_RET( ENOTTY  , __WASI_ERRNO_NOTTY  )\n    APE_CASE_RET( ETXTBSY , __WASI_ERRNO_TXTBSY )\n    APE_CASE_RET( EFBIG   , __WASI_ERRNO_FBIG   )\n    APE_CASE_RET( ENOSPC  , __WASI_ERRNO_NOSPC  )\n    APE_CASE_RET( ESPIPE  , __WASI_ERRNO_SPIPE  )\n    APE_CASE_RET( EROFS   , __WASI_ERRNO_ROFS   )\n    APE_CASE_RET( EMLINK  , __WASI_ERRNO_MLINK  )\n    APE_CASE_RET( EPIPE   , __WASI_ERRNO_PIPE   )\n    APE_CASE_RET( EDOM    , __WASI_ERRNO_DOM    )\n    APE_CASE_RET( ERANGE  , __WASI_ERRNO_RANGE  )\n    APE_SWITCH_END\n    return __WASI_ERRNO_INVAL;\n}\n\n#if defined(_WIN32)\n\n#if !defined(__MINGW32__)\n\nstatic inline\nint clock_gettime(int clk_id, struct timespec *spec)\n{\n    __int64 wintime; GetSystemTimeAsFileTime((FILETIME*)&wintime);\n    wintime      -= 116444736000000000i64;           //1jan1601 to 1jan1970\n    spec->tv_sec  = wintime / 10000000i64;           //seconds\n    spec->tv_nsec = wintime % 10000000i64 *100;      //nano-seconds\n    return 0;\n}\n\nstatic inline\nint clock_getres(int clk_id, struct timespec *spec) {\n    return -1; // Defaults to 1000000\n}\n\n#endif\n\nstatic inline\nint convert_clockid(__wasi_clockid_t in) {\n    return 0;\n}\n\n#else // _WIN32\n\nstatic inline\nint convert_clockid(__wasi_clockid_t in) {\n    switch (in) {\n    case __WASI_CLOCKID_MONOTONIC:            return CLOCK_MONOTONIC;\n    case __WASI_CLOCKID_PROCESS_CPUTIME_ID:   return CLOCK_PROCESS_CPUTIME_ID;\n    case __WASI_CLOCKID_REALTIME:             return CLOCK_REALTIME;\n    case __WASI_CLOCKID_THREAD_CPUTIME_ID:    return CLOCK_THREAD_CPUTIME_ID;\n    default: return -1;\n    }\n}\n\n#endif // _WIN32\n\nstatic inline\n__wasi_timestamp_t convert_timespec(const struct timespec *ts) {\n    if (ts->tv_sec < 0)\n        return 0;\n    if ((__wasi_timestamp_t)ts->tv_sec >= UINT64_MAX / 1000000000)\n        return UINT64_MAX;\n    return (__wasi_timestamp_t)ts->tv_sec * 1000000000 + ts->tv_nsec;\n}\n\n#if defined(HAS_IOVEC)\n\nstatic inline\nconst void* copy_iov_to_host(IM3Runtime runtime, void* _mem, struct iovec* host_iov, wasi_iovec_t* wasi_iov, int32_t iovs_len)\n{\n    // Convert wasi memory offsets to host addresses\n    for (int i = 0; i < iovs_len; i++) {\n        host_iov[i].iov_base = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iov[i].buf));\n        host_iov[i].iov_len  = m3ApiReadMem32(&wasi_iov[i].buf_len);\n        m3ApiCheckMem(host_iov[i].iov_base,     host_iov[i].iov_len);\n    }\n    m3ApiSuccess();\n}\n\n#endif\n\n/*\n * WASI API implementation\n */\n\nm3ApiRawFunction(m3_wasi_generic_args_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , argv)\n    m3ApiGetArgMem   (char *               , argv_buf)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    m3ApiCheckMem(argv, context->argc * sizeof(uint32_t));\n\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        m3ApiWriteMem32(&argv[i], m3ApiPtrToOffset(argv_buf));\n\n        size_t len = strlen (context->argv[i]);\n\n        m3ApiCheckMem(argv_buf, len);\n        memcpy (argv_buf, context->argv[i], len);\n        argv_buf += len;\n        * argv_buf++ = 0;\n    }\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_args_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , argc)\n    m3ApiGetArgMem   (__wasi_size_t *      , argv_buf_size)\n\n    m3ApiCheckMem(argc,             sizeof(__wasi_size_t));\n    m3ApiCheckMem(argv_buf_size,    sizeof(__wasi_size_t));\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    __wasi_size_t buf_len = 0;\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        buf_len += strlen (context->argv[i]) + 1;\n    }\n\n    m3ApiWriteMem32(argc, context->argc);\n    m3ApiWriteMem32(argv_buf_size, buf_len);\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , env)\n    m3ApiGetArgMem   (char *               , env_buf)\n\n    // TODO\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_count)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_buf_size)\n\n    m3ApiCheckMem(env_count,    sizeof(__wasi_size_t));\n    m3ApiCheckMem(env_buf_size, sizeof(__wasi_size_t));\n\n    // TODO\n    m3ApiWriteMem32(env_count,    0);\n    m3ApiWriteMem32(env_buf_size, 0);\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_dir_name)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (char *               , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    if (fd < 3 || fd >= PREOPEN_CNT) { m3ApiReturn(__WASI_ERRNO_BADF); }\n    size_t slen = strlen(preopen[fd].path) + 1;\n    memcpy(path, preopen[fd].path, M3_MIN(slen, path_len));\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 8);\n\n    if (fd < 3 || fd >= PREOPEN_CNT) { m3ApiReturn(__WASI_ERRNO_BADF); }\n\n    m3ApiWriteMem32(buf+0, __WASI_PREOPENTYPE_DIR);\n    m3ApiWriteMem32(buf+4, strlen(preopen[fd].path) + 1);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_fdstat_t *    , fdstat)\n\n    m3ApiCheckMem(fdstat, sizeof(__wasi_fdstat_t));\n\n#ifdef _WIN32\n\n    // TODO: This needs a proper implementation\n    if (fd < PREOPEN_CNT) {\n        fdstat->fs_filetype= __WASI_FILETYPE_DIRECTORY;\n    } else {\n        fdstat->fs_filetype= __WASI_FILETYPE_REGULAR_FILE;\n    }\n\n    fdstat->fs_flags = 0;\n    fdstat->fs_rights_base = (uint64_t)-1; // all rights\n    fdstat->fs_rights_inheriting = (uint64_t)-1; // all rights\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#else\n    struct stat fd_stat;\n\n#if !defined(APE) // TODO: not implemented in Cosmopolitan\n    int fl = fcntl(fd, F_GETFL);\n    if (fl < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n#endif\n\n    fstat(fd, &fd_stat);\n    int mode = fd_stat.st_mode;\n    fdstat->fs_filetype = (S_ISBLK(mode)   ? __WASI_FILETYPE_BLOCK_DEVICE     : 0) |\n                          (S_ISCHR(mode)   ? __WASI_FILETYPE_CHARACTER_DEVICE : 0) |\n                          (S_ISDIR(mode)   ? __WASI_FILETYPE_DIRECTORY        : 0) |\n                          (S_ISREG(mode)   ? __WASI_FILETYPE_REGULAR_FILE     : 0) |\n                          //(S_ISSOCK(mode)  ? __WASI_FILETYPE_SOCKET_STREAM    : 0) |\n                          (S_ISLNK(mode)   ? __WASI_FILETYPE_SYMBOLIC_LINK    : 0);\n#if !defined(APE)\n    m3ApiWriteMem16(&fdstat->fs_flags,\n                       ((fl & O_APPEND)    ? __WASI_FDFLAGS_APPEND    : 0) |\n                       ((fl & O_DSYNC)     ? __WASI_FDFLAGS_DSYNC     : 0) |\n                       ((fl & O_NONBLOCK)  ? __WASI_FDFLAGS_NONBLOCK  : 0) |\n                       //((fl & O_RSYNC)     ? __WASI_FDFLAGS_RSYNC     : 0) |\n                       ((fl & O_SYNC)      ? __WASI_FDFLAGS_SYNC      : 0));\n#endif // APE\n\n    fdstat->fs_rights_base = (uint64_t)-1; // all rights\n\n    // Make descriptors 0,1,2 look like a TTY\n    if (fd <= 2) {\n        fdstat->fs_rights_base &= ~(__WASI_RIGHTS_FD_SEEK | __WASI_RIGHTS_FD_TELL);\n    }\n\n    fdstat->fs_rights_inheriting = (uint64_t)-1; // all rights\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#endif\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_flags)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_fdflags_t     , flags)\n\n    // TODO\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    int whence;\n\n    switch (wasi_whence) {\n    case 0: whence = SEEK_CUR; break;\n    case 1: whence = SEEK_END; break;\n    case 2: whence = SEEK_SET; break;\n    default:                m3ApiReturn(__WASI_ERRNO_INVAL);\n    }\n\n    int64_t ret;\n#if defined(M3_COMPILER_MSVC) || defined(__MINGW32__)\n    ret = _lseeki64(fd, offset, whence);\n#else\n    ret = lseek(fd, offset, whence);\n#endif\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem64(result, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    int whence;\n\n    switch (wasi_whence) {\n    case 0: whence = SEEK_SET; break;\n    case 1: whence = SEEK_CUR; break;\n    case 2: whence = SEEK_END; break;\n    default:                m3ApiReturn(__WASI_ERRNO_INVAL);\n    }\n\n    int64_t ret;\n#if defined(M3_COMPILER_MSVC) || defined(__MINGW32__)\n    ret = _lseeki64(fd, offset, whence);\n#else\n    ret = lseek(fd, offset, whence);\n#endif\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem64(result, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\n\nm3ApiRawFunction(m3_wasi_generic_path_open)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , dirfd)\n    m3ApiGetArg      (__wasi_lookupflags_t , dirflags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n    m3ApiGetArg      (__wasi_oflags_t      , oflags)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_base)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_inheriting)\n    m3ApiGetArg      (__wasi_fdflags_t     , fs_flags)\n    m3ApiGetArgMem   (__wasi_fd_t *        , fd)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(fd,   sizeof(__wasi_fd_t));\n\n    if (path_len >= 512)\n        m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    // copy path so we can ensure it is NULL terminated\n#if defined(M3_COMPILER_MSVC)\n    char host_path[512];\n#else\n    char host_path[path_len+1];\n#endif\n    memcpy (host_path, path, path_len);\n    host_path[path_len] = '\\0'; // NULL terminator\n\n#if defined(APE)\n    // TODO: This all needs a proper implementation\n\n    int flags = ((oflags & __WASI_OFLAGS_CREAT)             ? O_CREAT     : 0) |\n                ((oflags & __WASI_OFLAGS_EXCL)              ? O_EXCL      : 0) |\n                ((oflags & __WASI_OFLAGS_TRUNC)             ? O_TRUNC     : 0) |\n                ((fs_flags & __WASI_FDFLAGS_APPEND)     ? O_APPEND    : 0);\n\n    if ((fs_rights_base & __WASI_RIGHTS_FD_READ) &&\n        (fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= O_RDWR;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= O_WRONLY;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_READ)) {\n        flags |= O_RDONLY; // no-op because O_RDONLY is 0\n    }\n    int mode = 0644;\n\n    int host_fd = open (host_path, flags, mode);\n\n    if (host_fd < 0)\n    {\n        m3ApiReturn(errno_to_wasi (errno));\n    }\n    else\n    {\n        m3ApiWriteMem32(fd, host_fd);\n        m3ApiReturn(__WASI_ERRNO_SUCCESS);\n    }\n#elif defined(_WIN32)\n    // TODO: This all needs a proper implementation\n\n    int flags = ((oflags & __WASI_OFLAGS_CREAT)             ? _O_CREAT     : 0) |\n                ((oflags & __WASI_OFLAGS_EXCL)              ? _O_EXCL      : 0) |\n                ((oflags & __WASI_OFLAGS_TRUNC)             ? _O_TRUNC     : 0) |\n                ((fs_flags & __WASI_FDFLAGS_APPEND)         ? _O_APPEND    : 0) |\n                _O_BINARY;\n\n    if ((fs_rights_base & __WASI_RIGHTS_FD_READ) &&\n        (fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= _O_RDWR;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= _O_WRONLY;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_READ)) {\n        flags |= _O_RDONLY; // no-op because O_RDONLY is 0\n    }\n    int mode = 0644;\n\n    int host_fd = open (host_path, flags, mode);\n\n    if (host_fd < 0)\n    {\n        m3ApiReturn(errno_to_wasi (errno));\n    }\n    else\n    {\n        m3ApiWriteMem32(fd, host_fd);\n        m3ApiReturn(__WASI_ERRNO_SUCCESS);\n    }\n#else\n    // translate o_flags and fs_flags into flags and mode\n    int flags = ((oflags & __WASI_OFLAGS_CREAT)             ? O_CREAT     : 0) |\n                //((oflags & __WASI_OFLAGS_DIRECTORY)         ? O_DIRECTORY : 0) |\n                ((oflags & __WASI_OFLAGS_EXCL)              ? O_EXCL      : 0) |\n                ((oflags & __WASI_OFLAGS_TRUNC)             ? O_TRUNC     : 0) |\n                ((fs_flags & __WASI_FDFLAGS_APPEND)     ? O_APPEND    : 0) |\n                ((fs_flags & __WASI_FDFLAGS_DSYNC)      ? O_DSYNC     : 0) |\n                ((fs_flags & __WASI_FDFLAGS_NONBLOCK)   ? O_NONBLOCK  : 0) |\n                //((fs_flags & __WASI_FDFLAGS_RSYNC)      ? O_RSYNC     : 0) |\n                ((fs_flags & __WASI_FDFLAGS_SYNC)       ? O_SYNC      : 0);\n    if ((fs_rights_base & __WASI_RIGHTS_FD_READ) &&\n        (fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= O_RDWR;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_WRITE)) {\n        flags |= O_WRONLY;\n    } else if ((fs_rights_base & __WASI_RIGHTS_FD_READ)) {\n        flags |= O_RDONLY; // no-op because O_RDONLY is 0\n    }\n    int mode = 0644;\n    int host_fd = openat (preopen[dirfd].fd, host_path, flags, mode);\n\n    if (host_fd < 0)\n    {\n        m3ApiReturn(errno_to_wasi (errno));\n    }\n    else\n    {\n        m3ApiWriteMem32(fd, host_fd);\n        m3ApiReturn(__WASI_ERRNO_SUCCESS);\n    }\n#endif\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_read)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(__wasi_size_t));\n\n#if defined(HAS_IOVEC)\n    struct iovec iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n\n    ssize_t ret = readv(fd, iovs, iovs_len);\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem32(nread, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#else\n    ssize_t res = 0;\n    for (__wasi_size_t i = 0; i < iovs_len; i++) {\n        void* addr = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        size_t len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        if (len == 0) continue;\n        m3ApiCheckMem(addr,     len);\n        int ret = read (fd, addr, len);\n        if (ret < 0) m3ApiReturn(errno_to_wasi(errno));\n        res += ret;\n        if ((size_t)ret < len) break;\n    }\n    m3ApiWriteMem32(nread, res);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#endif\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_write)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(__wasi_size_t));\n\n#if defined(HAS_IOVEC)\n    struct iovec iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n\n    ssize_t ret = writev(fd, iovs, iovs_len);\n    if (ret < 0) { m3ApiReturn(errno_to_wasi(errno)); }\n    m3ApiWriteMem32(nwritten, ret);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#else\n    ssize_t res = 0;\n    for (__wasi_size_t i = 0; i < iovs_len; i++) {\n        void* addr = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        size_t len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        if (len == 0) continue;\n        m3ApiCheckMem(addr,     len);\n        int ret = write (fd, addr, len);\n        if (ret < 0) m3ApiReturn(errno_to_wasi(errno));\n        res += ret;\n        if ((size_t)ret < len) break;\n    }\n    m3ApiWriteMem32(nwritten, res);\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n#endif\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_close)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n    int ret = close(fd);\n    m3ApiReturn(ret == 0 ? __WASI_ERRNO_SUCCESS : ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_datasync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n#if defined(_WIN32)\n    int ret = _commit(fd);\n#elif defined(__APPLE__)\n    int ret = fsync(fd);\n#elif defined(__ANDROID_API__) || defined(__OpenBSD__) || defined(__linux__) || defined(__EMSCRIPTEN__)\n    int ret = fdatasync(fd);\n#else\n    int ret = __WASI_ERRNO_NOSYS;\n#endif\n    m3ApiReturn(ret == 0 ? __WASI_ERRNO_SUCCESS : ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_random_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n    m3ApiGetArg      (__wasi_size_t        , buf_len)\n\n    m3ApiCheckMem(buf, buf_len);\n\n    while (1) {\n        ssize_t retlen = 0;\n\n#if defined(__wasi__) || defined(__APPLE__) || defined(__ANDROID_API__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)\n        size_t reqlen = M3_MIN (buf_len, 256);\n#   if defined(__APPLE__) && (TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR)\n        retlen = SecRandomCopyBytes(kSecRandomDefault, reqlen, buf) < 0 ? -1 : reqlen;\n#   else\n        retlen = getentropy(buf, reqlen) < 0 ? -1 : reqlen;\n#   endif\n#elif defined(__FreeBSD__) || defined(__linux__)\n        retlen = getrandom(buf, buf_len, 0);\n#elif defined(_WIN32)\n        if (RtlGenRandom(buf, buf_len) == TRUE) {\n            m3ApiReturn(__WASI_ERRNO_SUCCESS);\n        }\n#else\n        m3ApiReturn(__WASI_ERRNO_NOSYS);\n#endif\n        if (retlen < 0) {\n            if (errno == EINTR || errno == EAGAIN) {\n                continue;\n            }\n            m3ApiReturn(errno_to_wasi(errno));\n        } else if (retlen == buf_len) {\n            m3ApiReturn(__WASI_ERRNO_SUCCESS);\n        } else {\n            buf     += retlen;\n            buf_len -= retlen;\n        }\n    }\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_res_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , resolution)\n\n    m3ApiCheckMem(resolution, sizeof(__wasi_timestamp_t));\n\n    int clk = convert_clockid(wasi_clk_id);\n    if (clk < 0) m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    struct timespec tp;\n    if (clock_getres(clk, &tp) != 0) {\n        m3ApiWriteMem64(resolution, 1000000);\n    } else {\n        m3ApiWriteMem64(resolution, convert_timespec(&tp));\n    }\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_time_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArg      (__wasi_timestamp_t   , precision)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , time)\n\n    m3ApiCheckMem(time, sizeof(__wasi_timestamp_t));\n\n    int clk = convert_clockid(wasi_clk_id);\n    if (clk < 0) m3ApiReturn(__WASI_ERRNO_INVAL);\n\n    struct timespec tp;\n    if (clock_gettime(clk, &tp) != 0) {\n        m3ApiReturn(errno_to_wasi(errno));\n    }\n\n    m3ApiWriteMem64(time, convert_timespec(&tp));\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_exit)\n{\n    m3ApiGetArg      (uint32_t, code)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context) {\n        context->exit_code = code;\n    }\n\n    m3ApiTrap(m3Err_trapExit);\n}\n\n\nstatic\nM3Result SuppressLookupFailure(M3Result i_result)\n{\n    if (i_result == m3Err_functionLookupFailed)\n        return m3Err_none;\n    else\n        return i_result;\n}\n\nm3_wasi_context_t* m3_GetWasiContext()\n{\n    return wasi_context;\n}\n\n\nM3Result  m3_LinkWASI  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n#ifdef _WIN32\n    setmode(fileno(stdin),  O_BINARY);\n    setmode(fileno(stdout), O_BINARY);\n    setmode(fileno(stderr), O_BINARY);\n\n#else\n    // Preopen dirs\n    for (int i = 3; i < PREOPEN_CNT; i++) {\n        preopen[i].fd = open(preopen[i].real_path, O_RDONLY);\n    }\n#endif\n\n    if (!wasi_context) {\n        wasi_context = (m3_wasi_context_t*)malloc(sizeof(m3_wasi_context_t));\n        wasi_context->exit_code = 0;\n        wasi_context->argc = 0;\n        wasi_context->argv = 0;\n    }\n\n    static const char* namespaces[2] = { \"wasi_unstable\", \"wasi_snapshot_preview1\" };\n\n    // Some functions are incompatible between WASI versions\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_seek\",     \"i(iIi*)\", &m3_wasi_unstable_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_seek\",     \"i(iIi*)\", &m3_wasi_snapshot_preview1_fd_seek)));\n//_ (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_unstable_fd_filestat_get)));\n//_ (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_snapshot_preview1_fd_filestat_get)));\n//_ (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_unstable_path_filestat_get)));\n//_ (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_snapshot_preview1_path_filestat_get)));\n\n    for (int i=0; i<2; i++)\n    {\n        const char* wasi = namespaces[i];\n\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_get\",           \"i(**)\",   &m3_wasi_generic_args_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_sizes_get\",     \"i(**)\",   &m3_wasi_generic_args_sizes_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_res_get\",        \"i(i*)\",   &m3_wasi_generic_clock_res_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_time_get\",       \"i(iI*)\",  &m3_wasi_generic_clock_time_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_get\",          \"i(**)\",   &m3_wasi_generic_environ_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_sizes_get\",    \"i(**)\",   &m3_wasi_generic_environ_sizes_get)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_advise\",            \"i(iIIi)\", )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_allocate\",          \"i(iII)\",  )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_close\",             \"i(i)\",    &m3_wasi_generic_fd_close)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_datasync\",          \"i(i)\",    &m3_wasi_generic_fd_datasync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_get\",        \"i(i*)\",   &m3_wasi_generic_fd_fdstat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_flags\",  \"i(ii)\",   &m3_wasi_generic_fd_fdstat_set_flags)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_rights\", \"i(iII)\",  )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_size\", \"i(iI)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_times\",\"i(iIIi)\", )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pread\",             \"i(i*iI*)\",)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_get\",       \"i(i*)\",   &m3_wasi_generic_fd_prestat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_dir_name\",  \"i(i*i)\",  &m3_wasi_generic_fd_prestat_dir_name)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pwrite\",            \"i(i*iI*)\",)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_read\",              \"i(i*i*)\", &m3_wasi_generic_fd_read)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_readdir\",           \"i(i*iI*)\",)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_renumber\",          \"i(ii)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_sync\",              \"i(i)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_tell\",              \"i(i*)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_write\",             \"i(i*i*)\", &m3_wasi_generic_fd_write)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_create_directory\",    \"i(i*i)\",       )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_filestat_set_times\",  \"i(ii*iIIi)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_link\",                \"i(ii*ii*i)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_open\",                \"i(ii*iiIIi*)\", &m3_wasi_generic_path_open)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_readlink\",            \"i(i*i*i*)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_remove_directory\",    \"i(i*i)\",       )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_rename\",              \"i(i*ii*i)\",    )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_symlink\",             \"i(*ii*i)\",     )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_unlink_file\",         \"i(i*i)\",       )));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"poll_oneoff\",          \"i(**i*)\", &m3_wasi_generic_poll_oneoff)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"proc_exit\",          \"v(i)\",    &m3_wasi_generic_proc_exit, wasi_context)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"proc_raise\",           \"i(i)\",    )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"random_get\",           \"i(*i)\",   &m3_wasi_generic_random_get)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sched_yield\",          \"i()\",     )));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_recv\",            \"i(i*ii**)\",        )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_send\",            \"i(i*ii*)\",         )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_shutdown\",        \"i(ii)\",            )));\n    }\n\n_catch:\n    return result;\n}\n\n#endif // d_m3HasWASI\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_compile.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_compile.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_compile.h\n//\n//  Created by Steven Massey on 4/17/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include <stdbool.h>\n\n#include \"m3_code.h\"\n#include \"m3_exec.h\"\n#include \"m3_function.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\nenum\n{\n    c_waOp_block                = 0x02,\n    c_waOp_loop                 = 0x03,\n    c_waOp_if                   = 0x04,\n    c_waOp_else                 = 0x05,\n    c_waOp_end                  = 0x0b,\n    c_waOp_branch               = 0x0c,\n    c_waOp_branchTable          = 0x0e,\n    c_waOp_branchIf             = 0x0d,\n    c_waOp_call                 = 0x10,\n    c_waOp_getLocal             = 0x20,\n    c_waOp_setLocal             = 0x21,\n    c_waOp_teeLocal             = 0x22,\n\n    c_waOp_getGlobal            = 0x23,\n\n    c_waOp_store_f32            = 0x38,\n    c_waOp_store_f64            = 0x39,\n\n    c_waOp_i32_const            = 0x41,\n    c_waOp_i64_const            = 0x42,\n    c_waOp_f32_const            = 0x43,\n    c_waOp_f64_const            = 0x44,\n\n    c_waOp_extended             = 0xfc,\n\n    c_waOp_memoryCopy           = 0xfc0a,\n    c_waOp_memoryFill           = 0xfc0b\n};\n\n\n#define d_FuncRetType(ftype,i)  ((ftype)->types[(i)])\n#define d_FuncArgType(ftype,i)  ((ftype)->types[(ftype)->numRets + (i)])\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3CompilationScope\n{\n    struct M3CompilationScope *     outer;\n\n    pc_t                            pc;                 // used by ContinueLoop's\n    pc_t                            patches;\n    i32                             depth;\n    u16                             exitStackIndex;\n    u16                             blockStackIndex;\n//    u16                             topSlot;\n    IM3FuncType                     type;\n    m3opcode_t                      opcode;\n    bool                            isPolymorphic;\n}\nM3CompilationScope;\n\ntypedef M3CompilationScope *        IM3CompilationScope;\n\ntypedef struct\n{\n    IM3Runtime          runtime;\n    IM3Module           module;\n\n    bytes_t             wasm;\n    bytes_t             wasmEnd;\n    bytes_t             lastOpcodeStart;\n\n    M3CompilationScope  block;\n\n    IM3Function         function;\n\n    IM3CodePage         page;\n\n#ifdef DEBUG\n    u32                 numEmits;\n    u32                 numOpcodes;\n#endif\n\n    u16                 stackFirstDynamicIndex;     // args and locals are pushed to the stack so that their slot locations can be tracked. the wasm model itself doesn't\n                                                    // treat these values as being on the stack, so stackFirstDynamicIndex marks the start of the real Wasm stack\n    u16                 stackIndex;                 // current stack top\n\n    u16                 slotFirstConstIndex;\n    u16                 slotMaxConstIndex;          // as const's are encountered during compilation this tracks their location in the \"real\" stack\n\n    u16                 slotFirstLocalIndex;\n    u16                 slotFirstDynamicIndex;      // numArgs + numLocals + numReservedConstants. the first mutable slot available to the compiler.\n\n    u16                 maxStackSlots;\n\n    m3slot_t            constants                   [d_m3MaxConstantTableSize];\n\n    // 'wasmStack' holds slot locations\n    u16                 wasmStack                   [d_m3MaxFunctionStackHeight];\n    u8                  typeStack                   [d_m3MaxFunctionStackHeight];\n\n    // 'm3Slots' contains allocation usage counts\n    u8                  m3Slots                     [d_m3MaxFunctionSlots];\n\n    u16                 slotMaxAllocatedIndexPlusOne;\n\n    u16                 regStackIndexPlusOne        [2];\n\n    m3opcode_t          previousOpcode;\n}\nM3Compilation;\n\ntypedef M3Compilation *                 IM3Compilation;\n\ntypedef M3Result (* M3Compiler)         (IM3Compilation, m3opcode_t);\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\n\ntypedef struct M3OpInfo\n{\n#ifdef DEBUG\n    const char * const      name;\n#endif\n\n    i8                      stackOffset;\n    u8                      type;\n\n    // for most operations:\n    // [0]= top operand in register, [1]= top operand in stack, [2]= both operands in stack\n    IM3Operation            operations [4];\n\n    M3Compiler              compiler;\n}\nM3OpInfo;\n\ntypedef const M3OpInfo *    IM3OpInfo;\n\nIM3OpInfo  GetOpInfo  (m3opcode_t opcode);\n\n// TODO: This helper should be removed, when MultiValue is implemented\nstatic inline\nu8 GetSingleRetType(IM3FuncType ftype) {\n    return (ftype && ftype->numRets) ? ftype->types[0] : (u8)c_m3Type_none;\n}\n\nstatic const u16 c_m3RegisterUnallocated = 0;\nstatic const u16 c_slotUnused = 0xffff;\n\nstatic inline\nbool  IsRegisterAllocated  (IM3Compilation o, u32 i_register)\n{\n    return (o->regStackIndexPlusOne [i_register] != c_m3RegisterUnallocated);\n}\n\nstatic inline\nbool  IsStackPolymorphic  (IM3Compilation o)\n{\n    return o->block.isPolymorphic;\n}\n\nstatic inline bool  IsRegisterSlotAlias        (u16 i_slot)    { return (i_slot >= d_m3Reg0SlotAlias and i_slot != c_slotUnused); }\nstatic inline bool  IsFpRegisterSlotAlias      (u16 i_slot)    { return (i_slot == d_m3Fp0SlotAlias);  }\nstatic inline bool  IsIntRegisterSlotAlias     (u16 i_slot)    { return (i_slot == d_m3Reg0SlotAlias); }\n\n\n#ifdef DEBUG\n    #define M3OP(...)       { __VA_ARGS__ }\n    #define M3OP_RESERVED   { \"reserved\" }\n#else\n    // Strip-off name\n    #define M3OP(name, ...) { __VA_ARGS__ }\n    #define M3OP_RESERVED   { 0 }\n#endif\n\n#if d_m3HasFloat\n    #define M3OP_F          M3OP\n#elif d_m3NoFloatDynamic\n    #define M3OP_F(n,o,t,op,...)        M3OP(n, o, t, { op_Unsupported, op_Unsupported, op_Unsupported, op_Unsupported }, __VA_ARGS__)\n#else\n    #define M3OP_F(...)     { 0 }\n#endif\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\nu16         GetMaxUsedSlotPlusOne       (IM3Compilation o);\n\nM3Result    CompileBlock                (IM3Compilation io, IM3FuncType i_blockType, m3opcode_t i_blockOpcode);\n\nM3Result    CompileBlockStatements      (IM3Compilation io);\nM3Result    CompileFunction             (IM3Function io_function);\n\nM3Result    CompileRawFunction          (IM3Module io_module, IM3Function io_function, const void * i_function, const void * i_userdata);\n\n\nd_m3EndExternC\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_esp_wasi.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_esp_wasi.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_esp_wasi.h\n//\n//  Created by Volodymyr Shymanskyy on 01/07/20.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include \"wasm3.h\"\n#include \"m3_function.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\ntypedef struct m3_wasi_context_t\n{\n    i32                     exit_code;\n    u32                     argc;\n    ccstr_t *               argv;\n} m3_wasi_context_t;\n\nM3Result    m3_LinkEspWASI     (IM3Module io_module);\nM3Result m3_LinkEspWASI_Hello(IM3Module module);\n\nm3_wasi_context_t* m3_GetWasiContext();\n\nd_m3EndExternC\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exec.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_exec.h\n//\n//  Created by Steven Massey on 4/17/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n\n#pragma once\n\n#include \"esp_log.h\"\n\n#include \"wasm3.h\"\n#include \"m3_math_utils.h\"\n#include \"m3_exception.h\"\n#include \"m3_segmented_memory.h\"\n#include \"m3_exec_defs.h\"\n\n// TODO: all these functions could move over to the .c at some point. normally, I'd say screw it,\n// but it might prove useful to be able to compile m3_exec alone w/ optimizations while the remaining\n// code is at debug O0\n\n\n// About the naming convention of these operations/macros (_rs, _sr_, _ss, _srs, etc.)\n//------------------------------------------------------------------------------------------------------\n//   - 'r' means register and 's' means slot\n//   - the first letter is the top of the stack\n//\n//  so, for example, _rs means the first operand (the first thing pushed to the stack) is in a slot\n//  and the second operand (the top of the stack) is in a register\n//------------------------------------------------------------------------------------------------------\n\n#ifndef M3_COMPILE_OPCODES\n//#  error \"Opcodes should only be included in one compilation unit\"\n#endif\n\n#include <limits.h>\n\n#define DEBUG_MEMORY 1\n\nd_m3BeginExternC\n\n# define rewrite_op(OP)             * ((void **) (_pc-1)) = (void*)(OP)\n\n# define immediate(TYPE)            * ((TYPE *) _pc++)\n# define skip_immediate(TYPE)       (_pc++)\n\n# define slot(TYPE)                 * (TYPE *) (_sp + immediate (i32))\n# define slot_ptr(TYPE)             (TYPE *) (_sp + immediate (i32))\n\n\n# if d_m3EnableOpProfiling\n                                    d_m3RetSig  profileOp   (d_m3OpSig, cstr_t i_operationName);\n#   define nextOp()                 M3_MUSTTAIL return profileOp (d_m3OpAllArgs, __FUNCTION__)\n# elif d_m3EnableOpTracing\n                                    d_m3RetSig  debugOp     (d_m3OpSig, cstr_t i_operationName);\n#   define nextOp()                 M3_MUSTTAIL return debugOp (d_m3OpAllArgs, __FUNCTION__)\n# else\n#   define nextOp()                 nextOpDirect()\n# endif\n\n#define jumpOp(PC)                  jumpOpDirect(PC)\n\n#if d_m3RecordBacktraces\n    #define pushBacktraceFrame()            (PushBacktraceFrame (_mem->runtime, _pc - 1))\n    #define fillBacktraceFrame(FUNCTION)    (FillBacktraceFunctionInfo (_mem->runtime, function))\n\n    #define newTrap(err)                    (pushBacktraceFrame(), (err))\n    #define forwardTrap(err)                (err)\n#else\n    #define pushBacktraceFrame()            do {} while (0)\n    #define fillBacktraceFrame(FUNCTION)    do {} while (0)\n\n    #define newTrap(err)                    (err)\n    #define forwardTrap(err)                (err)\n#endif\n\n\n#if d_m3EnableStrace == 1\n    // Flat trace\n    #define d_m3TracePrepare\n    #define d_m3TracePrint(fmt, ...)            fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__)\n#elif d_m3EnableStrace >= 2\n    // Structured trace\n    #define d_m3TracePrepare                    const IM3Runtime trace_rt = m3MemRuntime(_mem);\n    #define d_m3TracePrint(fmt, ...)            fprintf(stderr, \"%*s\" fmt \"\\n\", (trace_rt->callDepth)*2, \"\", ##__VA_ARGS__)\n#else\n    #define d_m3TracePrepare\n    #define d_m3TracePrint(fmt, ...)\n#endif\n\n#if d_m3EnableStrace >= 3\n    #define d_m3TraceLoad(TYPE,offset,val)      d_m3TracePrint(\"load.\" #TYPE \"  0x%x = %\" PRI##TYPE, offset, val)\n    #define d_m3TraceStore(TYPE,offset,val)     d_m3TracePrint(\"store.\" #TYPE \" 0x%x , %\" PRI##TYPE, offset, val)\n#else\n    #define d_m3TraceLoad(TYPE,offset,val)\n    #define d_m3TraceStore(TYPE,offset,val)\n#endif\n\n#ifdef DEBUG\n  #define d_outOfBounds newTrap (ErrorRuntime (m3Err_trapOutOfBoundsMemoryAccess,   \\\n                        _mem->runtime, \"memory size: %zu; access offset: %zu\",      \\\n                        _mem->memory->total_size, operand))\n\n#   define d_outOfBoundsMemOp(OFFSET, SIZE) newTrap (ErrorRuntime (m3Err_trapOutOfBoundsMemoryAccess,   \\\n                      _mem->runtime, \"memory size: %zu; access offset: %zu; size: %u\",     \\\n                      _mem->memory->total_size, OFFSET, SIZE))\n#else\n  #define d_outOfBounds newTrap (m3Err_trapOutOfBoundsMemoryAccess)\n\n#   define d_outOfBoundsMemOp(OFFSET, SIZE) newTrap (m3Err_trapOutOfBoundsMemoryAccess)\n\n#endif\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\nd_m3RetSig  Call  (d_m3OpSig, cstr_t i_operationName)\n# else\nd_m3RetSig  Call  (d_m3OpSig)\n# endif\n{\n    m3ret_t possible_trap = m3_Yield ();\n    if (M3_UNLIKELY(possible_trap)) return possible_trap;\n\n    nextOpDirect();\n}\n\n// TODO: OK, this needs some explanation here ;0\n\n#define d_m3CommutativeOpMacro(RES, REG, TYPE, NAME, OP, ...) \\\nd_m3Op(TYPE##_##NAME##_rs)                              \\\n{                                                       \\\n    TYPE operand = slot (TYPE);                         \\\n    OP((RES), operand, ((TYPE) REG), ##__VA_ARGS__);    \\\n    nextOp ();                                          \\\n    return m3Err_none;                                  \\\n}                                                       \\\nd_m3Op(TYPE##_##NAME##_ss)                              \\\n{                                                       \\\n    TYPE operand2 = slot (TYPE);                        \\\n    TYPE operand1 = slot (TYPE);                        \\\n    OP((RES), operand1, operand2, ##__VA_ARGS__);       \\\n    nextOp ();                                          \\\n    return m3Err_none;                                  \\\n}\n\n#define d_m3OpMacro(RES, REG, TYPE, NAME, OP, ...)      \\\nd_m3Op(TYPE##_##NAME##_sr)                              \\\n{                                                       \\\n    TYPE operand = slot (TYPE);                         \\\n    OP((RES), ((TYPE) REG), operand, ##__VA_ARGS__);    \\\n    nextOp ();                                          \\\n    return m3Err_none;                                  \\\n}                                                       \\\nd_m3CommutativeOpMacro(RES, REG, TYPE,NAME, OP, ##__VA_ARGS__)\n\n// Accept macros\n#define d_m3CommutativeOpMacro_i(TYPE, NAME, MACRO, ...)    d_m3CommutativeOpMacro  ( _r0,  _r0, TYPE, NAME, MACRO, ##__VA_ARGS__)\n#define d_m3OpMacro_i(TYPE, NAME, MACRO, ...)               d_m3OpMacro             ( _r0,  _r0, TYPE, NAME, MACRO, ##__VA_ARGS__)\n#define d_m3CommutativeOpMacro_f(TYPE, NAME, MACRO, ...)    d_m3CommutativeOpMacro  (_fp0, _fp0, TYPE, NAME, MACRO, ##__VA_ARGS__)\n#define d_m3OpMacro_f(TYPE, NAME, MACRO, ...)               d_m3OpMacro             (_fp0, _fp0, TYPE, NAME, MACRO, ##__VA_ARGS__)\n\n#define M3_FUNC(RES, A, B, OP)  (RES) = OP((A), (B))        // Accept functions: res = OP(a,b)\n#define M3_OPER(RES, A, B, OP)  (RES) = ((A) OP (B))        // Accept operators: res = a OP b\n\n#define d_m3CommutativeOpFunc_i(TYPE, NAME, OP)     d_m3CommutativeOpMacro_i    (TYPE, NAME, M3_FUNC, OP)\n#define d_m3OpFunc_i(TYPE, NAME, OP)                d_m3OpMacro_i               (TYPE, NAME, M3_FUNC, OP)\n#define d_m3CommutativeOpFunc_f(TYPE, NAME, OP)     d_m3CommutativeOpMacro_f    (TYPE, NAME, M3_FUNC, OP)\n#define d_m3OpFunc_f(TYPE, NAME, OP)                d_m3OpMacro_f               (TYPE, NAME, M3_FUNC, OP)\n\n#define d_m3CommutativeOp_i(TYPE, NAME, OP)         d_m3CommutativeOpMacro_i    (TYPE, NAME, M3_OPER, OP)\n#define d_m3Op_i(TYPE, NAME, OP)                    d_m3OpMacro_i               (TYPE, NAME, M3_OPER, OP)\n#define d_m3CommutativeOp_f(TYPE, NAME, OP)         d_m3CommutativeOpMacro_f    (TYPE, NAME, M3_OPER, OP)\n#define d_m3Op_f(TYPE, NAME, OP)                    d_m3OpMacro_f               (TYPE, NAME, M3_OPER, OP)\n\n// compare needs to be distinct for fp 'cause the result must be _r0\n#define d_m3CompareOp_f(TYPE, NAME, OP)             d_m3OpMacro                 (_r0, _fp0, TYPE, NAME, M3_OPER, OP)\n#define d_m3CommutativeCmpOp_f(TYPE, NAME, OP)      d_m3CommutativeOpMacro      (_r0, _fp0, TYPE, NAME, M3_OPER, OP)\n\n///\n///\n///\n\n//-----------------------\n\n// signed\nd_m3CommutativeOp_i (i32, Equal,            ==)     d_m3CommutativeOp_i (i64, Equal,            ==)\nd_m3CommutativeOp_i (i32, NotEqual,         !=)     d_m3CommutativeOp_i (i64, NotEqual,         !=)\n\nd_m3Op_i (i32, LessThan,                    < )     d_m3Op_i (i64, LessThan,                    < )\nd_m3Op_i (i32, GreaterThan,                 > )     d_m3Op_i (i64, GreaterThan,                 > )\nd_m3Op_i (i32, LessThanOrEqual,             <=)     d_m3Op_i (i64, LessThanOrEqual,             <=)\nd_m3Op_i (i32, GreaterThanOrEqual,          >=)     d_m3Op_i (i64, GreaterThanOrEqual,          >=)\n\n// unsigned\nd_m3Op_i (u32, LessThan,                    < )     d_m3Op_i (u64, LessThan,                    < )\nd_m3Op_i (u32, GreaterThan,                 > )     d_m3Op_i (u64, GreaterThan,                 > )\nd_m3Op_i (u32, LessThanOrEqual,             <=)     d_m3Op_i (u64, LessThanOrEqual,             <=)\nd_m3Op_i (u32, GreaterThanOrEqual,          >=)     d_m3Op_i (u64, GreaterThanOrEqual,          >=)\n\n#if d_m3HasFloat\nd_m3CommutativeCmpOp_f (f32, Equal,         ==)     d_m3CommutativeCmpOp_f (f64, Equal,         ==)\nd_m3CommutativeCmpOp_f (f32, NotEqual,      !=)     d_m3CommutativeCmpOp_f (f64, NotEqual,      !=)\nd_m3CompareOp_f (f32, LessThan,             < )     d_m3CompareOp_f (f64, LessThan,             < )\nd_m3CompareOp_f (f32, GreaterThan,          > )     d_m3CompareOp_f (f64, GreaterThan,          > )\nd_m3CompareOp_f (f32, LessThanOrEqual,      <=)     d_m3CompareOp_f (f64, LessThanOrEqual,      <=)\nd_m3CompareOp_f (f32, GreaterThanOrEqual,   >=)     d_m3CompareOp_f (f64, GreaterThanOrEqual,   >=)\n#endif\n\n#define OP_ADD_32(A,B) (i32)((u32)(A) + (u32)(B))\n#define OP_ADD_64(A,B) (i64)((u64)(A) + (u64)(B))\n#define OP_SUB_32(A,B) (i32)((u32)(A) - (u32)(B))\n#define OP_SUB_64(A,B) (i64)((u64)(A) - (u64)(B))\n#define OP_MUL_32(A,B) (i32)((u32)(A) * (u32)(B))\n#define OP_MUL_64(A,B) (i64)((u64)(A) * (u64)(B))\n\nd_m3CommutativeOpFunc_i (i32, Add,      OP_ADD_32)  d_m3CommutativeOpFunc_i (i64, Add,      OP_ADD_64)\nd_m3CommutativeOpFunc_i (i32, Multiply, OP_MUL_32)  d_m3CommutativeOpFunc_i (i64, Multiply, OP_MUL_64)\n\nd_m3OpFunc_i (i32, Subtract,            OP_SUB_32)  d_m3OpFunc_i (i64, Subtract,            OP_SUB_64)\n\n#define OP_SHL_32(X,N) ((X) << ((u32)(N) % 32))\n#define OP_SHL_64(X,N) ((X) << ((u64)(N) % 64))\n#define OP_SHR_32(X,N) ((X) >> ((u32)(N) % 32))\n#define OP_SHR_64(X,N) ((X) >> ((u64)(N) % 64))\n\nd_m3OpFunc_i (u32, ShiftLeft,       OP_SHL_32)      d_m3OpFunc_i (u64, ShiftLeft,       OP_SHL_64)\nd_m3OpFunc_i (i32, ShiftRight,      OP_SHR_32)      d_m3OpFunc_i (i64, ShiftRight,      OP_SHR_64)\nd_m3OpFunc_i (u32, ShiftRight,      OP_SHR_32)      d_m3OpFunc_i (u64, ShiftRight,      OP_SHR_64)\n\nd_m3CommutativeOp_i (u32, And,              &)\nd_m3CommutativeOp_i (u32, Or,               |)\nd_m3CommutativeOp_i (u32, Xor,              ^)\n\nd_m3CommutativeOp_i (u64, And,              &)\nd_m3CommutativeOp_i (u64, Or,               |)\nd_m3CommutativeOp_i (u64, Xor,              ^)\n\n#if d_m3HasFloat\nd_m3CommutativeOp_f (f32, Add,              +)      d_m3CommutativeOp_f (f64, Add,              +)\nd_m3CommutativeOp_f (f32, Multiply,         *)      d_m3CommutativeOp_f (f64, Multiply,         *)\nd_m3Op_f (f32, Subtract,                    -)      d_m3Op_f (f64, Subtract,                    -)\nd_m3Op_f (f32, Divide,                      /)      d_m3Op_f (f64, Divide,                      /)\n#endif\n\nd_m3OpFunc_i(u32, Rotl, rotl32)\nd_m3OpFunc_i(u32, Rotr, rotr32)\nd_m3OpFunc_i(u64, Rotl, rotl64)\nd_m3OpFunc_i(u64, Rotr, rotr64)\n\nd_m3OpMacro_i(u32, Divide, OP_DIV_U);\nd_m3OpMacro_i(i32, Divide, OP_DIV_S, INT32_MIN);\nd_m3OpMacro_i(u64, Divide, OP_DIV_U);\nd_m3OpMacro_i(i64, Divide, OP_DIV_S, INT64_MIN);\n\nd_m3OpMacro_i(u32, Remainder, OP_REM_U);\nd_m3OpMacro_i(i32, Remainder, OP_REM_S, INT32_MIN);\nd_m3OpMacro_i(u64, Remainder, OP_REM_U);\nd_m3OpMacro_i(i64, Remainder, OP_REM_S, INT64_MIN);\n\n#if d_m3HasFloat\nd_m3OpFunc_f(f32, Min, min_f32);\nd_m3OpFunc_f(f32, Max, max_f32);\nd_m3OpFunc_f(f64, Min, min_f64);\nd_m3OpFunc_f(f64, Max, max_f64);\n\nd_m3OpFunc_f(f32, CopySign, copysignf);\nd_m3OpFunc_f(f64, CopySign, copysign);\n#endif\n\n// Unary operations\n// Note: This macro follows the principle of d_m3OpMacro\n\n#define d_m3UnaryMacro(RES, REG, TYPE, NAME, OP, ...)   \\\nd_m3Op(TYPE##_##NAME##_r)                           \\\n{                                                   \\\n    OP((RES), (TYPE) REG, ##__VA_ARGS__);           \\\n    nextOp ();                                      \\\n}                                                   \\\nd_m3Op(TYPE##_##NAME##_s)                           \\\n{                                                   \\\n    TYPE operand = slot (TYPE);                     \\\n    OP((RES), operand, ##__VA_ARGS__);              \\\n    nextOp ();                                      \\\n}\n\n#define M3_UNARY(RES, X, OP) (RES) = OP(X)\n#define d_m3UnaryOp_i(TYPE, NAME, OPERATION)        d_m3UnaryMacro( _r0,  _r0, TYPE, NAME, M3_UNARY, OPERATION)\n#define d_m3UnaryOp_f(TYPE, NAME, OPERATION)        d_m3UnaryMacro(_fp0, _fp0, TYPE, NAME, M3_UNARY, OPERATION)\n\n#if d_m3HasFloat\nd_m3UnaryOp_f (f32, Abs,        fabsf);         d_m3UnaryOp_f (f64, Abs,        fabs);\nd_m3UnaryOp_f (f32, Ceil,       ceilf);         d_m3UnaryOp_f (f64, Ceil,       ceil);\nd_m3UnaryOp_f (f32, Floor,      floorf);        d_m3UnaryOp_f (f64, Floor,      floor);\nd_m3UnaryOp_f (f32, Trunc,      truncf);        d_m3UnaryOp_f (f64, Trunc,      trunc);\nd_m3UnaryOp_f (f32, Sqrt,       sqrtf);         d_m3UnaryOp_f (f64, Sqrt,       sqrt);\nd_m3UnaryOp_f (f32, Nearest,    rintf);         d_m3UnaryOp_f (f64, Nearest,    rint);\nd_m3UnaryOp_f (f32, Negate,     -);             d_m3UnaryOp_f (f64, Negate,     -);\n#endif\n\n#define OP_EQZ(x) ((x) == 0)\n\nd_m3UnaryOp_i (i32, EqualToZero, OP_EQZ)\nd_m3UnaryOp_i (i64, EqualToZero, OP_EQZ)\n\n// clz(0), ctz(0) results are undefined for rest platforms, fix it\n#if (defined(__i386__) || defined(__x86_64__)) && !(defined(__AVX2__) || (defined(__ABM__) && defined(__BMI__)))\n    #define OP_CLZ_32(x) (M3_UNLIKELY((x) == 0) ? 32 : __builtin_clz(x))\n    #define OP_CTZ_32(x) (M3_UNLIKELY((x) == 0) ? 32 : __builtin_ctz(x))\n    // for 64-bit instructions branchless approach more preferable\n    #define OP_CLZ_64(x) (__builtin_clzll((x) | (1LL <<  0)) + OP_EQZ(x))\n    #define OP_CTZ_64(x) (__builtin_ctzll((x) | (1LL << 63)) + OP_EQZ(x))\n#elif defined(__ppc__) || defined(__ppc64__)\n// PowerPC is defined for __builtin_clz(0) and __builtin_ctz(0).\n// See (https://github.com/aquynh/capstone/blob/master/MathExtras.h#L99)\n    #define OP_CLZ_32(x) __builtin_clz(x)\n    #define OP_CTZ_32(x) __builtin_ctz(x)\n    #define OP_CLZ_64(x) __builtin_clzll(x)\n    #define OP_CTZ_64(x) __builtin_ctzll(x)\n#else\n    #define OP_CLZ_32(x) (M3_UNLIKELY((x) == 0) ? 32 : __builtin_clz(x))\n    #define OP_CTZ_32(x) (M3_UNLIKELY((x) == 0) ? 32 : __builtin_ctz(x))\n    #define OP_CLZ_64(x) (M3_UNLIKELY((x) == 0) ? 64 : __builtin_clzll(x))\n    #define OP_CTZ_64(x) (M3_UNLIKELY((x) == 0) ? 64 : __builtin_ctzll(x))\n#endif\n\nd_m3UnaryOp_i (u32, Clz, OP_CLZ_32)\nd_m3UnaryOp_i (u64, Clz, OP_CLZ_64)\n\nd_m3UnaryOp_i (u32, Ctz, OP_CTZ_32)\nd_m3UnaryOp_i (u64, Ctz, OP_CTZ_64)\n\nd_m3UnaryOp_i (u32, Popcnt, __builtin_popcount)\nd_m3UnaryOp_i (u64, Popcnt, __builtin_popcountll)\n\n#define OP_WRAP_I64(X) ((X) & 0x00000000ffffffff)\n\nd_m3Op(i32_Wrap_i64_r){\n    _r0 = OP_WRAP_I64((i64) _r0);\n    return nextOp ();\n}\n\nd_m3Op(i32_Wrap_i64_s)\n{\n    i64 operand = slot (i64);\n    _r0 = OP_WRAP_I64(operand);\n    return nextOp ();\n}\n\n// Integer sign extension operations\n#define OP_EXTEND8_S_I32(X)  ((int32_t)(int8_t)(X))\n#define OP_EXTEND16_S_I32(X) ((int32_t)(int16_t)(X))\n#define OP_EXTEND8_S_I64(X)  ((int64_t)(int8_t)(X))\n#define OP_EXTEND16_S_I64(X) ((int64_t)(int16_t)(X))\n#define OP_EXTEND32_S_I64(X) ((int64_t)(int32_t)(X))\n\nd_m3UnaryOp_i (i32, Extend8_s,  OP_EXTEND8_S_I32)\nd_m3UnaryOp_i (i32, Extend16_s, OP_EXTEND16_S_I32)\nd_m3UnaryOp_i (i64, Extend8_s,  OP_EXTEND8_S_I64)\nd_m3UnaryOp_i (i64, Extend16_s, OP_EXTEND16_S_I64)\nd_m3UnaryOp_i (i64, Extend32_s, OP_EXTEND32_S_I64)\n\n#define d_m3TruncMacro(DEST, SRC, TYPE, NAME, FROM, OP, ...)   \\\nd_m3Op(TYPE##_##NAME##_##FROM##_r_r)                \\\n{                                                   \\\n    M3Result result = OP((DEST), (FROM) SRC, ##__VA_ARGS__);   \\\n    return nextOp ();                               \\\n}                                                   \\\nd_m3Op(TYPE##_##NAME##_##FROM##_r_s)                \\\n{                                                   \\\n    FROM * stack = slot_ptr (FROM);                 \\\n    OP((DEST), (* stack), ##__VA_ARGS__);           \\\n    return nextOp ();                                      \\\n}                                                   \\\nd_m3Op(TYPE##_##NAME##_##FROM##_s_r)                \\\n{                                                   \\\n    TYPE * dest = slot_ptr (TYPE);                  \\\n    OP((* dest), (FROM) SRC, ##__VA_ARGS__);        \\\n    return nextOp ();                                      \\\n}                                                   \\\nd_m3Op(TYPE##_##NAME##_##FROM##_s_s)                \\\n{                                                   \\\n    FROM * stack = slot_ptr (FROM);                 \\\n    TYPE * dest = slot_ptr (TYPE);                  \\\n    OP((* dest), (* stack), ##__VA_ARGS__);         \\\n    return nextOp ();                                      \\\n}\n\n#if d_m3HasFloat\nd_m3TruncMacro(_r0, _fp0, i32, Trunc, f32, OP_I32_TRUNC_F32)\nd_m3TruncMacro(_r0, _fp0, u32, Trunc, f32, OP_U32_TRUNC_F32)\nd_m3TruncMacro(_r0, _fp0, i32, Trunc, f64, OP_I32_TRUNC_F64)\nd_m3TruncMacro(_r0, _fp0, u32, Trunc, f64, OP_U32_TRUNC_F64)\n\nd_m3TruncMacro(_r0, _fp0, i64, Trunc, f32, OP_I64_TRUNC_F32)\nd_m3TruncMacro(_r0, _fp0, u64, Trunc, f32, OP_U64_TRUNC_F32)\nd_m3TruncMacro(_r0, _fp0, i64, Trunc, f64, OP_I64_TRUNC_F64)\nd_m3TruncMacro(_r0, _fp0, u64, Trunc, f64, OP_U64_TRUNC_F64)\n\nd_m3TruncMacro(_r0, _fp0, i32, TruncSat, f32, OP_I32_TRUNC_SAT_F32)\nd_m3TruncMacro(_r0, _fp0, u32, TruncSat, f32, OP_U32_TRUNC_SAT_F32)\nd_m3TruncMacro(_r0, _fp0, i32, TruncSat, f64, OP_I32_TRUNC_SAT_F64)\nd_m3TruncMacro(_r0, _fp0, u32, TruncSat, f64, OP_U32_TRUNC_SAT_F64)\n\nd_m3TruncMacro(_r0, _fp0, i64, TruncSat, f32, OP_I64_TRUNC_SAT_F32)\nd_m3TruncMacro(_r0, _fp0, u64, TruncSat, f32, OP_U64_TRUNC_SAT_F32)\nd_m3TruncMacro(_r0, _fp0, i64, TruncSat, f64, OP_I64_TRUNC_SAT_F64)\nd_m3TruncMacro(_r0, _fp0, u64, TruncSat, f64, OP_U64_TRUNC_SAT_F64)\n#endif\n\n#define d_m3TypeModifyOp(REG_TO, REG_FROM, TO, NAME, FROM)  \\\nd_m3Op(TO##_##NAME##_##FROM##_r)                            \\\n{                                                           \\\n    REG_TO = (TO) ((FROM) REG_FROM);                        \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_##NAME##_##FROM##_s)                            \\\n{                                                           \\\n    FROM from = slot (FROM);                                \\\n    REG_TO = (TO) (from);                                   \\\nreturn     nextOp ();                                               \\\n}\n\n// Int to int\nd_m3TypeModifyOp (_r0, _r0, i64, Extend, i32);\nd_m3TypeModifyOp (_r0, _r0, i64, Extend, u32);\n\n// Float to float\n#if d_m3HasFloat\nd_m3TypeModifyOp (_fp0, _fp0, f32, Demote, f64);\nd_m3TypeModifyOp (_fp0, _fp0, f64, Promote, f32);\n#endif\n\n#define d_m3TypeConvertOp(REG_TO, REG_FROM, TO, NAME, FROM) \\\nd_m3Op(TO##_##NAME##_##FROM##_r_r)                          \\\n{                                                           \\\n    REG_TO = (TO) ((FROM) REG_FROM);                        \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_##NAME##_##FROM##_s_r)                          \\\n{                                                           \\\n    slot (TO) = (TO) ((FROM) REG_FROM);                     \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_##NAME##_##FROM##_r_s)                          \\\n{                                                           \\\n    FROM from = slot (FROM);                                \\\n    REG_TO = (TO) (from);                                   \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_##NAME##_##FROM##_s_s)                          \\\n{                                                           \\\n    FROM from = slot (FROM);                                \\\n    slot (TO) = (TO) (from);                                \\\nreturn     nextOp ();                                               \\\n}\n\n// Int to float\n#if d_m3HasFloat\nd_m3TypeConvertOp (_fp0, _r0, f64, Convert, i32);\nd_m3TypeConvertOp (_fp0, _r0, f64, Convert, u32);\nd_m3TypeConvertOp (_fp0, _r0, f64, Convert, i64);\nd_m3TypeConvertOp (_fp0, _r0, f64, Convert, u64);\n\nd_m3TypeConvertOp (_fp0, _r0, f32, Convert, i32);\nd_m3TypeConvertOp (_fp0, _r0, f32, Convert, u32);\nd_m3TypeConvertOp (_fp0, _r0, f32, Convert, i64);\nd_m3TypeConvertOp (_fp0, _r0, f32, Convert, u64);\n#endif\n\n#define d_m3ReinterpretOp(REG, TO, SRC, FROM)               \\\nd_m3Op(TO##_Reinterpret_##FROM##_r_r)                       \\\n{                                                           \\\n    union { FROM c; TO t; } u;                              \\\n    u.c = (FROM) SRC;                                       \\\n    REG = u.t;                                              \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_Reinterpret_##FROM##_r_s)                       \\\n{                                                           \\\n    union { FROM c; TO t; } u;                              \\\n    u.c = slot (FROM);                                      \\\n    REG = u.t;                                              \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_Reinterpret_##FROM##_s_r)                       \\\n{                                                           \\\n    union { FROM c; TO t; } u;                              \\\n    u.c = (FROM) SRC;                                       \\\n    slot (TO) = u.t;                                        \\\nreturn     nextOp ();                                               \\\n}                                                           \\\n                                                            \\\nd_m3Op(TO##_Reinterpret_##FROM##_s_s)                       \\\n{                                                           \\\n    union { FROM c; TO t; } u;                              \\\n    u.c = slot (FROM);                                      \\\n    slot (TO) = u.t;                                        \\\nreturn     nextOp ();                                               \\\n}\n\n#if d_m3HasFloat\nd_m3ReinterpretOp (_r0, i32, _fp0, f32)\nd_m3ReinterpretOp (_r0, i64, _fp0, f64)\nd_m3ReinterpretOp (_fp0, f32, _r0, i32)\nd_m3ReinterpretOp (_fp0, f64, _r0, i64)\n#endif\n\n\nd_m3Op  (GetGlobal_s32){\n    u32 * global = immediate (u32 *);\n    slot (u32) = * global;                        //  printf (\"get global: %p %\" PRIi64 \"\\n\", global, *global);\n\n    return nextOp ();\n}\n\n\nd_m3Op  (GetGlobal_s64)\n{\n    u64 * global = immediate (u64 *);\n    slot (u64) = * global;                        // printf (\"get global: %p %\" PRIi64 \"\\n\", global, *global);\n\n    return nextOp ();\n}\n\n\nd_m3Op  (SetGlobal_i32)\n{\n    u32 * global = immediate (u32 *);\n    * global = (u32) _r0;                         //  printf (\"set global: %p %\" PRIi64 \"\\n\", global, _r0);\n\n    return nextOp ();\n}\n\n\nd_m3Op  (SetGlobal_i64)\n{\n    u64 * global = immediate (u64 *);\n    * global = (u64) _r0;                         //  printf (\"set global: %p %\" PRIi64 \"\\n\", global, _r0);\n\n    return nextOp ();\n}\n\n\nd_m3Op (Call)\n{\n    pc_t callPC                 = immediate (pc_t);\n    i32 stackOffset            = immediate (i32);\n    IM3Memory memory           =_mem; //  m3MemInfo (_mem);\n\n    m3stack_t sp = _sp + stackOffset;\n\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n    m3ret_t r = Call(callPC, sp, memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n    m3ret_t r = Call(callPC, sp, memory, d_m3OpDefaultArgs);\n# endif\n\n    // Non serve più refreshare _mem dato che usiamo la memoria segmentata\n    \n    if (M3_LIKELY(not r))\n        return nextOp();\n    else\n    {\n        pushBacktraceFrame();\n        forwardTrap(r);\n    }\n}\n\nd_m3Op (CallIndirect)\n{\n    u32 tableIndex             = slot (u32);\n    IM3Module module           = immediate (IM3Module);\n    IM3FuncType type           = immediate (IM3FuncType);\n    i32 stackOffset            = immediate (i32);\n    IM3Memory memory          =_mem; //  m3MemInfo (_mem);\n\n    m3stack_t sp = _sp + stackOffset;\n\n    m3ret_t r = m3Err_none;\n\n    if (M3_LIKELY(tableIndex < module->table0Size))\n    {\n        IM3Function function = module->table0[tableIndex];\n\n        if (M3_LIKELY(function))\n        {\n            if (M3_LIKELY(type == function->funcType))\n            {\n                if (M3_UNLIKELY(not function->compiled))\n                    r = CompileFunction(function);\n\n                if (M3_LIKELY(not r))\n                {\n# if (d_m3EnableOpProfiling || d_m3EnableOpTracing)\n                    r = Call(function->compiled, sp, memory, d_m3OpDefaultArgs, d_m3BaseCstr);\n# else\n                    r = Call(function->compiled, sp, memory, d_m3OpDefaultArgs);\n# endif\n\n                    // Non serve più refreshare _mem\n                    \n                    if (M3_LIKELY(not r))\n                        nextOpDirect();\n                    else\n                    {\n                        pushBacktraceFrame();\n                        forwardTrap(r);\n                    }\n                }\n            }\n            else r = m3Err_trapIndirectCallTypeMismatch;\n        }\n        else r = m3Err_trapTableElementIsNull;\n    }\n    else r = m3Err_trapTableIndexOutOfRange;\n\n    if (M3_UNLIKELY(r))\n        newTrap(r);\n    else forwardTrap(r);\n}\n\nd_m3Op (CallRawFunction)\n{\n    d_m3TracePrepare\n\n    M3ImportContext ctx;\n\n    M3RawCall call = (M3RawCall) (*_pc++);\n    ctx.function = immediate (IM3Function);\n    ctx.userdata = immediate (void *);\n    u64* const sp = ((u64*)_sp);\n    IM3Memory memory =_mem; //  m3MemInfo (_mem);\n    IM3Runtime runtime = m3MemRuntime(_mem);\n\n#if d_m3EnableStrace\n    // ... (il codice di tracing rimane invariato)\n#endif\n\n    void* stack_backup = runtime->stack;\n    runtime->stack = sp;\n    \n    // Per le funzioni raw, dobbiamo fornire un modo sicuro per accedere ai dati\n    // attraverso i segmenti. Creiamo una funzione helper che gestisce questo.\n    m3ret_t possible_trap = call(runtime, &ctx, sp, memory);\n    \n    runtime->stack = stack_backup;\n\n#if d_m3EnableStrace\n    // ... (il codice di tracing rimane invariato)\n#endif\n\n    if (M3_UNLIKELY(possible_trap)) {\n        // Non serve più refreshare _mem\n        pushBacktraceFrame();\n    }\n    forwardTrap(possible_trap);\n}\n\n\nd_m3Op  (MemSize)\n{\n    IM3Memory memory            =_mem; //  m3MemInfo (_mem);\n\n    _r0 = memory->total_size; // istead of memory->numPages\n\n    return nextOp ();\n}\n\n\nd_m3Op (MemGrow) //todo: convert it to new memory model\n{\n    IM3Runtime runtime = m3MemRuntime(_mem);\n    IM3Memory memory = &runtime->memory;\n\n    i32 numPagesToGrow = _r0;\n    if (numPagesToGrow >= 0) {\n        _r0 = memory->total_size;\n\n        if (M3_LIKELY(numPagesToGrow))\n        {\n            u32 requiredPages = memory->numPages + numPagesToGrow;\n            size_t newSize = (size_t)requiredPages * WASM_PAGE_SIZE;\n            \n            // Calcola il nuovo numero di segmenti necessari\n            size_t currentSegments = memory->num_segments;\n            size_t newNumSegments = (newSize + memory->segment_size - 1) / memory->segment_size;\n            \n            // Alloca il nuovo array di segmenti\n            MemorySegment* newSegments = current_allocator->realloc(\n                memory->segments,\n                newNumSegments * sizeof(MemorySegment)\n            );\n            \n            if (newSegments) {\n                // Inizializza i nuovi segmenti\n                for (size_t i = currentSegments; i < newNumSegments; i++) {\n                    newSegments[i].data = NULL;\n                    newSegments[i].is_allocated = false;\n                    //newSegments[i].size = 0;\n                }\n                \n                // Aggiorna la struttura della memoria\n                memory->segments = newSegments;\n                memory->num_segments = newNumSegments;\n                memory->numPages = requiredPages;\n                memory->total_size = newSize;\n                \n                ESP_LOGI(\"WASM3\", \"Memory grown to %lu pages (%zu bytes, %zu segments)\", \n                         requiredPages, newSize, newNumSegments);\n            }\n            else {\n                _r0 = -1;\n                ESP_LOGE(\"WASM3\", \"Failed to grow memory to %lu pages\", requiredPages);\n            }\n        }\n    }\n    else {\n        _r0 = -1;\n    }\n\n    return nextOp();\n}\n\n\nd_m3Op  (MemCopy)\n{\n    u32 size = (u32) _r0;\n    u64 source = slot (u32);\n    u64 destination = slot (u32);\n\n    if (M3_LIKELY(destination + size <= _mem->memory->total_size))\n    {\n        if (M3_LIKELY(source + size <= _mem->memory->total_size))\n        {\n            u8 * dst = m3MemData (_mem) + destination;\n            u8 * src = m3MemData (_mem) + source;\n            memmove (dst, src, size);\n\n            return nextOp ();\n        }\n        else return d_outOfBoundsMemOp (source, size);\n    }\n    else return d_outOfBoundsMemOp (destination, size);\n}\n\n\nd_m3Op  (MemFill)\n{\n    u32 size = (u32) _r0;\n    u32 byte = slot (u32);\n    u64 destination = slot (u32);\n\n    if (M3_LIKELY(destination + size <= _mem->memory->total_size))\n    {\n        u8 * mem8 = m3MemData (_mem) + destination;\n        memset (mem8, (u8) byte, size);\n        return nextOp ();\n    }\n    else return d_outOfBoundsMemOp (destination, size);\n}\n\n\n// it's a debate: should the compilation be trigger be the caller or callee page.\n// it's a much easier to put it in the caller pager. if it's in the callee, either the entire page\n// has be left dangling or it's just a stub that jumps to a newly acquired page.  In Gestalt, I opted\n// for the stub approach. Stubbing makes it easier to dynamically free the compilation. You can also\n// do both.\nd_m3Op  (Compile)\n{\n    rewrite_op (op_Call);\n\n    IM3Function function        = immediate (IM3Function);\n\n    m3ret_t result = m3Err_none;\n\n    if (M3_UNLIKELY(not function->compiled)) // check to see if function was compiled since this operation was emitted.\n        result = CompileFunction (function);\n\n    if (not result)\n    {\n        // patch up compiled pc and call rewritten op_Call\n        * ((void**) --_pc) = (void*) (function->compiled);\n        --_pc;\n        nextOpDirect ();\n    }\n\n    newTrap (result);\n}\n\n\nstatic const bool WASM_Entry_IgnoreBufferOverflow = true;\nd_m3Op  (Entry)\n{\n    d_m3ClearRegisters\n    \n    d_m3TracePrepare\n\n    IM3Function function = immediate (IM3Function);\n    IM3Memory memory =_mem; //  m3MemInfo (_mem);\n\n#if d_m3SkipStackCheck\n    if (true)\n#else\n    // Usa total_size invece di maxStack per il controllo\n    if (WASM_Entry_IgnoreBufferOverflow || M3_LIKELY ((void *)(_sp + function->maxStackSlots) <  (void *)(memory->total_size))) //todo: DEPRECATE IT?\n#endif\n    {\n#if defined(DEBUG)\n        function->hits++;\n#endif\n        u8* stack = (u8*)((m3slot_t*)_sp + function->numRetAndArgSlots);\n        \n        // Assicuriamoci che i segmenti necessari per lo stack siano allocati\n        size_t stack_start_offset = (size_t)stack;\n        size_t required_size = function->numLocalBytes + function->numConstantBytes;\n        \n        // Alloca i segmenti necessari per lo stack\n        size_t start_segment = stack_start_offset / memory->segment_size;\n        size_t end_segment = (stack_start_offset + required_size - 1) / memory->segment_size;\n                            \n        if(end_segment > memory->num_segments){\n            // realloc new segments\n            memory->num_segments = end_segment;\n            ESP_LOGI(\"WASM3\", \"(Entry): Going to reallocate %u memory->segments\", end_segment);\n            if(current_allocator->realloc(memory->segments, memory->num_segments * sizeof(MemorySegment)) == NULL){\n                forwardTrap(error_details(m3Err_mallocFailed, \"during segments realloc in (Entry)\"));\n                return NULL;\n            }\n        }\n\n        for (size_t i = start_segment; i <= end_segment; i++) {\n            if (!memory->segments[i].is_allocated) {\n                if (!allocate_segment(memory, i)) {\n                    forwardTrap(error_details(m3Err_mallocFailed, \"during allocate_segment in (Entry)\"));\n                    return NULL;\n                }\n            }\n        }\n        \n        // Zero-inizializza i locali attraverso i segmenti\n        size_t remaining_locals = function->numLocalBytes;\n        size_t current_offset = stack_start_offset;\n        \n        while (remaining_locals > 0) {\n            size_t seg_idx = current_offset / memory->segment_size;\n            size_t seg_offset = current_offset % memory->segment_size;\n            size_t bytes_to_clear = M3_MIN(\n                remaining_locals,\n                memory->segment_size - seg_offset\n            );\n            \n            memset(\n                ((u8*)memory->segments[seg_idx].data) + seg_offset,\n                0x0,\n                bytes_to_clear\n            );\n            \n            remaining_locals -= bytes_to_clear;\n            current_offset += bytes_to_clear;\n        }\n        \n        stack += function->numLocalBytes;\n\n        // Copia le costanti se presenti\n        if (function->constants) {\n            size_t remaining_constants = function->numConstantBytes;\n            current_offset = (size_t)stack;\n            const u8* src = function->constants;\n            \n            while (remaining_constants > 0) {\n                size_t seg_idx = current_offset / memory->segment_size;\n                size_t seg_offset = current_offset % memory->segment_size;\n                size_t bytes_to_copy = M3_MIN(\n                    remaining_constants,\n                    memory->segment_size - seg_offset\n                );\n                \n                memcpy(\n                    ((u8*)memory->segments[seg_idx].data) + seg_offset,\n                    src,\n                    bytes_to_copy\n                );\n                \n                remaining_constants -= bytes_to_copy;\n                current_offset += bytes_to_copy;\n                src += bytes_to_copy;\n            }\n        }\n\n#if d_m3EnableStrace >= 2\n        d_m3TracePrint(\"%s %s {\", m3_GetFunctionName(function), \n                      SPrintFunctionArgList(function, _sp + function->numRetSlots));\n        trace_rt->callDepth++;\n#endif\n\n        m3ret_t r = nextOpImpl();\n\n#if d_m3EnableStrace >= 2\n        trace_rt->callDepth--;\n\n        if (r) {\n            d_m3TracePrint(\"} !trap = %s\", (char*)r);\n        } else {\n            int rettype = GetSingleRetType(function->funcType);\n            if (rettype != c_m3Type_none) {\n                char str[128] = { 0 };\n                SPrintArg(str, 127, _sp, rettype);\n                d_m3TracePrint(\"} = %s\", str);\n            } else {\n                d_m3TracePrint(\"}\");\n            }\n        }\n#endif\n\n        if (M3_UNLIKELY(r)) {\n            // Non abbiamo più bisogno di refreshare _mem\n            fillBacktraceFrame();\n        }\n        forwardTrap(r);\n    }\n    else newTrap(error_details(m3Err_trapStackOverflow, \"in d_m30p (Entry)\"));\n}\n\n\nd_m3Op  (Loop)\n{\n    d_m3TracePrepare\n\n    // regs are unused coming into a loop anyway\n    // this reduces code size & stack usage\n    d_m3ClearRegisters\n\n    m3ret_t r;\n    \n    IM3Memory memory =_mem; //  m3MemInfo (_mem);\n    \n    // Manteniamo un contatore delle iterazioni per debug/logging opzionale\n    u32 iteration_count = 0;\n\n    do\n    {\n#if d_m3EnableStrace >= 3\n        d_m3TracePrint(\"iter {\");\n        trace_rt->callDepth++;\n#endif\n        \n        r = nextOpImpl ();\n        \n#if d_m3EnableStrace >= 3\n        trace_rt->callDepth--;\n        d_m3TracePrint(\"}\");\n#endif\n\n        // Non abbiamo più bisogno di refreshare _mem poiché non usiamo più\n        // un singolo blocco mallocated. Invece, ogni accesso alla memoria\n        // passa attraverso m3SegmentedMemAccess che gestisce l'allocazione\n        // lazy dei segmenti necessari.\n        \n        iteration_count++;\n        \n        // Opzionale: logging periodico per debug\n        if (DEBUG_MEMORY && (iteration_count % 1000 == 0)) {\n            ESP_LOGI(\"WASM3\", \"Loop iteration %lu\", iteration_count);\n        }\n    }\n    while (r == _pc);\n\n    forwardTrap (r);\n}\n\n\nd_m3Op  (Branch)\n{\n    jumpOp (* _pc);\n}\n\n\nd_m3Op  (If_r)\n{\n    i32 condition = (i32) _r0;\n\n    pc_t elsePC = immediate (pc_t);\n\n    if (condition)\n        return nextOp ();\n    else\n        jumpOp (elsePC);\n}\n\n\nd_m3Op  (If_s)\n{\n    i32 condition = slot (i32);\n\n    pc_t elsePC = immediate (pc_t);\n\n    if (condition)\n        return nextOp ();\n    else\n        jumpOp (elsePC);\n}\n\n\nd_m3Op  (BranchTable)\n{\n    u32 branchIndex = slot (u32);           // branch index is always in a slot\n    u32 numTargets  = immediate (u32);\n\n    pc_t * branches = (pc_t *) _pc;\n\n    if (branchIndex > numTargets)\n        branchIndex = numTargets; // the default index\n\n    jumpOp (branches [branchIndex]);\n}\n\n\n#define d_m3SetRegisterSetSlot(TYPE, REG) \\\nd_m3Op  (SetRegister_##TYPE)            \\\n{                                       \\\n    REG = slot (TYPE);                  \\\n    return nextOp ();                          \\\n}\\                                       \\\n                                        \\\nd_m3Op(SetSlot_##TYPE)                 \\\n{                                       \\\n    slot (TYPE) = (TYPE) REG;           \\\nreturn     nextOp ();                           \\\n}                                       \\\n                                        \\\nd_m3Op (PreserveSetSlot_##TYPE)         \\\n{                                       \\\n    TYPE * stack     = slot_ptr (TYPE); \\\n    TYPE * preserve  = slot_ptr (TYPE); \\\n                                        \\\n    * preserve = * stack;               \\\n    * stack = (TYPE) REG;               \\\n                                        \\\nreturn     nextOp ();                           \\\n}\n\nd_m3SetRegisterSetSlot (i32, _r0)\nd_m3SetRegisterSetSlot (i64, _r0)\n#if d_m3HasFloat\nd_m3SetRegisterSetSlot (f32, _fp0)\nd_m3SetRegisterSetSlot (f64, _fp0)\n#endif\n\nd_m3Op (CopySlot_32){\n    u32 * dst = slot_ptr (u32);\n    u32 * src = slot_ptr (u32);\n\n    * dst = * src;\n\n    return nextOp ();\n}\n\n\nd_m3Op (PreserveCopySlot_32)\n{\n    u32 * dest      = slot_ptr (u32);\n    u32 * src       = slot_ptr (u32);\n    u32 * preserve  = slot_ptr (u32);\n\n    * preserve = * dest;\n    * dest = * src;\n\n    return nextOp ();\n}\n\n\nd_m3Op (CopySlot_64)\n{\n    u64 * dst = slot_ptr (u64);\n    u64 * src = slot_ptr (u64);\n\n    * dst = * src;                  // printf (\"copy: %p <- %\" PRIi64 \" <- %p\\n\", dst, * dst, src);\n\n    return nextOp ();\n}\n\n\nd_m3Op (PreserveCopySlot_64)\n{\n    u64 * dest      = slot_ptr (u64);\n    u64 * src       = slot_ptr (u64);\n    u64 * preserve  = slot_ptr (u64);\n\n    * preserve = * dest;\n    * dest = * src;\n\n    return nextOp ();\n}\n\n\n#if d_m3EnableOpTracing\n//--------------------------------------------------------------------------------------------------------\nd_m3Op  (DumpStack)\n{\n    u32 opcodeIndex         = immediate (u32);\n    u32 stackHeight         = immediate (u32);\n    IM3Function function    = immediate (IM3Function);\n\n    cstr_t funcName = (function) ? m3_GetFunctionName(function) : \"\";\n\n    printf (\" %4d \", opcodeIndex);\n    printf (\" %-25s     r0: 0x%016\" PRIx64 \"  i:%\" PRIi64 \"  u:%\" PRIu64 \"\\n\", funcName, _r0, _r0, _r0);\n#if d_m3HasFloat\n    printf (\"                                    fp0: %\" PRIf64 \"\\n\", _fp0);\n#endif\n    m3stack_t sp = _sp;\n\n    for (u32 i = 0; i < stackHeight; ++i)\n    {\n        cstr_t kind = \"\";\n\n        printf (\"%p  %5s  %2d: 0x%\" PRIx64 \"  i:%\" PRIi64 \"\\n\", sp, kind, i, (u64) *(sp), (i64) *(sp));\n\n        ++sp;\n    }\n    printf (\"---------------------------------------------------------------------------------------------------------\\n\");\n\n    nextOpDirect();\n}\n#endif\n\n\n#define d_m3Select_i(TYPE, REG)                 \\\nd_m3Op  (Select_##TYPE##_rss)                   \\\n{                                               \\\n    i32 condition = (i32) _r0;                  \\\n                                                \\\n    TYPE operand2 = slot (TYPE);                \\\n    TYPE operand1 = slot (TYPE);                \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\n    return nextOp ();                                  \\\n}                                               \\\n                                                \\\nd_m3Op(Select_##TYPE##_srs)                   \\\n{                                               \\\n    i32 condition = slot (i32);                 \\\n                                                \\\n    TYPE operand2 = (TYPE) REG;                 \\\n    TYPE operand1 = slot (TYPE);                \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}                                               \\\n                                                \\\nd_m3Op  (Select_##TYPE##_ssr)                   \\\n{                                               \\\n    i32 condition = slot (i32);                 \\\n                                                \\\n    TYPE operand2 = slot (TYPE);                \\\n    TYPE operand1 = (TYPE) REG;                 \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}                                               \\\n                                                \\\nd_m3Op  (Select_##TYPE##_sss)                   \\\n{                                               \\\n    i32 condition = slot (i32);                 \\\n                                                \\\n    TYPE operand2 = slot (TYPE);                \\\n    TYPE operand1 = slot (TYPE);                \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}\n\n\nd_m3Select_i (i32, _r0)\nd_m3Select_i (i64, _r0)\n\n\n#define d_m3Select_f(TYPE, REG, LABEL, SELECTOR)  \\\nd_m3Op  (Select_##TYPE##_##LABEL##ss)           \\\n{                                               \\\n    i32 condition = (i32) SELECTOR;             \\\n                                                \\\n    TYPE operand2 = slot (TYPE);                \\\n    TYPE operand1 = slot (TYPE);                \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}                                               \\\n                                                \\\nd_m3Op  (Select_##TYPE##_##LABEL##rs)           \\\n{                                               \\\n    i32 condition = (i32) SELECTOR;             \\\n                                                \\\n    TYPE operand2 = (TYPE) REG;                 \\\n    TYPE operand1 = slot (TYPE);                \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}                                               \\\n                                                \\\nd_m3Op  (Select_##TYPE##_##LABEL##sr)           \\\n{                                               \\\n    i32 condition = (i32) SELECTOR;             \\\n                                                \\\n    TYPE operand2 = slot (TYPE);                \\\n    TYPE operand1 = (TYPE) REG;                 \\\n                                                \\\n    REG = (condition) ? operand1 : operand2;    \\\n                                                \\\nreturn     nextOp ();                                   \\\n}\n\n#if d_m3HasFloat\nd_m3Select_f (f32, _fp0, r, _r0)\nd_m3Select_f (f32, _fp0, s, slot (i32))\n\nd_m3Select_f (f64, _fp0, r, _r0)\nd_m3Select_f (f64, _fp0, s, slot (i32))\n#endif\n\nd_m3Op  (Return){\n    m3StackCheck();\n    return m3Err_none;\n}\n\n\nd_m3Op  (BranchIf_r)\n{\n    i32 condition   = (i32) _r0;\n    pc_t branch     = immediate (pc_t);\n\n    if (condition)\n    {\n        jumpOp (branch);\n    }\n    else return nextOp ();\n}\n\n\nd_m3Op  (BranchIf_s)\n{\n    i32 condition   = slot (i32);\n    pc_t branch     = immediate (pc_t);\n\n    if (condition)\n    {\n        jumpOp (branch);\n    }\n    else return nextOp ();\n}\n\n\nd_m3Op  (BranchIfPrologue_r)\n{\n    i32 condition   = (i32) _r0;\n    pc_t branch     = immediate (pc_t);\n\n    if (condition)\n    {\n        // this is the \"prologue\" that ends with\n        // a plain branch to the actual target\n        return nextOp ();\n    }\n    else jumpOp (branch); // jump over the prologue\n}\n\n\nd_m3Op  (BranchIfPrologue_s)\n{\n    i32 condition   = slot (i32);\n    pc_t branch     = immediate (pc_t);\n\n    if (condition)\n    {\n        return nextOp ();\n    }\n    else jumpOp (branch);\n}\n\n\nd_m3Op  (ContinueLoop)\n{\n    m3StackCheck();\n\n    // TODO: this is where execution can \"escape\" the M3 code and callback to the client / fiber switch\n    // OR it can go in the Loop operation. I think it's best to do here. adding code to the loop operation\n    // has the potential to increase its native-stack usage. (don't forget ContinueLoopIf too.)\n\n    void * loopId = immediate (void *);\n    return loopId;\n}\n\n\nd_m3Op  (ContinueLoopIf)\n{\n    i32 condition = (i32) _r0;\n    void * loopId = immediate (void *);\n\n    if (condition)\n    {\n        return loopId;\n    }\n    else return nextOp ();\n}\n\n\nd_m3Op  (Const32)\n{\n    u32 value = * (u32 *)_pc++;\n    slot (u32) = value;\n    return nextOp ();\n}\n\n\nd_m3Op  (Const64)\n{\n    u64 value = * (u64 *)_pc;\n    _pc += (M3_SIZEOF_PTR == 4) ? 2 : 1;\n    slot (u64) = value;\n    return nextOp ();\n}\n\nd_m3Op  (Unsupported)\n{\n    newTrap (\"unsupported instruction executed\");\n}\n\nd_m3Op  (Unreachable)\n{\n    m3StackCheck();\n    newTrap (m3Err_trapUnreachable);\n}\n\n\nd_m3Op  (End)\n{\n    m3StackCheck();\n    return m3Err_none;\n}\n\n\nd_m3Op  (SetGlobal_s32)\n{\n    u32 * global = immediate (u32 *);\n    * global = slot (u32);\n\n    return nextOp ();\n}\n\n\nd_m3Op  (SetGlobal_s64)\n{\n    u64 * global = immediate (u64 *);\n    * global = slot (u64);\n\n    return nextOp ();\n}\n\n#if d_m3HasFloat\nd_m3Op  (SetGlobal_f32)\n{\n    f32 * global = immediate (f32 *);\n    * global = _fp0;\n\n    return nextOp ();\n}\n\n\nd_m3Op  (SetGlobal_f64)\n{\n    f64 * global = immediate (f64 *);\n    * global = _fp0;\n\n    return nextOp ();\n}\n#endif\n\n\n#if d_m3SkipMemoryBoundsCheck\n#  define m3MemCheck(x) true\n#else\n#  define m3MemCheck(x) M3_LIKELY(x)\n#endif\n\n// memcpy here is to support non-aligned access on some platforms.\n\n/*\n#define d_m3Load(REG,DEST_TYPE,SRC_TYPE)                \\\nd_m3Op(DEST_TYPE##_Load_##SRC_TYPE##_r)                 \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u32 offset = immediate (u32);                       \\\n    u64 operand = (u32) _r0;                            \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (SRC_TYPE) <= _mem->memory->total_size     \\\n    )) {                                                \\\n        {                                               \\\n            u8* src8 = m3MemData(_mem) + operand;       \\\n            SRC_TYPE value;                             \\\n            memcpy(&value, src8, sizeof(value));        \\\n            M3_BSWAP_##SRC_TYPE(value);                 \\\n            REG = (DEST_TYPE)value;                     \\\n            d_m3TraceLoad(DEST_TYPE, operand, REG);     \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}                                                       \\\nd_m3Op(DEST_TYPE##_Load_##SRC_TYPE##_s)                 \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (SRC_TYPE) <= _mem->memory->total_size     \\\n    )){                                                \\\n        {                                               \\\n            u8* src8 = m3MemData(_mem) + operand;       \\\n            SRC_TYPE value;                             \\\n            memcpy(&value, src8, sizeof(value));        \\\n            M3_BSWAP_##SRC_TYPE(value);                 \\\n            REG = (DEST_TYPE)value;                     \\\n            d_m3TraceLoad(DEST_TYPE, operand, REG);     \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}\n*/\n\n///\n/// Segmented memory management\n///\nstatic inline u8* m3SegmentedMemAccess(IM3Memory mem, u64 offset, size_t size) \n{\n    ESP_LOGI(\"WASM3\", \"m3SegmentedMemAccess call\");\n    \n    // Verifica che l'accesso sia nei limiti della memoria totale\n    if (offset + size > mem->total_size) return NULL;\n\n    size_t segment_index = offset / mem->segment_size;\n    size_t segment_offset = offset % mem->segment_size;\n    \n    // Verifica se stiamo accedendo attraverso più segmenti\n    size_t end_segment = (offset + size - 1) / mem->segment_size;\n    \n    // Alloca tutti i segmenti necessari se non sono già allocati\n    for (size_t i = segment_index; i <= end_segment; i++) {\n        if (!mem->segments[i].is_allocated) {\n            if (!allocate_segment(mem, i)) {\n                ESP_LOGE(\"WASM3\", \"Failed to allocate segment %zu on access\", i);\n                return NULL;\n            }\n            ESP_LOGI(\"WASM3\", \"Lazy allocated segment %zu on access\", i);\n        }\n    }\n    \n    // Ora possiamo essere sicuri che il segmento è allocato\n    return ((u8*)mem->segments[segment_index].data) + segment_offset;\n}\n\n#define d_m3Load(REG,DEST_TYPE,SRC_TYPE)                \\\nd_m3Op(DEST_TYPE##_Load_##SRC_TYPE##_r)                 \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u32 offset = immediate (u32);                       \\\n    u64 operand = (u32) _r0;                           \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (SRC_TYPE) <= _mem->memory->total_size \\\n    )){                                                \\\n        {                                               \\\n            u8* src8 = m3SegmentedMemAccess(_mem, operand, sizeof(SRC_TYPE)); \\\n            if (src8) {                                 \\\n                SRC_TYPE value;                         \\\n                memcpy(&value, src8, sizeof(value));    \\\n                M3_BSWAP_##SRC_TYPE(value);            \\\n                REG = (DEST_TYPE)value;                 \\\n                d_m3TraceLoad(DEST_TYPE, operand, REG); \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n} else  d_outOfBounds;                                \\\n}                                                       \\\nd_m3Op(DEST_TYPE##_Load_##SRC_TYPE##_s)                 \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (SRC_TYPE) <= _mem->memory->total_size \\\n    )){                                                \\\n        {                                               \\\n            u8* src8 = m3SegmentedMemAccess(_mem, operand, sizeof(SRC_TYPE)); \\\n            if (src8) {                                 \\\n                SRC_TYPE value;                         \\\n                memcpy(&value, src8, sizeof(value));    \\\n                M3_BSWAP_##SRC_TYPE(value);            \\\n                REG = (DEST_TYPE)value;                 \\\n                d_m3TraceLoad(DEST_TYPE, operand, REG); \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n} else  d_outOfBounds;                                \\\n}\n\n//  printf (\"get: %d -> %d\\n\", operand + offset, (i64) REG);\n\n\n#define d_m3Load_i(DEST_TYPE, SRC_TYPE) d_m3Load(_r0, DEST_TYPE, SRC_TYPE)\n#define d_m3Load_f(DEST_TYPE, SRC_TYPE) d_m3Load(_fp0, DEST_TYPE, SRC_TYPE)\n\n#if d_m3HasFloat\nd_m3Load_f (f32, f32);\nd_m3Load_f (f64, f64);\n#endif\n\nd_m3Load_i (i32, i8);\nd_m3Load_i (i32, u8);\nd_m3Load_i (i32, i16);\nd_m3Load_i (i32, u16);\nd_m3Load_i (i32, i32);\n\nd_m3Load_i (i64, i8);\nd_m3Load_i (i64, u8);\nd_m3Load_i (i64, i16);\nd_m3Load_i (i64, u16);\nd_m3Load_i (i64, i32);\nd_m3Load_i (i64, u32);\nd_m3Load_i (i64, i64);\n\n/*\n#define d_m3Store(REG, SRC_TYPE, DEST_TYPE)             \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_rs)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, REG);     \\\n            u8* mem8 = m3MemData(_mem) + operand;       \\\n            DEST_TYPE val = (DEST_TYPE) REG;            \\\n            M3_BSWAP_##DEST_TYPE(val);                  \\\n            memcpy(mem8, &val, sizeof(val));            \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}                                                       \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_sr)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    const SRC_TYPE value = slot (SRC_TYPE);             \\\n    u64 operand = (u32) _r0;                            \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, value);   \\\n            u8* mem8 = m3MemData(_mem) + operand;       \\\n            DEST_TYPE val = (DEST_TYPE) value;          \\\n            M3_BSWAP_##DEST_TYPE(val);                  \\\n            memcpy(mem8, &val, sizeof(val));            \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}                                                       \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_ss)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    const SRC_TYPE value = slot (SRC_TYPE);             \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, value);   \\\n            u8* mem8 = m3MemData(_mem) + operand;       \\\n            DEST_TYPE val = (DEST_TYPE) value;          \\\n            M3_BSWAP_##DEST_TYPE(val);                  \\\n            memcpy(mem8, &val, sizeof(val));            \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}\n\n// both operands can be in regs when storing a float\n#define d_m3StoreFp(REG, TYPE)                          \\\nd_m3Op(TYPE##_Store_##TYPE##_rr)                      \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = (u32) _r0;                            \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (TYPE) <= _mem->memory->total_size         \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(TYPE, operand, REG);         \\\n            u8* mem8 = m3MemData(_mem) + operand;       \\\n            TYPE val = (TYPE) REG;                      \\\n            M3_BSWAP_##TYPE(val);                       \\\n            memcpy(mem8, &val, sizeof(val));            \\\n        \n    return nextOp();\\}                                               \\\n        nextOp ();                                      \\\n    } else d_outOfBounds;                               \\\n}\n*/\n\n///\n/// Segmented memory store\n///\n\n#define d_m3Store(REG, SRC_TYPE, DEST_TYPE)             \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_rs)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, REG);     \\\n            u8* mem8 = m3SegmentedMemAccess(_mem, operand, sizeof(DEST_TYPE)); \\\n            if (mem8) {                                 \\\n                DEST_TYPE val = (DEST_TYPE) REG;        \\\n                M3_BSWAP_##DEST_TYPE(val);              \\\n                memcpy(mem8, &val, sizeof(val));        \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n} else  d_outOfBounds;                                \\\n}                                                       \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_sr)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    const SRC_TYPE value = slot (SRC_TYPE);             \\\n    u64 operand = (u32) _r0;                            \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, value);   \\\n            u8* mem8 = m3SegmentedMemAccess(_mem, operand, sizeof(DEST_TYPE)); \\\n            if (mem8) {                                 \\\n                DEST_TYPE val = (DEST_TYPE) value;      \\\n                M3_BSWAP_##DEST_TYPE(val);              \\\n                memcpy(mem8, &val, sizeof(val));        \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n    } else return d_outOfBounds;                                \\\n}                                                       \\\nd_m3Op(SRC_TYPE##_Store_##DEST_TYPE##_ss)             \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    const SRC_TYPE value = slot (SRC_TYPE);             \\\n    u64 operand = slot (u32);                           \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (DEST_TYPE) <= _mem->memory->total_size    \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(SRC_TYPE, operand, value);   \\\n            u8* mem8 = m3SegmentedMemAccess(_mem, operand, sizeof(DEST_TYPE)); \\\n            if (mem8) {                                 \\\n                DEST_TYPE val = (DEST_TYPE) value;      \\\n                M3_BSWAP_##DEST_TYPE(val);              \\\n                memcpy(mem8, &val, sizeof(val));        \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n} else return d_outOfBounds;                                \\\n}\n\n#define d_m3StoreFp(REG, TYPE)                          \\\nd_m3Op(TYPE##_Store_##TYPE##_rr)                      \\\n{                                                       \\\n    d_m3TracePrepare                                    \\\n    u64 operand = (u32) _r0;                            \\\n    u32 offset = immediate (u32);                       \\\n    operand += offset;                                  \\\n                                                        \\\n    if (m3MemCheck(                                     \\\n        operand + sizeof (TYPE) <= _mem->memory->total_size         \\\n    )){                                                \\\n        {                                               \\\n            d_m3TraceStore(TYPE, operand, REG);         \\\n            u8* mem8 = m3SegmentedMemAccess(_mem, operand, sizeof(TYPE)); \\\n            if (mem8) {                                 \\\n                TYPE val = (TYPE) REG;                  \\\n                M3_BSWAP_##TYPE(val);                   \\\n                memcpy(mem8, &val, sizeof(val));        \\\n            } else return d_outOfBounds;                       \\\n        }                                               \\\nreturn         nextOp ();                                       \\\n} else  d_outOfBounds;                                \\\n}\n\n#define d_m3Store_i(SRC_TYPE, DEST_TYPE) d_m3Store(_r0, SRC_TYPE, DEST_TYPE)\n#define d_m3Store_f(SRC_TYPE, DEST_TYPE) d_m3Store(_fp0, SRC_TYPE, DEST_TYPE) d_m3StoreFp (_fp0, SRC_TYPE);\n\n#if d_m3HasFloat\nd_m3Store_f (f32, f32)\nd_m3Store_f (f64, f64)\n#endif\n\nd_m3Store_i (i32, u8)\nd_m3Store_i (i32, i16)\nd_m3Store_i (i32, i32)\n\nd_m3Store_i (i64, u8)\nd_m3Store_i (i64, i16)\nd_m3Store_i (i64, i32)\nd_m3Store_i (i64, i64)\n\n#undef m3MemCheck\n\n\n//---------------------------------------------------------------------------------------------------------------------\n// debug/profiling\n//---------------------------------------------------------------------------------------------------------------------\n#if d_m3EnableOpTracing\nd_m3RetSig  debugOp  (d_m3OpSig, cstr_t i_opcode)\n{\n    char name [100];\n    strcpy (name, strstr (i_opcode, \"op_\") + 3);\n    char * bracket = strstr (name, \"(\");\n    if (bracket) {\n        *bracket  = 0;\n    }\n\n    puts (name);\n    nextOpDirect();\n}\n# endif\n\n# if d_m3EnableOpProfiling\nd_m3RetSig  profileOp  (d_m3OpSig, cstr_t i_operationName)\n{\n    ProfileHit (i_operationName);\n\n    nextOpDirect();\n}\n# endif\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_env.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_env.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_env.h\n//\n//  Created by Steven Massey on 4/19/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include \"wasm3.h\"\n#include \"m3_code.h\"\n#include \"m3_compile.h\"\n#include \"m3_segmented_memory.h\"\n#include \"m3_exception.h\"\n#include \"m3_info.h\"\n#include \"m3_pointers.h\"\n#include \"m3_function.h\"\n\nd_m3BeginExternC\n\n// forced pre-declaration (m3_compile.h)\n//struct M3Compilation;  // Forward declaration\n//typedef struct M3Compilation M3Compilation;\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\n// Disabled\ntypedef struct M3MemoryInfo //todo: study its usage\n{\n    u32     initPages;\n    u32     maxPages;\n    u32     pageSize;\n}\nM3MemoryInfo;\n\n\n\n/* // Old M3Memory implementation\ntypedef struct M3Memory\n{\n    M3MemoryHeader *        mallocated;\n\n    u32                     numPages;\n    u32                     maxPages;\n    u32                     pageSize;\n\n    // Add segmentation support\n    void**                  segments;\n    size_t                  num_segments;\n    size_t                  segment_size;\n}\nM3Memory;\n\ntypedef M3Memory *          IM3Memory;\n*/\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3DataSegment\n{\n    const u8 *              initExpr;           // wasm code\n    const u8 *              data;\n\n    u32                     initExprSize;\n    u32                     memoryRegion;\n    u32                     size;\n}\nM3DataSegment;\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3Global\n{\n    M3ImportInfo            import;\n\n    union\n    {\n        i32 i32Value;\n        i64 i64Value;\n#if d_m3HasFloat\n        f64 f64Value;\n        f32 f32Value;\n#endif\n    };\n\n    cstr_t                  name;\n    bytes_t                 initExpr;       // wasm code\n    u32                     initExprSize;\n    u8                      type;\n    bool                    imported;\n    bool                    isMutable;\n}\nM3Global;\n\n\n//---------------------------------------------------------------------------------------------------------------------------------\ntypedef struct M3Module\n{\n    struct M3Runtime *      runtime;\n    struct M3Environment *  environment;\n\n    bytes_t                 wasmStart;\n    bytes_t                 wasmEnd;\n\n    cstr_t                  name;\n\n    u32                     numFuncTypes;\n    IM3FuncType *           funcTypes;              // array of pointers to list of FuncTypes\n\n    u32                     numFuncImports;\n    u32                     numFunctions;\n    u32                     allFunctions;           // allocated functions count\n    M3Function *            functions;\n\n    i32                     startFunction;\n\n    u32                     numDataSegments;\n    M3DataSegment *         dataSegments;\n\n    //u32                     importedGlobals;\n    u32                     numGlobals;\n    M3Global *              globals;\n\n    u32                     numElementSegments;\n    bytes_t                 elementSection;\n    bytes_t                 elementSectionEnd;\n\n    IM3Function *           table0;\n    u32                     table0Size;\n    const char*             table0ExportName;\n\n    M3MemoryInfo            memoryInfo;\n    M3ImportInfo            memoryImport;\n    bool                    memoryImported;\n    const char*             memoryExportName;\n\n    //bool                    hasWasmCodeCopy;\n\n    struct M3Module *       next;\n}\nM3Module;\n\nM3Result                    Module_AddGlobal            (IM3Module io_module, IM3Global * o_global, u8 i_type, bool i_mutable, bool i_isImported);\n\nM3Result                    Module_PreallocFunctions    (IM3Module io_module, u32 i_totalFunctions);\nM3Result                    Module_AddFunction          (IM3Module io_module, u32 i_typeIndex, IM3ImportInfo i_importInfo /* can be null */);\nIM3Function                 Module_GetFunction          (IM3Module i_module, u32 i_functionIndex);\n\nvoid                        Module_GenerateNames        (IM3Module i_module);\n\nvoid                        FreeImportInfo              (M3ImportInfo * i_info);\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3Environment\n{\n//    struct M3Runtime *      runtimes;\n\n    IM3FuncType             funcTypes;                          // linked list of unique M3FuncType structs that can be compared using pointer-equivalence\n\n    IM3FuncType             retFuncTypes [c_m3Type_unknown];    // these 'point' to elements in the linked list above.\n                                                                // the number of elements must match the basic types as per M3ValueType\n    M3CodePage *            pagesReleased;\n\n    M3SectionHandler        customSectionHandler;\n}\nM3Environment;\n\nvoid                        Environment_Release         (IM3Environment i_environment);\n\n// takes ownership of io_funcType and returns a pointer to the persistent version (could be same or different)\nvoid                        Environment_AddFuncType     (IM3Environment i_environment, IM3FuncType * io_funcType);\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef struct M3Runtime\n{\n    M3Compilation *           compilation;\n\n    IM3Environment          environment;\n\n    M3CodePage *            pagesOpen;      // linked list of code pages with writable space on them\n    M3CodePage *            pagesFull;      // linked list of at-capacity pages\n\n    u32                     numCodePages;\n    u32                     numActiveCodePages;\n\n    IM3Module               modules;        // linked list of imported modules\n\n    /* // Original stack management\n    void *                  stack;\n    void *                  originStack;\n    u32                     stackSize;\n    u32                     numStackSlots;\n    */\n\n    IM3Memory               stack;\n    IM3Memory               originStack;\n    u32                     maxStackSize;\n\n    IM3Function             lastCalled;     // last function that successfully executed\n\n    void *                  userdata;\n\n    M3Memory                memory;\n    u32                     memoryLimit;\n\n#if d_m3EnableStrace >= 2\n    u32                     callDepth;\n#endif\n\n    M3ErrorInfo             error;\n#if d_m3VerboseErrorMessages\n    char                    error_message[256]; // the actual buffer. M3ErrorInfo can point to this\n#endif\n\n#if d_m3RecordBacktraces\n    M3BacktraceInfo         backtrace;\n#endif\n\n\tu32\t\t\t\t\t\tnewCodePageSequence;\n}\nM3Runtime;\n\ntypedef void *              (* ModuleVisitor)           (IM3Module i_module, void * i_info);\nvoid *                      ForEachModule               (IM3Runtime i_runtime, ModuleVisitor i_visitor, void * i_info);\n\nvoid *                      v_FindFunction              (IM3Module i_module, const char * const i_name);\n\nIM3CodePage                 AcquireCodePage             (IM3Runtime io_runtime);\nIM3CodePage                 AcquireCodePageWithCapacity (IM3Runtime io_runtime, u32 i_lineCount);\nvoid                        ReleaseCodePage             (IM3Runtime io_runtime, IM3CodePage i_codePage);\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_libc.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_libc.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_libc.h\n//\n//  Created by Volodymyr Shymanskyy on 11/20/19.\n//  Copyright © 2019 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_core.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\nM3Result    m3_LinkLibC     (IM3Module io_module);\nM3Result    m3_LinkSpecTest (IM3Module io_module);\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_pointers.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_pointers.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#include \"esp_debug_helpers.h\"\n#include \"esp_heap_caps.h\"\n#include \"esp_log.h\"\n#include \"esp_system.h\"\n#include \"esp_memory_utils.h\"\n#include <setjmp.h>\n\n#include \"m3_pointers.h\"\n\nstatic const bool WASM_DEBUG_POINTERS = true;\nstatic const bool WASM_DEBUG_POINTERS_BACKTRACE = false;\nstatic const bool WASM_DEBUG_POINTERS_IGNORE_OUTSIDE_HEAP = false; \nstatic const bool WASM_POINTERS_CHECK_BOUNDS = false;\n\nptr_check_result_t validate_pointer(const void* ptr, size_t expected_size) {\n    // 1. Controllo NULL pointer\n    if (ptr == NULL) {\n        if(WASM_DEBUG_POINTERS) ESP_LOGE(\"WASM3\", \"NULL pointer detected\");\n        return PTR_CHECK_NULL;\n    }\n\n    // 2. Verifica allineamento (assumendo che M3Memory richieda allineamento a 4 byte)\n    if (((uintptr_t)ptr) % 4 != 0) {\n        if(WASM_DEBUG_POINTERS) ESP_LOGE(\"WASM3\", \"Unaligned pointer: %p\", ptr);\n        return PTR_CHECK_UNALIGNED;\n    }\n\n    // 3. Verifica che il puntatore sia in un range di memoria valido\n    // Questi valori vanno adattati in base alla configurazione della memoria dell'ESP32\n    extern uint32_t _heap_start, _heap_end;\n    if ((uintptr_t)ptr < (uintptr_t)&_heap_start || \n        (uintptr_t)ptr + expected_size > (uintptr_t)&_heap_end) {\n        if(WASM_DEBUG_POINTERS) ESP_LOGE(\"WASM3\", \"Pointer out of valid memory range: %p\", ptr);\n        return PTR_CHECK_OUT_OF_BOUNDS;\n    }\n\n    return PTR_CHECK_OK;\n}\n\n/**\n * @brief Verifica se un puntatore può essere liberato in sicurezza\n * @param ptr Puntatore da verificare\n * @return true se il puntatore è valido per free(), false altrimenti\n */\nbool is_ptr_freeable(void* ptr) {\n    // 1. Controllo puntatore NULL\n    if (ptr == NULL) {\n        if(WASM_DEBUG_POINTERS) ESP_LOGW(\"WASM3\", \"Null pointer detected\");\n        if(WASM_DEBUG_POINTERS_BACKTRACE) esp_backtrace_print(100);\n        return false;\n    }\n\n    // 2. Verifica allineamento (l'heap ESP32 richiede allineamento a 8 byte)\n    if ((uint32_t)ptr & 0x3) { // disabled\n        if(WASM_DEBUG_POINTERS){\n             ESP_LOGE(\"WASM3\", \"Unaligned pointer: %p\", ptr);\n             if(WASM_DEBUG_POINTERS_BACKTRACE) esp_backtrace_print(100);\n        }\n        return false;\n    }\n\n    // 3. Verifica che il puntatore sia nell'heap DRAM\n    if (!heap_caps_check_integrity_addr((intptr_t)ptr, true)) {\n        if(WASM_DEBUG_POINTERS && WASM_DEBUG_POINTERS_IGNORE_OUTSIDE_HEAP) {\n            ESP_LOGE(\"WASM3\", \"Pointer not in valid heap region: %p\", ptr);\n            if(WASM_DEBUG_POINTERS_BACKTRACE) esp_backtrace_print(100);\n        }\n        return false;\n    }\n\n    // 4. Verifica che il blocco di memoria abbia un header valido\n    if(WASM_POINTERS_CHECK_BOUNDS){\n        multi_heap_info_t info;\n        heap_caps_get_info(&info, MALLOC_CAP_8BIT);\n        if ((uintptr_t)ptr < 0 || (uintptr_t)ptr > (info.total_free_bytes + info.total_allocated_bytes)) {\n            if(WASM_DEBUG_POINTERS) ESP_LOGE(\"WASM3\", \"Pointer outside heap bounds: %p\", ptr);\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * @brief Libera la memoria in modo sicuro\n * @param ptr Puntatore da liberare\n * @return true se l'operazione è riuscita, false altrimenti\n */\nbool safe_free(void* ptr) {\n    if (!(ptr)) {\n        return false;\n    }\n\n    if (!is_ptr_freeable(ptr)) {\n        return false;\n    }\n\n    free(ptr);\n    ptr = NULL;  // Previene use-after-free\n    return true;\n}\n\n///\n///\n///\n\n// Verifica se un puntatore è valido per le operazioni di memoria\nbool is_ptr_valid(const void* ptr) {\n    if (!ptr) {\n        ESP_LOGW(\"WASM3\", \"Null pointer detected\");\n        return false;\n    }\n    \n    if (!esp_ptr_in_dram(ptr)) {\n        ESP_LOGW(\"WASM3\", \"Pointer %p not in DRAM\", ptr);\n        return false;\n    }\n    \n    if (!heap_caps_check_integrity_addr(ptr, false)) {\n        ESP_LOGW(\"WASM3\", \"Heap corruption detected at %p\", ptr);\n        return false;\n    }\n    \n    return true;\n}\n\n// Wrapper sicuro per free\nbool safe_free_with_check(void** ptr) {\n    if (!ptr || !(*ptr)) {\n        ESP_LOGW(\"WASM3\", \"Attempting to free null pointer\");\n        return false;\n    }\n    \n    if (!is_ptr_valid(*ptr)) {\n        ESP_LOGW(\"WASM3\", \"Invalid pointer detected during free\");\n        *ptr = NULL;\n        return false;\n    }\n    \n    // Backup del puntatore per il logging\n    void* original_ptr = *ptr;\n    \n    // Tentativo di free\n    heap_caps_free(*ptr);\n    \n    // Clear del puntatore dopo la free\n    *ptr = NULL;\n    \n    ESP_LOGD(\"WASM3\", \"Successfully freed memory at %p\", original_ptr);\n    return true;\n}\n\nstatic jmp_buf g_jmpBuf;\n\n// Wrapper sicuro per m3_Int_Free specifica per WASM3\nbool safe_m3_int_free(void** ptr) {\n    if (!ptr || !(*ptr)) {\n        return false;\n    }\n    \n    // Salva il valore originale per il logging\n    void* original_ptr = *ptr;\n    \n    // Setup error handler\n    if (setjmp(g_jmpBuf) == 0) {\n        // Tenta l'operazione in un contesto protetto\n        if (is_ptr_valid(*ptr)) {\n            m3_Int_Free(*ptr);\n            *ptr = NULL;\n            ESP_LOGD(\"WASM3\", \"Successfully freed WASM3 memory at %p\", original_ptr);\n            return true;\n        }\n    } else {\n        ESP_LOGE(\"WASM3\", \"Exception during WASM3 free operation at %p\", original_ptr);\n    }\n    \n    return false;\n}\n\n///\n///\n///\n\nstatic inline bool is_address_in_range(uintptr_t ptr) {\n    // Verifica range DRAM per ESP32\n    const uint32_t VALID_HEAP_START = 0x3FFAE000; // Inizio dell'heap (DRAM)\n    const uint32_t VALID_HEAP_END = 0x40000000;   // Fine dell'heap\n\n    uint32_t addr = (uint32_t)ptr;\n    return addr >= VALID_HEAP_START && addr < VALID_HEAP_END;\n}\n\nbool ultra_safe_ptr_valid(const void* ptr) {\n    if (!ptr) {\n        ESP_LOGW(\"WASM3\", \"Null pointer detected\");\n        return false;\n    }\n    \n    // Cast sicuro a uintptr_t per manipolazione numerica\n    uintptr_t addr = (uintptr_t)ptr;\n    \n    // Verifica allineamento (assumendo architettura 32-bit)\n    /*if (addr & 0x3) {\n        ESP_LOGW(\"WASM3\", \"Pointer %p is not aligned\", ptr);\n        return false;\n    }*/\n\n    /*if(!heap_caps_check_integrity_addr(addr, false)) { // useless: it crashes\n        ESP_LOGW(\"WASM3\", \"Pointer %p: no integrity\", ptr);\n        return false;\n    }*/\n\n    // Verifica range base\n    if (!is_address_in_range(addr)) {\n        ESP_LOGW(\"WASM3\", \"Pointer %p outside valid memory range\", ptr);\n        return false;\n    }\n\n    // Opzionale: verifica pattern di corruzione comuni\n    /*uint32_t first_word;\n    if (esp_ptr_in_dram(ptr) && // Verifica extra sicurezza\n        esp_flash_read_safe((void*)&first_word, ptr, sizeof(uint32_t))) {\n        if (first_word == 0xFFFFFFFF || first_word == 0xEEEEEEEE) {\n            ESP_LOGW(\"WASM3\", \"Pointer %p shows corruption pattern\", ptr);\n            return false;\n        }\n    }*/\n\n    return true;\n}\n\n///\n///\n///\n\n#include \"esp_heap_caps.h\"\n#include \"esp_log.h\"\n#include <stdint.h>\n\n#define SAFE_TAG \"SafeFree\"\nstatic const bool WASM_DEBUG_SAFE_TAG = false;\n\n// Struttura per memorizzare informazioni sui blocchi liberati\n#define MAX_TRACKED_PTRS 64\nstatic struct {\n    void* ptrs[MAX_TRACKED_PTRS];\n    int count;\n} freed_ptrs = {0};\n\nstatic inline bool is_in_dram_range(const void* ptr) {\n    // Uso uint32_t come nel file originale\n    extern uint32_t _heap_start, _heap_end;\n    \n    uintptr_t addr = (uintptr_t)ptr;\n    uintptr_t start = (uintptr_t)&_heap_start;\n    uintptr_t end = (uintptr_t)&_heap_end;\n    \n    return (addr >= start && addr < end);\n}\n\nstatic bool was_previously_freed(const void* ptr) {\n    for (int i = 0; i < freed_ptrs.count; i++) {\n        if (freed_ptrs.ptrs[i] == ptr) return true;\n    }\n    return false;\n}\n\nstatic void track_freed_ptr(const void* ptr) {\n    if (freed_ptrs.count < MAX_TRACKED_PTRS) {\n        freed_ptrs.ptrs[freed_ptrs.count++] = (void*)ptr;\n    }\n}\n\nptr_status_t validate_ptr_for_free(const void* ptr) {\n    if (!ptr) {\n        return PTR_NULL;\n    }\n\n    // Verifica allineamento (32-bit)\n    if (((uintptr_t)ptr & 0x3) != 0) {\n        if(WASM_DEBUG_SAFE_TAG) ESP_LOGW(SAFE_TAG, \"Unaligned pointer: %p\", ptr);\n        return PTR_UNALIGNED;\n    }\n\n    // Verifica range DRAM\n    if (!is_in_dram_range(ptr)) {\n        if(WASM_DEBUG_SAFE_TAG) ESP_LOGW(SAFE_TAG, \"Pointer outside DRAM: %p\", ptr);\n        return PTR_OUT_OF_BOUNDS;\n    }\n\n    // Verifica se già liberato\n    if (was_previously_freed(ptr)) {\n        if(WASM_DEBUG_SAFE_TAG) ESP_LOGW(SAFE_TAG, \"Pointer already freed: %p\", ptr);\n        return PTR_ALREADY_FREED;\n    }\n\n    // Verifica integrità del blocco heap\n    if (!heap_caps_check_integrity_addr(ptr, true)) {\n        if(WASM_DEBUG_SAFE_TAG) ESP_LOGW(SAFE_TAG, \"Corrupted heap block: %p\", ptr);\n        return PTR_CORRUPTED;\n    }\n\n    return PTR_OK;\n}\n\nbool ultra_safe_free(void** ptr) {\n    if (!ptr || !(*ptr)) {\n        return false;\n    }\n\n    void* original = *ptr;\n    ptr_status_t status = validate_ptr_for_free(original);\n    \n    if (status != PTR_OK) {\n        if(WASM_DEBUG_SAFE_TAG) ESP_LOGW(SAFE_TAG, \"Invalid free attempt for %p (status: %d)\", original, status);\n        *ptr = NULL; // Previene ulteriori tentativi di free\n        return false;\n    }\n\n    // Free sicura con tracking\n    heap_caps_free(original);\n    track_freed_ptr(original);\n    *ptr = NULL;\n    \n    return true;\n}\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_parse.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_parse.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#pragma once\n\n#include \"m3_env.h\"\n#include \"m3_compile.h\"\n#include \"m3_exception.h\"\n#include \"m3_info.h\"\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_bind.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_bind.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_bind.h\n//\n//  Created by Steven Massey on 2/27/20.\n//  Copyright © 2020 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_env.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\nu8          ConvertTypeCharToTypeId     (char i_code);\nM3Result    SignatureToFuncType         (IM3FuncType * o_functionType, ccstr_t i_signature);\n\nd_m3EndExternC\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_code.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_code.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_code.c\n//\n//  Created by Steven Massey on 4/19/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#include <limits.h>\n\n#include \"m3_core.h\"\n#include \"m3_exception.h\"\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\ntypedef M3Runtime; // forced pre-declaration (m3_env.h)\n\nIM3CodePage  NewCodePage  (IM3Runtime i_runtime, u32 i_minNumLines)\n{\n    IM3CodePage page;\n\n    // check multiplication overflow\n    if (i_minNumLines > UINT_MAX / sizeof (code_t)) {\n        return NULL;\n    }\n    u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;\n\n    // check addition overflow\n    if (pageSize < sizeof (M3CodePageHeader)) {\n        return NULL;\n    }\n\n    pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align\n    // check alignment overflow\n    if (pageSize == 0) {\n        return NULL;\n    }\n\n    page = (IM3CodePage)m3_Malloc (\"M3CodePage\", pageSize);\n\n    if (page)\n    {\n        page->info.sequence = ++i_runtime->newCodePageSequence;\n        page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);\n\n#if d_m3RecordBacktraces\n        u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;\n        page->info.mapping = (M3CodeMappingPage *)m3_Malloc (\"M3CodeMappingPage\", pageSizeBt);\n\n        if (page->info.mapping)\n        {\n            page->info.mapping->size = 0;\n            page->info.mapping->capacity = page->info.numLines;\n        }\n        else\n        {\n            m3_Free (page);\n            return NULL;\n        }\n        page->info.mapping->basePC = GetPageStartPC(page);\n#endif // d_m3RecordBacktraces\n\n        m3log (runtime, \"new page: %p; seq: %d; bytes: %d; lines: %d\", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);\n    }\n\n    return page;\n}\n\n\nvoid  FreeCodePages  (IM3CodePage * io_list)\n{\n    IM3CodePage page = * io_list;\n\n    while (page)\n    {\n        m3log (code, \"free page: %d; %p; util: %3.1f%%\", page->info.sequence, page, 100. * page->info.lineIndex / page->info.numLines);\n\n        IM3CodePage next = page->info.next;\n#if d_m3RecordBacktraces\n        m3_Free (page->info.mapping);\n#endif // d_m3RecordBacktraces\n        m3_Free (page);\n        page = next;\n    }\n\n    * io_list = NULL;\n}\n\n\nu32  NumFreeLines  (IM3CodePage i_page)\n{\n    d_m3Assert (i_page->info.lineIndex <= i_page->info.numLines);\n\n    return i_page->info.numLines - i_page->info.lineIndex;\n}\n\n\nvoid  EmitWord_impl  (IM3CodePage i_page, void * i_word)\n{                                                                       d_m3Assert (i_page->info.lineIndex+1 <= i_page->info.numLines);\n    i_page->code [i_page->info.lineIndex++] = i_word;\n}\n\nvoid  EmitWord32  (IM3CodePage i_page, const u32 i_word)\n{                                                                       d_m3Assert (i_page->info.lineIndex+1 <= i_page->info.numLines);\n    memcpy (& i_page->code[i_page->info.lineIndex++], & i_word, sizeof(i_word));\n}\n\nvoid  EmitWord64  (IM3CodePage i_page, const u64 i_word)\n{\n#if M3_SIZEOF_PTR == 4\n                                                                        d_m3Assert (i_page->info.lineIndex+2 <= i_page->info.numLines);\n    memcpy (& i_page->code[i_page->info.lineIndex], & i_word, sizeof(i_word));\n    i_page->info.lineIndex += 2;\n#else\n                                                                        d_m3Assert (i_page->info.lineIndex+1 <= i_page->info.numLines);\n    memcpy (& i_page->code[i_page->info.lineIndex], & i_word, sizeof(i_word));\n    i_page->info.lineIndex += 1;\n#endif\n}\n\n\n#if d_m3RecordBacktraces\nvoid  EmitMappingEntry  (IM3CodePage i_page, u32 i_moduleOffset)\n{\n    M3CodeMappingPage * page = i_page->info.mapping;\n                                                                        d_m3Assert (page->size < page->capacity);\n\n    M3CodeMapEntry * entry = & page->entries[page->size++];\n    pc_t pc = GetPagePC (i_page);\n\n    entry->pcOffset = pc - page->basePC;\n    entry->moduleOffset = i_moduleOffset;\n}\n#endif // d_m3RecordBacktraces\n\npc_t  GetPageStartPC  (IM3CodePage i_page)\n{\n    return & i_page->code [0];\n}\n\n\npc_t  GetPagePC  (IM3CodePage i_page)\n{\n    if (i_page)\n        return & i_page->code [i_page->info.lineIndex];\n    else\n        return NULL;\n}\n\n\nvoid  PushCodePage  (IM3CodePage * i_list, IM3CodePage i_codePage)\n{\n    IM3CodePage next = * i_list;\n    i_codePage->info.next = next;\n    * i_list = i_codePage;\n}\n\n\nIM3CodePage  PopCodePage  (IM3CodePage * i_list)\n{\n    IM3CodePage page = * i_list;\n    * i_list = page->info.next;\n    page->info.next = NULL;\n\n    return page;\n}\n\n\n\nu32  FindCodePageEnd  (IM3CodePage i_list, IM3CodePage * o_end)\n{\n    u32 numPages = 0;\n    * o_end = NULL;\n\n    while (i_list)\n    {\n        * o_end = i_list;\n        ++numPages;\n        i_list = i_list->info.next;\n    }\n\n    return numPages;\n}\n\n\nu32  CountCodePages  (IM3CodePage i_list)\n{\n    IM3CodePage unused;\n    return FindCodePageEnd (i_list, & unused);\n}\n\n\nIM3CodePage GetEndCodePage  (IM3CodePage i_list)\n{\n    IM3CodePage end;\n    FindCodePageEnd (i_list, & end);\n\n    return end;\n}\n\n#if d_m3RecordBacktraces\nbool  ContainsPC  (IM3CodePage i_page, pc_t i_pc)\n{\n    return GetPageStartPC (i_page) <= i_pc && i_pc < GetPagePC (i_page);\n}\n\n\nbool  MapPCToOffset  (IM3CodePage i_page, pc_t i_pc, u32 * o_moduleOffset)\n{\n    M3CodeMappingPage * mapping = i_page->info.mapping;\n\n    u32 pcOffset = i_pc - mapping->basePC;\n\n    u32 left = 0;\n    u32 right = mapping->size;\n\n    while (left < right)\n    {\n        u32 mid = left + (right - left) / 2;\n\n        if (mapping->entries[mid].pcOffset < pcOffset)\n        {\n            left = mid + 1;\n        }\n        else if (mapping->entries[mid].pcOffset > pcOffset)\n        {\n            right = mid;\n        }\n        else\n        {\n            *o_moduleOffset = mapping->entries[mid].moduleOffset;\n            return true;\n        }\n    }\n\n    // Getting here means left is now one more than the element we want.\n    if (left > 0)\n    {\n        left--;\n        *o_moduleOffset = mapping->entries[left].moduleOffset;\n        return true;\n    }\n    else return false;\n}\n#endif // d_m3RecordBacktraces\n\n//---------------------------------------------------------------------------------------------------------------------------------\n\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_info.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_info.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_info.h\n//\n//  Created by Steven Massey on 12/6/19.\n//  Copyright © 2019 Steven Massey. All rights reserved.\n//\n\n#pragma once\n\n#include \"m3_compile.h\"\n#include \"m3_exception.h\"\n\nd_m3BeginExternC\n\nvoid            ProfileHit              (cstr_t i_operationName);\n\n#ifdef DEBUG\n\nvoid            dump_type_stack         (IM3Compilation o);\nvoid            log_opcode              (IM3Compilation o, m3opcode_t i_opcode);\nconst char *    get_indention_string    (IM3Compilation o);\nvoid            log_emit                (IM3Compilation o, IM3Operation i_operation);\n\ncstr_t          SPrintFuncTypeSignature (IM3FuncType i_funcType);\n\n#else // DEBUG\n\n#define         dump_type_stack(...)      {}\n#define         log_opcode(...)           {}\n#define         get_indention_string(...) \"\"\n#define         emit_stack_dump(...)      {}\n#define         log_emit(...)             {}\n\n#endif // DEBUG\n\nd_m3EndExternC\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_function.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_function.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_function.c\n//\n//  Created by Steven Massey on 4/7/21.\n//  Copyright © 2021 Steven Massey. All rights reserved.\n//\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"m3_function.h\"\n//#include \"m3_env.h\"\n#include \"m3_bind.h\"\n#include \"m3_pointers.h\"\n\nM3Result AllocFuncType (IM3FuncType * o_functionType, u32 i_numTypes)\n{\n    *o_functionType = (IM3FuncType) m3_Int_Malloc (\"M3FuncType\", sizeof (M3FuncType) + i_numTypes); \n\n    if(!(*o_functionType)){\n        ESP_LOGE(\"WASM3\", \"AllocFuncType allocation failed\");\n    }\n\n    return (*o_functionType) ? m3Err_none : m3Err_mallocFailed;\n}\n\n\n/*bool  AreFuncTypesEqual  (const IM3FuncType i_typeA, const IM3FuncType i_typeB)\n{\n    if (i_typeA->numRets == i_typeB->numRets && i_typeA->numArgs == i_typeB->numArgs)\n    {\n        return (memcmp (i_typeA->types, i_typeB->types, i_typeA->numRets + i_typeA->numArgs) == 0);\n    }\n\n    return false;\n}*/\n\nbool AreFuncTypesEqual(const IM3FuncType i_typeA, const IM3FuncType i_typeB)\n{\n    bool a_valid = ultra_safe_ptr_valid(i_typeA);\n    bool b_valid = ultra_safe_ptr_valid(i_typeB);\n    if(!a_valid || !b_valid){        \n        //ESP_LOGW(\"WASM3\", \"Invalid pointer for AreFuncTypesEqual\");\n        return false;\n    }\n\n    // Validazione puntatori\n    //if (!i_typeA || !i_typeB)\n    //    return false;\n        \n    if (i_typeA->numRets == i_typeB->numRets && i_typeA->numArgs == i_typeB->numArgs)\n    {\n        size_t size = i_typeA->numRets + i_typeA->numArgs;\n        \n        // Confronto byte per byte invece di memcmp\n        for (size_t i = 0; i < size; i++) {\n            if (i_typeA->types[i] != i_typeB->types[i])\n                return false;\n        }\n        return true;\n    }\n\n    return false;\n}\n\nu16  GetFuncTypeNumParams  (const IM3FuncType i_funcType)\n{\n    return i_funcType ? i_funcType->numArgs : 0;\n}\n\n\nu8  GetFuncTypeParamType  (const IM3FuncType i_funcType, u16 i_index)\n{\n    u8 type = c_m3Type_unknown;\n\n    if (i_funcType)\n    {\n        if (i_index < i_funcType->numArgs)\n        {\n            type = i_funcType->types [i_funcType->numRets + i_index];\n        }\n    }\n\n    return type;\n}\n\n\n\nu16  GetFuncTypeNumResults  (const IM3FuncType i_funcType)\n{\n    return i_funcType ? i_funcType->numRets : 0;\n}\n\n\nu8  GetFuncTypeResultType  (const IM3FuncType i_funcType, u16 i_index)\n{\n    u8 type = c_m3Type_unknown;\n\n    if (i_funcType)\n    {\n        if (i_index < i_funcType->numRets)\n        {\n            type = i_funcType->types [i_index];\n        }\n    }\n\n    return type;\n}\n\n\n//---------------------------------------------------------------------------------------------------------------\n\n\nvoid FreeImportInfo (M3ImportInfo * i_info)\n{\n    m3_Int_Free (i_info->moduleUtf8);\n    m3_Int_Free (i_info->fieldUtf8);\n}\n\nstatic const bool WASM_DEBUG_FUNCTION_RELEASE = false;\n\nvoid  Function_Release  (IM3Function i_function)\n{    \n    if(WASM_DEBUG_FUNCTION_RELEASE) ESP_LOGI(\"WASM3\", \"Function_Release called\");\n    //m3_Int_Free (i_function->constants);\n\n    safe_m3_int_free((void**)&(i_function->constants));\n\n    for (int i = 0; i < i_function->numNames; i++)\n    {\n        if(WASM_DEBUG_FUNCTION_RELEASE) ESP_LOGI(\"WASM3\", \"freeing i_function->numNames[%d]\", i);\n        // name can be an alias of fieldUtf8\n        if (i_function->names[i] != i_function->import.fieldUtf8)\n        {\n            safe_m3_int_free((void**)&(i_function->names[i]));\n        }\n    }\n\n    if(WASM_DEBUG_FUNCTION_RELEASE) ESP_LOGI(\"WASM3\", \"FreeImportInfo(..)\");\n    FreeImportInfo (& i_function->import);\n\n    if (i_function->ownsWasmCode){\n        if(WASM_DEBUG_FUNCTION_RELEASE) ESP_LOGI(\"WASM3\", \"free i_function->wasm\");\n        safe_m3_int_free((void**)&(i_function->wasm));\n    }\n\n    // Function_FreeCompiledCode (func);\n\n#   if (d_m3EnableCodePageRefCounting)\n    {\n        m3_Int_Free (i_function->codePageRefs);\n        i_function->numCodePageRefs = 0;\n    }\n\n   \n#   endif\n\n    safe_m3_int_free((void**)&(i_function));\n}\n\n\nvoid  Function_FreeCompiledCode (IM3Function i_function)\n{\n#   if (d_m3EnableCodePageRefCounting)\n    {\n        i_function->compiled = NULL;\n\n        while (i_function->numCodePageRefs--)\n        {\n            IM3CodePage page = i_function->codePageRefs [i_function->numCodePageRefs];\n\n            if (--(page->info.usageCount) == 0)\n            {\n//                printf (\"free %p\\n\", page);\n            }\n        }\n\n        m3_Int_Free (i_function->codePageRefs);\n\n        Runtime_ReleaseCodePages (i_function->module->runtime);\n    }\n#   endif\n}\n\n\ncstr_t  m3_GetFunctionName  (IM3Function i_function)\n{\n    u16 numNames = 0;\n    cstr_t *names = GetFunctionNames(i_function, &numNames);\n    if (numNames > 0)\n        return names[0];\n    else\n        return \"<unnamed>\";\n}\n\n\nIM3Module  m3_GetFunctionModule  (IM3Function i_function)\n{\n    return i_function ? i_function->module : NULL;\n}\n\n\ncstr_t *  GetFunctionNames  (IM3Function i_function, u16 * o_numNames)\n{\n    if (!i_function || !o_numNames)\n        return NULL;\n\n    if (i_function->import.fieldUtf8)\n    {\n        *o_numNames = 1;\n        return &i_function->import.fieldUtf8;\n    }\n    else\n    {\n        *o_numNames = i_function->numNames;\n        return i_function->names;\n    }\n}\n\n\ncstr_t  GetFunctionImportModuleName  (IM3Function i_function)\n{\n    return (i_function->import.moduleUtf8) ? i_function->import.moduleUtf8 : \"\";\n}\n\n\nu16  GetFunctionNumArgs  (IM3Function i_function)\n{\n    u16 numArgs = 0;\n\n    if (i_function)\n    {\n        if (i_function->funcType)\n            numArgs = i_function->funcType->numArgs;\n    }\n\n    return numArgs;\n}\n\nu8  GetFunctionArgType  (IM3Function i_function, u32 i_index)\n{\n    u8 type = c_m3Type_none;\n\n    if (i_index < GetFunctionNumArgs (i_function))\n    {\n        u32 numReturns = i_function->funcType->numRets;\n\n        type = i_function->funcType->types [numReturns + i_index];\n    }\n\n    return type;\n}\n\n\nu16  GetFunctionNumReturns  (IM3Function i_function)\n{\n    u16 numReturns = 0;\n\n    if (i_function)\n    {\n        if (i_function->funcType)\n            numReturns = i_function->funcType->numRets;\n    }\n\n    return numReturns;\n}\n\n\nu8  GetFunctionReturnType  (const IM3Function i_function, u16 i_index)\n{\n    return i_function ? GetFuncTypeResultType (i_function->funcType, i_index) : c_m3Type_unknown;\n}\n\n\nu32  GetFunctionNumArgsAndLocals (IM3Function i_function)\n{\n    if (i_function)\n        return i_function->numLocals + GetFunctionNumArgs (i_function);\n    else\n        return 0;\n}\n\n///\n/// Function signature\n///\n\nstatic const bool WASM_DEBUG_PARSE_FUNCTION_SIGNATURE = true;\n\n// (Probably) abandoned function (SignatureToFuncType from WASM3)\nM3FuncType* ParseFunctionSignature(const char* signature) {\n    if (!signature) {\n        ESP_LOGW(\"WASM3\", \"ParseFunctionSignature: returns NULL (null signature)\");\n        return NULL;\n    }\n\n    if(WASM_DEBUG_PARSE_FUNCTION_SIGNATURE) ESP_LOGI(\"WASM3\", \"ParseFunctionSignature called with signature: %s\", signature);\n    \n    size_t len = strlen(signature);\n    u16 numRets = 0;\n    u16 numArgs = 0;\n    size_t i = 0;\n    \n    // Process return type (before the parenthesis)\n    if (signature[i] == 'v') {\n        numRets = 0;\n    } else {\n        switch (signature[i]) {\n            case 'i':\n                numRets = 1;\n                break;\n            case 'I':\n                numRets = 1;\n                break;\n            case 'f':\n                numRets = 1;\n                break;\n            case 'F':\n                numRets = 1;\n                break;\n            default:\n                ESP_LOGW(\"WASM3\", \"ParseFunctionSignature: Invalid return type %c\", signature[i]);\n                return NULL;\n        }\n    }\n    \n    // Find opening parenthesis\n    while (i < len && signature[i] != '(') i++;\n    if (i >= len) {\n        ESP_LOGW(\"WASM3\", \"ParseFunctionSignature: Missing opening parenthesis\");\n        return NULL;\n    }\n    i++; // Skip '('\n    \n    // Count arguments until ')'\n    size_t args_start = i;\n    while (i < len && signature[i] != ')') {\n        if (signature[i] != ' ') numArgs++;\n        i++;\n    }\n    \n    if (i >= len || signature[i] != ')') {\n        ESP_LOGW(\"WASM3\", \"ParseFunctionSignature: Missing closing parenthesis\");\n        return NULL;\n    }\n    \n    // Allocate memory for the structure plus the types array\n    //size_t totalSize = sizeof(M3FuncType) + ((numRets + numArgs) * sizeof(u8));\n    IM3FuncType funcType = NULL; // (IM3FuncType)m3_Int_Malloc(\"M3FuncType\", totalSize); // or m3_Int_AllocStruct(M3FuncType)\n\n    M3Result result;\n    if((result = AllocFuncType(&funcType, numRets + numArgs)) != NULL){\n        ESP_LOGE(\"WASM3\", \"ParseFunctionSignature: AllocFuncType error: %s\", result);\n        return NULL;\n    }\n\n    /*if (!funcType) {\n        ESP_LOGW(\"WASM3\", \"ParseFunctionSignature: Memory allocation failed\");\n        return NULL;\n    }*/\n    \n    // Initialize the structure\n    funcType->next = NULL;\n    funcType->numRets = numRets;\n    funcType->numArgs = numArgs;\n    \n    // Fill the types array\n    u8* types = funcType->types;\n    \n    // First process return type (if any)\n    if (numRets > 0) {\n        switch (signature[0]) {\n            case 'i':\n                *types = M3_TYPE_I32;\n                break;\n            case 'I':\n                *types = M3_TYPE_I64;\n                break;\n            case 'f':\n                *types = M3_TYPE_F32;\n                break;\n            case 'F':\n                *types = M3_TYPE_F64;\n                break;\n            default:\n                ESP_LOGE(\"WASM3\", \"ParseFunctionSignature: Invalid return type: %c\", signature[i]);\n                m3_Int_Free(funcType);\n                return NULL;\n        }\n    }\n\n    types++;\n    \n    // Process arguments\n    for (i = args_start; signature[i] != ')'; i++) {\n        if (signature[i] != ' ') {\n            switch (signature[i]) {\n                case 'i':\n                    *types = M3_TYPE_I32;\n                    break;\n                case 'I':\n                    *types = M3_TYPE_I64;\n                    break;\n                case 'f':\n                    *types = M3_TYPE_F32;\n                    break;\n                case 'F':\n                    *types = M3_TYPE_F64;\n                    break;\n                default:\n                    ESP_LOGE(\"WASM3\", \"ParseFunctionSignature: Unknown argument type %c at position %d\", signature[i], i);\n                    m3_Int_Free(funcType);\n                    return NULL;\n            }\n\n            types++;\n        }\n    }\n\n    if (WASM_DEBUG_PARSE_FUNCTION_SIGNATURE) {\n        ESP_LOGI(\"WASM3\", \"ParseFunctionSignature: Successfully parsed signature '%s' (returns: %d, args: %d)\", \n                 signature, numRets, numArgs);\n    }\n    \n    return funcType;\n}\n\n// Utility function to free the M3FuncType structure\nvoid FreeFuncType(M3FuncType* funcType) {\n    default_allocator.free(funcType);\n}\n\n///\n/// Register function name\n///\n\nstatic const bool WASM_DEBUG_ADD_FUNCTION_NAME = true;\nM3Result addFunctionToModule(IM3Module module, const char* functionName, const char* signature) {\n    if(WASM_DEBUG_ADD_FUNCTION_NAME) ESP_LOGI(\"WASM3\", \"addFunctionToModule called\");\n\n    if (!module || !functionName) {\n        return \"Invalid parameters\";\n    }\n\n    // Alloca spazio per il nuovo nome della funzione\n    if(WASM_DEBUG_ADD_FUNCTION_NAME) ESP_LOGI(\"WASM3\", \"m3_Int_AllocArray function name\");\n    char* nameCopy = m3_Int_AllocArray(char, strlen(functionName) + 1);\n    if (!nameCopy) {\n        return \"nameCopy memory allocation failed\";\n    }\n    strcpy(nameCopy, functionName);\n\n    // Crea una nuova entry nella function table   \n    u32 index = module->numFunctions++;\n    //ESP_LOGI(\"WASM3\", \"index: %lu, allFunctions: %lu\", index, module->allFunctions); // just debug\n\n    if(WASM_DEBUG_ADD_FUNCTION_NAME) ESP_LOGI(\"WASM3\", \"Module_PreallocFunctions\");\n    Module_PreallocFunctions(module, module->numFunctions);\n\n    if(WASM_DEBUG_ADD_FUNCTION_NAME) ESP_LOGI(\"WASM3\", \"Module_GetFunction\");\n    IM3Function function = Module_GetFunction (module, index);\n\n    if (!function) {\n        ESP_LOGE(\"WASM3\", \"addFunctionToModule: Module_GetFunction failed\");\n        return \"Module_GetFunction failed\";\n    }\n    \n    if(WASM_DEBUG_ADD_FUNCTION_NAME) ESP_LOGI(\"WASM3\", \"Setting function parameters\");\n    function->import.fieldUtf8 = nameCopy;\n    function->import.moduleUtf8 = module->name; //strdup(module->name);  \n    function->names[0] = function->import.moduleUtf8;\n    function->numNames++;\n    function->module = module;\n    function->compiled = NULL;  // Non compilata\n\n    //function->funcType = ParseFunctionSignature(signature);  // Tipo non definito    \n    M3Result signatureResult = SignatureToFuncType(& function->funcType, signature);\n    if(signatureResult){\n        ESP_LOGE(\"WASM3\", \"addFunctionToModule: SignatureToFuncType failed: %s\", signatureResult);\n    }\n\n    return m3Err_none;\n}\n\n// Funzione helper per registrare una funzione nel modulo\nM3Result RegisterWasmFunction(IM3Module module, const WasmFunctionEntry* entry) {\n    M3Result result = m3Err_none;\n    \n    if (!module || !entry || !entry->name || !entry->func) {\n        return \"Invalid parameters\";\n    }\n\n    // Verifica dei parametri con log\n    if (!module || !entry || !entry->name || !entry->func) {\n        ESP_LOGE(\"WASM\", \"Invalid parameters - module: %p, entry: %p\", \n                 (void*)module, (void*)entry);\n        return \"Invalid parameters\";\n    }\n\n    addFunctionToModule(module, entry->name, entry->signature);\n\n    // Linkare la funzione nel modulo\n    result = m3_LinkRawFunction( \n        module,              // Modulo WASM\n        \"*\",                 // Namespace (wildcard)\n        entry->name,         // Nome della funzione\n        entry->signature,    // Firma della funzione\n        entry->func         // Puntatore alla funzione\n    );\n    \n    return result;\n}\n\n// Funzione per registrare multiple funzioni da un array\nM3Result RegisterWasmFunctions(IM3Module module, const WasmFunctionEntry* entries, size_t count) {\n    M3Result result = m3Err_none;\n    \n    for (size_t i = 0; i < count; i++) {\n        result = RegisterWasmFunction(module, &entries[i]);\n        ESP_LOGI(\"WASM3\", \"Registered native function: %s\\n\", entries[i].name);\n        if (result) {\n            return result; // Ritorna al primo errore\n        }\n    }\n    \n    return result;\n}\n\n// Esempio di utilizzo:\n/*\n// Definizione delle funzioni native\nm3_ret_t add(IM3Runtime runtime, IM3ImportContext _ctx, uint64_t* _sp, void* _mem) {\n    // Implementazione della funzione\n    return m3Err_none;\n}\n\n// Creazione del lookup table\nconst WasmFunctionEntry functionTable[] = {\n    { \"add\", add, \"i(ii)\" },  // Funzione che accetta due interi e ritorna un intero\n    // Aggiungi altre funzioni qui...\n};\n\n// Registrazione delle funzioni\nM3Result result = RegisterWasmFunctions(module, functionTable, sizeof(functionTable)/sizeof(functionTable[0]));\n*/\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_segmented_memory.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_segmented_memory.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#pragma once\n\n#include <stddef.h>\n#include <stdbool.h>\n\n#include \"wasm3.h\"\n#include \"m3_exception.h\"\n\n#define WASM_SEGMENT_SIZE 4096 // 4096 * x // btw move the definition elsewhere\n#define WASM_PAGE_SIZE 65536 //todo: think about\n#define WASM_ENABLE_SPI_MEM 0\n\n#define M3Memory_MaxPages 1024\n\ntypedef enum {\n    ADDRESS_INVALID = 0,\n    ADDRESS_STACK,\n    ADDRESS_LINEAR\n} AddressType;\n\n// Unified memory region structure\ntypedef struct M3MemoryRegion {\n    u8* base;           // Base address of region\n    size_t size;        // Current size\n    size_t max_size;    // Maximum size\n    size_t current_offset; // Current offset within region\n} M3MemoryRegion;\n\n// Memory segment with metadata\ntypedef struct MemorySegment {    \n    void* data;           // Actual data pointer\n    bool is_allocated;    // Allocation flag\n    size_t stack_size;    // Current stack size in this segment\n    size_t linear_size;   // Current linear memory size in this segment\n} MemorySegment;\n\ntypedef struct M3Memory_t {  \n    //M3MemoryHeader*       mallocated;    \n    IM3Runtime              runtime;\n\n    //u32                     initPages; // initPages or numPages?\n    u32                     numPages;\n    u32                     maxPages;\n    //u32                     pageSize;\n\n    // Segmentation\n    MemorySegment* segments;    // Array di segmenti\n    size_t num_segments;        // Current segments number\n    size_t segment_size;        // Segment size\n    size_t total_size;          // Current total size\n    size_t max_size;            // Max size\n\n    // Fragmentation\n    M3MemoryRegion stack;      // Regione dello stack (cresce verso il basso)\n    M3MemoryRegion linear;     // Regione della memoria lineare (cresce verso l'alto)\n    //u8* stack_pointer;         // SP corrente // delegated to M3MemoryPoint\n\n} M3Memory;\n\ntypedef M3Memory *          IM3Memory;\n\ntypedef struct M3MemoryPoint_t {  \n    IM3Memory memory;\n    size_t offset;\n} M3MemoryPoint;\n\ntypedef M3MemoryPoint *          IM3MemoryPoint;\n\n///\n/// M3Memory fragmentation\n///\n\n\n\n////////////////////////////////\nIM3Memory m3_NewMemory();\nIM3MemoryPoint m3_GetMemoryPoint(IM3Memory mem);\n\nvoid                        InitRuntime                 (IM3Runtime io_runtime, u32 i_stackSizeInBytes);\nvoid                        Runtime_Release             (IM3Runtime io_runtime);\nM3Result                    ResizeMemory                (IM3Runtime io_runtime, u32 i_numPages);\n\nbool IsStackAddress(M3Memory* memory, u8* addr);\nbool IsLinearAddress(M3Memory* memory, u8* addr);\nu8* GetStackAddress(M3Memory* memory, size_t offset);\nM3Result GrowStack(M3Memory* memory, size_t additional_size);\n\n// Stack/linear addresses\n// Studies: https://claude.ai/chat/699c9c02-0792-40c3-b08e-09b8e5df34c8\nM3Result AddSegment(M3Memory* memory);\nu8* GetEffectiveAddress(M3Memory* memory, size_t offset);\nbool IsStackAddress(M3Memory* memory, u8* addr);\nM3Result GrowStack(M3Memory* memory, size_t additional_size);\n\n////////////////////////////////\nbool allocate_segment(M3Memory* memory, size_t segment_index);\nstatic inline void* GetMemorySegment(IM3Memory memory, u32 offset);\nstatic inline i32 m3_LoadInt(IM3Memory memory, u32 offset);\nstatic inline void m3_StoreInt(IM3Memory memory, u32 offset, i32 value);\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_meta_wasi.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_meta_wasi.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_meta_wasi.c\n//\n//  Created by Volodymyr Shymanskyy on 01/08/20.\n//  Copyright © 2020 Volodymyr Shymanskyy. All rights reserved.\n//\n\n#include \"m3_api_wasi.h\"\n\n#if defined(d_m3HasMetaWASI)\n\n// NOTE: MetaWASI mostly redirects WASI calls to the host WASI environment\n\n#if !defined(__wasi__)\n# error \"MetaWASI is only supported on WASI target\"\n#endif\n\n#if __has_include(\"wasi/api.h\")\n# include <wasi/api.h>\n# define USE_NEW_WASI\n# define WASI_STAT_FIELD(f) f\n\n#elif __has_include(\"wasi/core.h\")\n# warning \"Using legacy WASI headers\"\n# include <wasi/core.h>\n# define __WASI_ERRNO_SUCCESS   __WASI_ESUCCESS\n# define __WASI_ERRNO_INVAL     __WASI_EINVAL\n# define WASI_STAT_FIELD(f) st_##f\n\n#else\n# error \"Missing WASI headers\"\n#endif\n\nstatic m3_wasi_context_t* wasi_context;\n\ntypedef size_t __wasi_size_t;\n\nstatic inline\nconst void* copy_iov_to_host(IM3Runtime runtime, void* _mem, __wasi_iovec_t* host_iov, __wasi_iovec_t* wasi_iov, int32_t iovs_len)\n{\n    // Convert wasi memory offsets to host addresses\n    for (int i = 0; i < iovs_len; i++) {\n        host_iov[i].buf = m3ApiOffsetToPtr(wasi_iov[i].buf);\n        host_iov[i].buf_len  = wasi_iov[i].buf_len;\n        m3ApiCheckMem(host_iov[i].buf,     host_iov[i].buf_len);\n    }\n    m3ApiSuccess();\n}\n\n#if d_m3EnableWasiTracing\n\nconst char* wasi_errno2str(__wasi_errno_t err)\n{\n    switch (err) {\n    case  0: return \"ESUCCESS\";\n    case  1: return \"E2BIG\";\n    case  2: return \"EACCES\";\n    case  3: return \"EADDRINUSE\";\n    case  4: return \"EADDRNOTAVAIL\";\n    case  5: return \"EAFNOSUPPORT\";\n    case  6: return \"EAGAIN\";\n    case  7: return \"EALREADY\";\n    case  8: return \"EBADF\";\n    case  9: return \"EBADMSG\";\n    case 10: return \"EBUSY\";\n    case 11: return \"ECANCELED\";\n    case 12: return \"ECHILD\";\n    case 13: return \"ECONNABORTED\";\n    case 14: return \"ECONNREFUSED\";\n    case 15: return \"ECONNRESET\";\n    case 16: return \"EDEADLK\";\n    case 17: return \"EDESTADDRREQ\";\n    case 18: return \"EDOM\";\n    case 19: return \"EDQUOT\";\n    case 20: return \"EEXIST\";\n    case 21: return \"EFAULT\";\n    case 22: return \"EFBIG\";\n    case 23: return \"EHOSTUNREACH\";\n    case 24: return \"EIDRM\";\n    case 25: return \"EILSEQ\";\n    case 26: return \"EINPROGRESS\";\n    case 27: return \"EINTR\";\n    case 28: return \"EINVAL\";\n    case 29: return \"EIO\";\n    case 30: return \"EISCONN\";\n    case 31: return \"EISDIR\";\n    case 32: return \"ELOOP\";\n    case 33: return \"EMFILE\";\n    case 34: return \"EMLINK\";\n    case 35: return \"EMSGSIZE\";\n    case 36: return \"EMULTIHOP\";\n    case 37: return \"ENAMETOOLONG\";\n    case 38: return \"ENETDOWN\";\n    case 39: return \"ENETRESET\";\n    case 40: return \"ENETUNREACH\";\n    case 41: return \"ENFILE\";\n    case 42: return \"ENOBUFS\";\n    case 43: return \"ENODEV\";\n    case 44: return \"ENOENT\";\n    case 45: return \"ENOEXEC\";\n    case 46: return \"ENOLCK\";\n    case 47: return \"ENOLINK\";\n    case 48: return \"ENOMEM\";\n    case 49: return \"ENOMSG\";\n    case 50: return \"ENOPROTOOPT\";\n    case 51: return \"ENOSPC\";\n    case 52: return \"ENOSYS\";\n    case 53: return \"ENOTCONN\";\n    case 54: return \"ENOTDIR\";\n    case 55: return \"ENOTEMPTY\";\n    case 56: return \"ENOTRECOVERABLE\";\n    case 57: return \"ENOTSOCK\";\n    case 58: return \"ENOTSUP\";\n    case 59: return \"ENOTTY\";\n    case 60: return \"ENXIO\";\n    case 61: return \"EOVERFLOW\";\n    case 62: return \"EOWNERDEAD\";\n    case 63: return \"EPERM\";\n    case 64: return \"EPIPE\";\n    case 65: return \"EPROTO\";\n    case 66: return \"EPROTONOSUPPORT\";\n    case 67: return \"EPROTOTYPE\";\n    case 68: return \"ERANGE\";\n    case 69: return \"EROFS\";\n    case 70: return \"ESPIPE\";\n    case 71: return \"ESRCH\";\n    case 72: return \"ESTALE\";\n    case 73: return \"ETIMEDOUT\";\n    case 74: return \"ETXTBSY\";\n    case 75: return \"EXDEV\";\n    case 76: return \"ENOTCAPABLE\";\n    default: return \"<unknown>\";\n    }\n}\n\nconst char* wasi_whence2str(__wasi_whence_t whence)\n{\n    switch (whence) {\n    case __WASI_WHENCE_SET: return \"SET\";\n    case __WASI_WHENCE_CUR: return \"CUR\";\n    case __WASI_WHENCE_END: return \"END\";\n    default:                return \"<unknown>\";\n    }\n}\n\n#  define WASI_TRACE(fmt, ...)    { fprintf(stderr, \"%s \" fmt, __FUNCTION__+16, ##__VA_ARGS__); fprintf(stderr, \" => %s\\n\", wasi_errno2str(ret)); }\n#else\n#  define WASI_TRACE(fmt, ...)\n#endif\n\n/*\n * WASI API implementation\n */\n\nm3ApiRawFunction(m3_wasi_generic_args_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , argv)\n    m3ApiGetArgMem   (char *               , argv_buf)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    m3ApiCheckMem(argv, context->argc * sizeof(uint32_t));\n\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        m3ApiWriteMem32(&argv[i], m3ApiPtrToOffset(argv_buf));\n\n        size_t len = strlen (context->argv[i]);\n\n        m3ApiCheckMem(argv_buf, len);\n        memcpy (argv_buf, context->argv[i], len);\n        argv_buf += len;\n        * argv_buf++ = 0;\n    }\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_args_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , argc)\n    m3ApiGetArgMem   (__wasi_size_t *      , argv_buf_size)\n\n    m3ApiCheckMem(argc,             sizeof(__wasi_size_t));\n    m3ApiCheckMem(argv_buf_size,    sizeof(__wasi_size_t));\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(__WASI_ERRNO_INVAL); }\n\n    __wasi_size_t buf_len = 0;\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        buf_len += strlen (context->argv[i]) + 1;\n    }\n\n    m3ApiWriteMem32(argc, context->argc);\n    m3ApiWriteMem32(argv_buf_size, buf_len);\n\n    m3ApiReturn(__WASI_ERRNO_SUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , env)\n    m3ApiGetArgMem   (char *               , env_buf)\n\n    __wasi_errno_t ret;\n    __wasi_size_t env_count, env_buf_size;\n\n    ret = __wasi_environ_sizes_get(&env_count, &env_buf_size);\n    if (ret != __WASI_ERRNO_SUCCESS) m3ApiReturn(ret);\n\n    m3ApiCheckMem(env,      env_count * sizeof(uint32_t));\n    m3ApiCheckMem(env_buf,  env_buf_size);\n\n    ret = __wasi_environ_get(env, env_buf);\n    if (ret != __WASI_ERRNO_SUCCESS) m3ApiReturn(ret);\n\n    for (u32 i = 0; i < env_count; ++i) {\n        env[i] = m3ApiPtrToOffset (env[i]);\n    }\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_count)\n    m3ApiGetArgMem   (__wasi_size_t *      , env_buf_size)\n\n    m3ApiCheckMem(env_count,    sizeof(__wasi_size_t));\n    m3ApiCheckMem(env_buf_size, sizeof(__wasi_size_t));\n\n    __wasi_errno_t ret = __wasi_environ_sizes_get(env_count, env_buf_size);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_dir_name)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (char *               , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    __wasi_errno_t ret = __wasi_fd_prestat_dir_name(fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, len:%d | path:%s\", fd, path_len, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_prestat_t *   , buf)\n\n    m3ApiCheckMem(buf, sizeof(__wasi_prestat_t));\n\n    __wasi_errno_t ret = __wasi_fd_prestat_get(fd, buf);\n\n    WASI_TRACE(\"fd:%d | type:%d, name_len:%d\", fd, buf->pr_type, buf->u.dir.pr_name_len);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_fdstat_t *    , fdstat)\n\n    m3ApiCheckMem(fdstat, sizeof(__wasi_fdstat_t));\n\n    __wasi_errno_t ret = __wasi_fd_fdstat_get(fd, fdstat);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_flags)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_fdflags_t     , flags)\n\n    __wasi_errno_t ret = __wasi_fd_fdstat_set_flags(fd, flags);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x\", fd, flags);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_rights)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_rights_t      , rights_base)\n    m3ApiGetArg      (__wasi_rights_t      , rights_inheriting)\n\n#if 0\n    __wasi_errno_t ret = __wasi_fd_fdstat_set_rights(fd, rights_base, rights_inheriting);\n#else\n    __wasi_errno_t ret = __WASI_ERRNO_INVAL;\n#endif\n\n    WASI_TRACE(\"fd:%d, base:0x%\" PRIx64 \", inheriting:0x%\" PRIx64, fd, rights_base, rights_inheriting);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_filestat_set_size)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filesize_t    , size)\n\n    __wasi_errno_t ret = __wasi_fd_filestat_set_size(fd, size);\n\n    WASI_TRACE(\"fd:%d, size:%\" PRIu64, fd, size);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_filestat_set_times)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_timestamp_t   , atim)\n    m3ApiGetArg      (__wasi_timestamp_t   , mtim)\n    m3ApiGetArg      (__wasi_fstflags_t    , fst_flags)\n\n    __wasi_errno_t ret = __wasi_fd_filestat_set_times(fd, atim, mtim, fst_flags);\n\n    WASI_TRACE(\"fd:%d, atim:%\" PRIu64 \", mtim:%\" PRIu64 \", flags:%d\", fd, atim, mtim, fst_flags);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 56); // wasi_filestat_t\n\n    __wasi_filestat_t stat;\n\n    __wasi_errno_t ret = __wasi_fd_filestat_get(fd, &stat);\n\n    WASI_TRACE(\"fd:%d | fs.size:%\" PRIu64, fd, stat.WASI_STAT_FIELD(size));\n\n    if (ret != __WASI_ERRNO_SUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 56);\n    m3ApiWriteMem64(buf+0,  stat.WASI_STAT_FIELD(dev));\n    m3ApiWriteMem64(buf+8,  stat.WASI_STAT_FIELD(ino));\n    m3ApiWriteMem8 (buf+16, stat.WASI_STAT_FIELD(filetype));\n    m3ApiWriteMem32(buf+20, stat.WASI_STAT_FIELD(nlink));\n    m3ApiWriteMem64(buf+24, stat.WASI_STAT_FIELD(size));\n    m3ApiWriteMem64(buf+32, stat.WASI_STAT_FIELD(atim));\n    m3ApiWriteMem64(buf+40, stat.WASI_STAT_FIELD(mtim));\n    m3ApiWriteMem64(buf+48, stat.WASI_STAT_FIELD(ctim));\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 64); // wasi_filestat_t\n\n    __wasi_filestat_t stat;\n\n    __wasi_errno_t ret = __wasi_fd_filestat_get(fd, &stat);\n\n    WASI_TRACE(\"fd:%d | fs.size:%\" PRIu64, fd, stat.WASI_STAT_FIELD(size));\n\n    if (ret != __WASI_ERRNO_SUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 64);\n    m3ApiWriteMem64(buf+0,  stat.WASI_STAT_FIELD(dev));\n    m3ApiWriteMem64(buf+8,  stat.WASI_STAT_FIELD(ino));\n    m3ApiWriteMem8 (buf+16, stat.WASI_STAT_FIELD(filetype));\n    m3ApiWriteMem64(buf+24, stat.WASI_STAT_FIELD(nlink));\n    m3ApiWriteMem64(buf+32, stat.WASI_STAT_FIELD(size));\n    m3ApiWriteMem64(buf+40, stat.WASI_STAT_FIELD(atim));\n    m3ApiWriteMem64(buf+48, stat.WASI_STAT_FIELD(mtim));\n    m3ApiWriteMem64(buf+56, stat.WASI_STAT_FIELD(ctim));\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    __wasi_whence_t whence = -1;\n    switch (wasi_whence) {\n    case 0: whence = __WASI_WHENCE_CUR; break;\n    case 1: whence = __WASI_WHENCE_END; break;\n    case 2: whence = __WASI_WHENCE_SET; break;\n    }\n\n    __wasi_filesize_t pos;\n    __wasi_errno_t ret = __wasi_fd_seek(fd, offset, whence, &pos);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", whence:%s | result:%\" PRIu64,\n               fd, offset, wasi_whence2str(whence), pos);\n\n    *result = pos;\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    __wasi_whence_t whence = -1;\n    switch (wasi_whence) {\n    case 0: whence = __WASI_WHENCE_SET; break;\n    case 1: whence = __WASI_WHENCE_CUR; break;\n    case 2: whence = __WASI_WHENCE_END; break;\n    }\n\n    __wasi_filesize_t pos;\n    __wasi_errno_t ret = __wasi_fd_seek(fd, offset, whence, &pos);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", whence:%s | result:%\" PRIu64,\n               fd, offset, wasi_whence2str(whence), pos);\n\n    *result = pos;\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_renumber)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , from)\n    m3ApiGetArg      (__wasi_fd_t          , to)\n\n    __wasi_errno_t ret = __wasi_fd_renumber(from, to);\n\n    WASI_TRACE(\"from:%d, to:%d\", from, to);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_sync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n\n    __wasi_errno_t ret = __wasi_fd_sync(fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_tell)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(__wasi_filesize_t));\n\n    __wasi_filesize_t pos;\n    __wasi_errno_t ret = __wasi_fd_tell(fd, &pos);\n\n    WASI_TRACE(\"fd:%d | result:%\" PRIu64, fd, pos);\n\n    *result = pos;\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_create_directory)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    __wasi_errno_t ret = __wasi_path_create_directory(fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_readlink)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n    m3ApiGetArgMem   (char *               , buf)\n    m3ApiGetArg      (__wasi_size_t        , buf_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , bufused)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf, buf_len);\n    m3ApiCheckMem(bufused, sizeof(__wasi_size_t));\n\n    __wasi_errno_t ret = __wasi_path_readlink(fd, path, path_len, buf, buf_len, bufused);\n\n    WASI_TRACE(\"fd:%d, path:%s | buf:%s, bufused:%d\", fd, path, buf, *bufused);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_remove_directory)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    __wasi_errno_t ret = __wasi_path_remove_directory(fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_rename)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , old_fd)\n    m3ApiGetArgMem   (const char *         , old_path)\n    m3ApiGetArg      (__wasi_size_t        , old_path_len)\n    m3ApiGetArg      (__wasi_fd_t          , new_fd)\n    m3ApiGetArgMem   (const char *         , new_path)\n    m3ApiGetArg      (__wasi_size_t        , new_path_len)\n\n    m3ApiCheckMem(old_path, old_path_len);\n    m3ApiCheckMem(new_path, new_path_len);\n\n    __wasi_errno_t ret = __wasi_path_rename(old_fd, old_path, old_path_len,\n                                            new_fd, new_path, new_path_len);\n\n    WASI_TRACE(\"old_fd:%d, old_path:%s, new_fd:%d, new_path:%s\", old_fd, old_path, new_fd, new_path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_symlink)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (const char *         , old_path)\n    m3ApiGetArg      (__wasi_size_t        , old_path_len)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , new_path)\n    m3ApiGetArg      (__wasi_size_t        , new_path_len)\n\n    m3ApiCheckMem(old_path, old_path_len);\n    m3ApiCheckMem(new_path, new_path_len);\n\n    __wasi_errno_t ret = __wasi_path_symlink(old_path, old_path_len,\n                                                  fd, new_path, new_path_len);\n\n    WASI_TRACE(\"old_path:%s, fd:%d, new_path:%s\", old_path, fd, new_path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_unlink_file)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    __wasi_errno_t ret = __wasi_path_unlink_file(fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_open)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , dirfd)\n    m3ApiGetArg      (__wasi_lookupflags_t , dirflags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (__wasi_size_t        , path_len)\n    m3ApiGetArg      (__wasi_oflags_t      , oflags)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_base)\n    m3ApiGetArg      (__wasi_rights_t      , fs_rights_inheriting)\n    m3ApiGetArg      (__wasi_fdflags_t     , fs_flags)\n    m3ApiGetArgMem   (__wasi_fd_t *        , fd)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(fd,   sizeof(__wasi_fd_t));\n\n    __wasi_errno_t ret = __wasi_path_open(dirfd,\n                                 dirflags,\n                                 path,\n                                 path_len,\n                                 oflags,\n                                 fs_rights_base,\n                                 fs_rights_inheriting,\n                                 fs_flags,\n                                 fd);\n\n    WASI_TRACE(\"dirfd:%d, dirflags:0x%x, path:%s, oflags:0x%x, fs_flags:0x%x | fd:%d\", dirfd, dirflags, path, oflags, fs_flags, *fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_path_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_lookupflags_t , flags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uint32_t             , path_len)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf,  56); // wasi_filestat_t\n\n    __wasi_filestat_t stat;\n\n    __wasi_errno_t ret = __wasi_path_filestat_get(fd, flags, path, path_len, &stat);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x, path:%s | fs.size:%\" PRIu64, fd, flags, path, stat.WASI_STAT_FIELD(size));\n\n    if (ret != __WASI_ERRNO_SUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 56);\n    m3ApiWriteMem64(buf+0,  stat.WASI_STAT_FIELD(dev));\n    m3ApiWriteMem64(buf+8,  stat.WASI_STAT_FIELD(ino));\n    m3ApiWriteMem8 (buf+16, stat.WASI_STAT_FIELD(filetype));\n    m3ApiWriteMem32(buf+20, stat.WASI_STAT_FIELD(nlink));\n    m3ApiWriteMem64(buf+24, stat.WASI_STAT_FIELD(size));\n    m3ApiWriteMem64(buf+32, stat.WASI_STAT_FIELD(atim));\n    m3ApiWriteMem64(buf+40, stat.WASI_STAT_FIELD(mtim));\n    m3ApiWriteMem64(buf+48, stat.WASI_STAT_FIELD(ctim));\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_path_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_lookupflags_t , flags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uint32_t             , path_len)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf,  64); // wasi_filestat_t\n\n    __wasi_filestat_t stat;\n\n    __wasi_errno_t ret = __wasi_path_filestat_get(fd, flags, path, path_len, &stat);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x, path:%s | fs.size:%\" PRIu64, fd, flags, path, stat.WASI_STAT_FIELD(size));\n\n    if (ret != __WASI_ERRNO_SUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 64);\n    m3ApiWriteMem64(buf+0,  stat.WASI_STAT_FIELD(dev));\n    m3ApiWriteMem64(buf+8,  stat.WASI_STAT_FIELD(ino));\n    m3ApiWriteMem8 (buf+16, stat.WASI_STAT_FIELD(filetype));\n    m3ApiWriteMem64(buf+24, stat.WASI_STAT_FIELD(nlink));\n    m3ApiWriteMem64(buf+32, stat.WASI_STAT_FIELD(size));\n    m3ApiWriteMem64(buf+40, stat.WASI_STAT_FIELD(atim));\n    m3ApiWriteMem64(buf+48, stat.WASI_STAT_FIELD(mtim));\n    m3ApiWriteMem64(buf+56, stat.WASI_STAT_FIELD(ctim));\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_pread)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_iovec_t *     , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArg      (__wasi_filesize_t    , offset)\n    m3ApiGetArgMem   (__wasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(__wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(__wasi_size_t));\n\n    __wasi_iovec_t iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n\n    __wasi_errno_t ret = __wasi_fd_pread(fd, iovs, iovs_len, offset, nread);\n\n    WASI_TRACE(\"fd:%d | nread:%d\", fd, *nread);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_read)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_iovec_t *     , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(__wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(__wasi_size_t));\n\n    __wasi_iovec_t iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n\n    __wasi_errno_t ret = __wasi_fd_read(fd, iovs, iovs_len, nread);\n\n    WASI_TRACE(\"fd:%d | nread:%d\", fd, *nread);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_write)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_iovec_t *     , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (__wasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(__wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(__wasi_size_t));\n\n    __wasi_iovec_t iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n\n    __wasi_errno_t ret = __wasi_fd_write(fd, (__wasi_ciovec_t*)iovs, iovs_len, nwritten);\n\n    WASI_TRACE(\"fd:%d | nwritten:%d\", fd, *nwritten);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_pwrite)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (__wasi_iovec_t *     , wasi_iovs)\n    m3ApiGetArg      (__wasi_size_t        , iovs_len)\n    m3ApiGetArg      (__wasi_filesize_t    , offset)\n    m3ApiGetArgMem   (__wasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(__wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(__wasi_size_t));\n\n    __wasi_iovec_t iovs[iovs_len];\n    const void* mem_check = copy_iov_to_host(runtime, _mem, iovs, wasi_iovs, iovs_len);\n    if (mem_check != m3Err_none) {\n        return mem_check;\n    }\n    \n    __wasi_errno_t ret = __wasi_fd_pwrite(fd, (__wasi_ciovec_t*)iovs, iovs_len, offset, nwritten);\n\n    WASI_TRACE(\"fd:%d | nwritten:%d\", fd, *nwritten);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_readdir)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArgMem   (void *               , buf)\n    m3ApiGetArg      (__wasi_size_t        , buf_len)\n    m3ApiGetArg      (__wasi_dircookie_t   , cookie)\n    m3ApiGetArgMem   (__wasi_size_t *      , bufused)\n\n    m3ApiCheckMem(buf,      buf_len);\n    m3ApiCheckMem(bufused,  sizeof(__wasi_size_t));\n\n    __wasi_errno_t ret = __wasi_fd_readdir(fd, buf, buf_len, cookie, bufused);\n\n    WASI_TRACE(\"fd:%d | bufused:%d\", fd, *bufused);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_advise)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filesize_t    , offset)\n    m3ApiGetArg      (__wasi_filesize_t    , length)\n    m3ApiGetArg      (__wasi_advice_t      , advice)\n\n    __wasi_errno_t ret = __wasi_fd_advise(fd, offset, length, advice);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", length:%\" PRIu64 \", advice:%d\", fd, offset, length, advice);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_allocate)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t          , fd)\n    m3ApiGetArg      (__wasi_filesize_t    , offset)\n    m3ApiGetArg      (__wasi_filesize_t    , length)\n\n    __wasi_errno_t ret = __wasi_fd_allocate(fd, offset, length);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", length:%\" PRIu64, fd, offset, length);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_close)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n    __wasi_errno_t ret = __wasi_fd_close(fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_datasync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_fd_t, fd)\n\n    __wasi_errno_t ret = __wasi_fd_datasync(fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_random_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n    m3ApiGetArg      (__wasi_size_t        , buf_len)\n\n    m3ApiCheckMem(buf, buf_len);\n\n    __wasi_errno_t ret = __wasi_random_get(buf, buf_len);\n\n    WASI_TRACE(\"len:%d\", buf_len);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_res_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , resolution)\n\n    m3ApiCheckMem(resolution, sizeof(__wasi_timestamp_t));\n\n    __wasi_timestamp_t t;\n    __wasi_errno_t ret = __wasi_clock_res_get(wasi_clk_id, &t);\n\n    WASI_TRACE(\"clk_id:%d | res:%\" PRIu64, wasi_clk_id, t);\n\n    *resolution = t;\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_time_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArg      (__wasi_timestamp_t   , precision)\n    m3ApiGetArgMem   (__wasi_timestamp_t * , time)\n\n    m3ApiCheckMem(time, sizeof(__wasi_timestamp_t));\n\n    __wasi_timestamp_t t;\n    __wasi_errno_t ret = __wasi_clock_time_get(wasi_clk_id, precision, &t);\n\n    WASI_TRACE(\"clk_id:%d | res:%\" PRIu64, wasi_clk_id, t);\n\n    *time = t;\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_poll_oneoff)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (const __wasi_subscription_t * , in)\n    m3ApiGetArgMem   (__wasi_event_t *              , out)\n    m3ApiGetArg      (__wasi_size_t                 , nsubscriptions)\n    m3ApiGetArgMem   (__wasi_size_t *               , nevents)\n\n    m3ApiCheckMem(in,       nsubscriptions * sizeof(__wasi_subscription_t));\n    m3ApiCheckMem(out,      nsubscriptions * sizeof(__wasi_event_t));\n    m3ApiCheckMem(nevents,  sizeof(__wasi_size_t));\n\n    // TODO: unstable/snapshot_preview1 compatibility\n\n    __wasi_errno_t ret = __wasi_poll_oneoff(in, out, nsubscriptions, nevents);\n\n    WASI_TRACE(\"nsubscriptions:%d | nevents:%d\", nsubscriptions, *nevents);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_exit)\n{\n    m3ApiGetArg      (uint32_t, code)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context) {\n        context->exit_code = code;\n    }\n\n    m3ApiTrap(m3Err_trapExit);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_raise)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (__wasi_signal_t, sig)\n\n    __wasi_errno_t ret = __WASI_ERRNO_INVAL;\n#if 0\n    ret = __wasi_proc_raise(sig);\n#endif\n\n    WASI_TRACE(\"sig:%d\", sig);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_sched_yield)\n{\n    m3ApiReturnType  (uint32_t)\n    __wasi_errno_t ret = __wasi_sched_yield();\n\n    WASI_TRACE(\"\");\n\n    m3ApiReturn(ret);\n}\n\n\nstatic\nM3Result SuppressLookupFailure(M3Result i_result)\n{\n    if (i_result == m3Err_functionLookupFailed)\n        return m3Err_none;\n    else\n        return i_result;\n}\n\nm3_wasi_context_t* m3_GetWasiContext()\n{\n    return wasi_context;\n}\n\n\nM3Result  m3_LinkWASI  (IM3Module module)\n{\n    M3Result result = m3Err_none;\n\n    if (!wasi_context) {\n        wasi_context = (m3_wasi_context_t*)malloc(sizeof(m3_wasi_context_t));\n        wasi_context->exit_code = 0;\n        wasi_context->argc = 0;\n        wasi_context->argv = 0;\n    }\n\n    static const char* namespaces[2] = { \"wasi_unstable\", \"wasi_snapshot_preview1\" };\n\n    // Some functions are incompatible between WASI versions\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_seek\",           \"i(iIi*)\",   &m3_wasi_unstable_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_seek\",           \"i(iIi*)\",   &m3_wasi_snapshot_preview1_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_unstable_fd_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_snapshot_preview1_fd_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_unstable_path_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_snapshot_preview1_path_filestat_get)));\n\n    for (int i=0; i<2; i++)\n    {\n        const char* wasi = namespaces[i];\n\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_get\",           \"i(**)\",   &m3_wasi_generic_args_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_sizes_get\",     \"i(**)\",   &m3_wasi_generic_args_sizes_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_res_get\",        \"i(i*)\",   &m3_wasi_generic_clock_res_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_time_get\",       \"i(iI*)\",  &m3_wasi_generic_clock_time_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_get\",          \"i(**)\",   &m3_wasi_generic_environ_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_sizes_get\",    \"i(**)\",   &m3_wasi_generic_environ_sizes_get)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_advise\",            \"i(iIIi)\", &m3_wasi_generic_fd_advise)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_allocate\",          \"i(iII)\",  &m3_wasi_generic_fd_allocate)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_close\",             \"i(i)\",    &m3_wasi_generic_fd_close)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_datasync\",          \"i(i)\",    &m3_wasi_generic_fd_datasync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_get\",        \"i(i*)\",   &m3_wasi_generic_fd_fdstat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_flags\",  \"i(ii)\",   &m3_wasi_generic_fd_fdstat_set_flags)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_rights\", \"i(iII)\",  &m3_wasi_generic_fd_fdstat_set_rights)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_size\", \"i(iI)\",   &m3_wasi_generic_fd_filestat_set_size)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_times\",\"i(iIIi)\", &m3_wasi_generic_fd_filestat_set_times)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pread\",             \"i(i*iI*)\",&m3_wasi_generic_fd_pread)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_get\",       \"i(i*)\",   &m3_wasi_generic_fd_prestat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_dir_name\",  \"i(i*i)\",  &m3_wasi_generic_fd_prestat_dir_name)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pwrite\",            \"i(i*iI*)\",&m3_wasi_generic_fd_pwrite)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_read\",              \"i(i*i*)\", &m3_wasi_generic_fd_read)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_readdir\",           \"i(i*iI*)\",&m3_wasi_generic_fd_readdir)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_renumber\",          \"i(ii)\",   &m3_wasi_generic_fd_renumber)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_sync\",              \"i(i)\",    &m3_wasi_generic_fd_sync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_tell\",              \"i(i*)\",   &m3_wasi_generic_fd_tell)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_write\",             \"i(i*i*)\", &m3_wasi_generic_fd_write)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_create_directory\",    \"i(i*i)\",       &m3_wasi_generic_path_create_directory)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_filestat_set_times\",  \"i(ii*iIIi)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_link\",                \"i(ii*ii*i)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_open\",                \"i(ii*iiIIi*)\", &m3_wasi_generic_path_open)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_readlink\",            \"i(i*i*i*)\",    &m3_wasi_generic_path_readlink)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_remove_directory\",    \"i(i*i)\",       &m3_wasi_generic_path_remove_directory)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_rename\",              \"i(i*ii*i)\",    &m3_wasi_generic_path_rename)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_symlink\",             \"i(*ii*i)\",     &m3_wasi_generic_path_symlink)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_unlink_file\",         \"i(i*i)\",       &m3_wasi_generic_path_unlink_file)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"poll_oneoff\",          \"i(**i*)\", &m3_wasi_generic_poll_oneoff)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"proc_exit\",          \"v(i)\",    &m3_wasi_generic_proc_exit, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"proc_raise\",           \"i(i)\",    &m3_wasi_generic_proc_raise)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"random_get\",           \"i(*i)\",   &m3_wasi_generic_random_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sched_yield\",          \"i()\",     &m3_wasi_generic_sched_yield)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_recv\",            \"i(i*ii**)\",        )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_send\",            \"i(i*ii*)\",         )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_shutdown\",        \"i(ii)\",            )));\n    }\n\n_catch:\n    return result;\n}\n\n#endif // d_m3HasMetaWASI\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exception.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_exception.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#include \"m3_exception.h\"\n\nchar* error_details(const char* base_error, const char* format, ...) {\n    static char buffer[512];  // Buffer statico per il risultato\n    char temp_buffer[256];    // Buffer temporaneo per la parte formattata\n    va_list args;\n    \n    // Formatta la seconda parte con i parametri variabili\n    va_start(args, format);\n    vsnprintf(temp_buffer, sizeof(temp_buffer), format, args);\n    va_end(args);\n    \n    // Combina l'errore base con i dettagli formattati\n    snprintf(buffer, sizeof(buffer), \"%s: %s\", base_error, temp_buffer);\n    \n    return buffer;\n}", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_module.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_module.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "#pragma once\n\n#include \"wasm3.h\"\n#include \"m3_exception.h\"\n#include \"m3_env.h\"\n#include \"m3_exception.h\"\n\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_uvwasi.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/m3_api_uvwasi.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_api_uvwasi.c\n//\n//  Created by Colin J. Ihrig on 4/20/20.\n//  Copyright © 2020 Colin J. Ihrig, Volodymyr Shymanskyy. All rights reserved.\n//\n\n#define _POSIX_C_SOURCE 200809L\n\n#include \"m3_api_libc.h\"\n#include \"m3_env.h\"\n#include \"m3_parse.h\"\n#include \"m3_segmented_memory.h\"\n\n#if defined(d_m3HasUVWASI)\n\n#include <stdio.h>\n#include <string.h>\n\n#ifdef __APPLE__\n# include <crt_externs.h>\n# define environ (*_NSGetEnviron())\n#elif !defined(_MSC_VER)\nextern char** environ;\n#endif\n\nstatic m3_wasi_context_t* wasi_context;\nstatic uvwasi_t uvwasi;\n\ntypedef struct wasi_iovec_t\n{\n    uvwasi_size_t buf;\n    uvwasi_size_t buf_len;\n} wasi_iovec_t;\n\n#if d_m3EnableWasiTracing\n\nconst char* wasi_errno2str(uvwasi_errno_t err)\n{\n    switch (err) {\n    case  0: return \"ESUCCESS\";\n    case  1: return \"E2BIG\";\n    case  2: return \"EACCES\";\n    case  3: return \"EADDRINUSE\";\n    case  4: return \"EADDRNOTAVAIL\";\n    case  5: return \"EAFNOSUPPORT\";\n    case  6: return \"EAGAIN\";\n    case  7: return \"EALREADY\";\n    case  8: return \"EBADF\";\n    case  9: return \"EBADMSG\";\n    case 10: return \"EBUSY\";\n    case 11: return \"ECANCELED\";\n    case 12: return \"ECHILD\";\n    case 13: return \"ECONNABORTED\";\n    case 14: return \"ECONNREFUSED\";\n    case 15: return \"ECONNRESET\";\n    case 16: return \"EDEADLK\";\n    case 17: return \"EDESTADDRREQ\";\n    case 18: return \"EDOM\";\n    case 19: return \"EDQUOT\";\n    case 20: return \"EEXIST\";\n    case 21: return \"EFAULT\";\n    case 22: return \"EFBIG\";\n    case 23: return \"EHOSTUNREACH\";\n    case 24: return \"EIDRM\";\n    case 25: return \"EILSEQ\";\n    case 26: return \"EINPROGRESS\";\n    case 27: return \"EINTR\";\n    case 28: return \"EINVAL\";\n    case 29: return \"EIO\";\n    case 30: return \"EISCONN\";\n    case 31: return \"EISDIR\";\n    case 32: return \"ELOOP\";\n    case 33: return \"EMFILE\";\n    case 34: return \"EMLINK\";\n    case 35: return \"EMSGSIZE\";\n    case 36: return \"EMULTIHOP\";\n    case 37: return \"ENAMETOOLONG\";\n    case 38: return \"ENETDOWN\";\n    case 39: return \"ENETRESET\";\n    case 40: return \"ENETUNREACH\";\n    case 41: return \"ENFILE\";\n    case 42: return \"ENOBUFS\";\n    case 43: return \"ENODEV\";\n    case 44: return \"ENOENT\";\n    case 45: return \"ENOEXEC\";\n    case 46: return \"ENOLCK\";\n    case 47: return \"ENOLINK\";\n    case 48: return \"ENOMEM\";\n    case 49: return \"ENOMSG\";\n    case 50: return \"ENOPROTOOPT\";\n    case 51: return \"ENOSPC\";\n    case 52: return \"ENOSYS\";\n    case 53: return \"ENOTCONN\";\n    case 54: return \"ENOTDIR\";\n    case 55: return \"ENOTEMPTY\";\n    case 56: return \"ENOTRECOVERABLE\";\n    case 57: return \"ENOTSOCK\";\n    case 58: return \"ENOTSUP\";\n    case 59: return \"ENOTTY\";\n    case 60: return \"ENXIO\";\n    case 61: return \"EOVERFLOW\";\n    case 62: return \"EOWNERDEAD\";\n    case 63: return \"EPERM\";\n    case 64: return \"EPIPE\";\n    case 65: return \"EPROTO\";\n    case 66: return \"EPROTONOSUPPORT\";\n    case 67: return \"EPROTOTYPE\";\n    case 68: return \"ERANGE\";\n    case 69: return \"EROFS\";\n    case 70: return \"ESPIPE\";\n    case 71: return \"ESRCH\";\n    case 72: return \"ESTALE\";\n    case 73: return \"ETIMEDOUT\";\n    case 74: return \"ETXTBSY\";\n    case 75: return \"EXDEV\";\n    case 76: return \"ENOTCAPABLE\";\n    default: return \"<unknown>\";\n    }\n}\n\nconst char* wasi_whence2str(uvwasi_whence_t whence)\n{\n    switch (whence) {\n    case UVWASI_WHENCE_SET: return \"SET\";\n    case UVWASI_WHENCE_CUR: return \"CUR\";\n    case UVWASI_WHENCE_END: return \"END\";\n    default:                return \"<unknown>\";\n    }\n}\n\n#  define WASI_TRACE(fmt, ...)    { fprintf(stderr, \"%s \" fmt, __FUNCTION__+16, ##__VA_ARGS__); fprintf(stderr, \" => %s\\n\", wasi_errno2str(ret)); }\n#else\n#  define WASI_TRACE(fmt, ...)\n#endif\n\n/*\n * WASI API implementation\n */\n\nm3ApiRawFunction(m3_wasi_generic_args_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , argv)\n    m3ApiGetArgMem   (char *               , argv_buf)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(UVWASI_EINVAL); }\n\n    m3ApiCheckMem(argv, context->argc * sizeof(uint32_t));\n\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        m3ApiWriteMem32(&argv[i], m3ApiPtrToOffset(argv_buf));\n\n        size_t len = strlen (context->argv[i]);\n\n        m3ApiCheckMem(argv_buf, len);\n        memcpy (argv_buf, context->argv[i], len);\n        argv_buf += len;\n        * argv_buf++ = 0;\n    }\n\n    m3ApiReturn(UVWASI_ESUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_args_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uvwasi_size_t *      , argc)\n    m3ApiGetArgMem   (uvwasi_size_t *      , argv_buf_size)\n\n    m3ApiCheckMem(argc,             sizeof(uvwasi_size_t));\n    m3ApiCheckMem(argv_buf_size,    sizeof(uvwasi_size_t));\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context == NULL) { m3ApiReturn(UVWASI_EINVAL); }\n\n    uvwasi_size_t buf_len = 0;\n    for (u32 i = 0; i < context->argc; ++i)\n    {\n        buf_len += strlen (context->argv[i]) + 1;\n    }\n\n    m3ApiWriteMem32(argc, context->argc);\n    m3ApiWriteMem32(argv_buf_size, buf_len);\n\n    m3ApiReturn(UVWASI_ESUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint32_t *           , env)\n    m3ApiGetArgMem   (char *               , env_buf)\n\n    char **environment;\n    uvwasi_errno_t ret;\n    uvwasi_size_t env_count, env_buf_size;\n\n    ret = uvwasi_environ_sizes_get(&uvwasi, &env_count, &env_buf_size);\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    m3ApiCheckMem(env,      env_count * sizeof(uint32_t));\n    m3ApiCheckMem(env_buf,  env_buf_size);\n\n    environment = calloc(env_count, sizeof(char *));\n    if (environment == NULL) {\n        m3ApiReturn(UVWASI_ENOMEM);\n    }\n\n    ret = uvwasi_environ_get(&uvwasi, environment, env_buf);\n    if (ret != UVWASI_ESUCCESS) {\n        free(environment);\n        m3ApiReturn(ret);\n    }\n\n    uint32_t environ_buf_offset = m3ApiPtrToOffset(env_buf);\n\n    for (u32 i = 0; i < env_count; ++i)\n    {\n        uint32_t offset = environ_buf_offset +\n                          (environment[i] - environment[0]);\n        m3ApiWriteMem32(&env[i], offset);\n    }\n\n    free(environment);\n    m3ApiReturn(UVWASI_ESUCCESS);\n}\n\nm3ApiRawFunction(m3_wasi_generic_environ_sizes_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uvwasi_size_t *      , env_count)\n    m3ApiGetArgMem   (uvwasi_size_t *      , env_buf_size)\n\n    m3ApiCheckMem(env_count,    sizeof(uvwasi_size_t));\n    m3ApiCheckMem(env_buf_size, sizeof(uvwasi_size_t));\n\n    uvwasi_size_t count;\n    uvwasi_size_t buf_size;\n\n    uvwasi_errno_t ret = uvwasi_environ_sizes_get(&uvwasi, &count, &buf_size);\n\n    m3ApiWriteMem32(env_count,    count);\n    m3ApiWriteMem32(env_buf_size, buf_size);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_dir_name)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (char *               , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    uvwasi_errno_t ret = uvwasi_fd_prestat_dir_name(&uvwasi, fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, len:%d | path:%s\", fd, path_len, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_prestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 8);\n\n    uvwasi_prestat_t prestat;\n\n    uvwasi_errno_t ret = uvwasi_fd_prestat_get(&uvwasi, fd, &prestat);\n\n    WASI_TRACE(\"fd:%d | type:%d, name_len:%d\", fd, prestat.pr_type, prestat.u.dir.pr_name_len);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    m3ApiWriteMem32(buf+0, prestat.pr_type);\n    m3ApiWriteMem32(buf+4, prestat.u.dir.pr_name_len);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 24);\n\n    uvwasi_fdstat_t stat;\n    uvwasi_errno_t ret = uvwasi_fd_fdstat_get(&uvwasi, fd, &stat);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 24);\n    m3ApiWriteMem8 (buf+0, stat.fs_filetype);\n    m3ApiWriteMem16(buf+2, stat.fs_flags);\n    m3ApiWriteMem64(buf+8, stat.fs_rights_base);\n    m3ApiWriteMem64(buf+16, stat.fs_rights_inheriting);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_flags)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_fdflags_t     , flags)\n\n    uvwasi_errno_t ret = uvwasi_fd_fdstat_set_flags(&uvwasi, fd, flags);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x\", fd, flags);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_fdstat_set_rights)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_rights_t      , rights_base)\n    m3ApiGetArg      (uvwasi_rights_t      , rights_inheriting)\n\n    uvwasi_errno_t ret = uvwasi_fd_fdstat_set_rights(&uvwasi, fd, rights_base, rights_inheriting);\n\n    WASI_TRACE(\"fd:%d, base:0x%\" PRIx64 \", inheriting:0x%\" PRIx64, fd, rights_base, rights_inheriting);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_filestat_set_size)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_filesize_t    , size)\n\n    uvwasi_errno_t ret = uvwasi_fd_filestat_set_size(&uvwasi, fd, size);\n\n    WASI_TRACE(\"fd:%d, size:%\" PRIu64, fd, size);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_filestat_set_times)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_timestamp_t   , atim)\n    m3ApiGetArg      (uvwasi_timestamp_t   , mtim)\n    m3ApiGetArg      (uvwasi_fstflags_t    , fst_flags)\n\n    uvwasi_errno_t ret = uvwasi_fd_filestat_set_times(&uvwasi, fd, atim, mtim, fst_flags);\n\n    WASI_TRACE(\"fd:%d, atim:%\" PRIu64 \", mtim:%\" PRIu64 \", flags:%d\", fd, atim, mtim, fst_flags);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 56); // wasi_filestat_t\n\n    uvwasi_filestat_t stat;\n\n    uvwasi_errno_t ret = uvwasi_fd_filestat_get(&uvwasi, fd, &stat);\n\n    WASI_TRACE(\"fd:%d | fs.size:%\" PRIu64, fd, stat.st_size);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 56);\n    m3ApiWriteMem64(buf+0,  stat.st_dev);\n    m3ApiWriteMem64(buf+8,  stat.st_ino);\n    m3ApiWriteMem8 (buf+16, stat.st_filetype);\n    m3ApiWriteMem32(buf+20, stat.st_nlink);\n    m3ApiWriteMem64(buf+24, stat.st_size);\n    m3ApiWriteMem64(buf+32, stat.st_atim);\n    m3ApiWriteMem64(buf+40, stat.st_mtim);\n    m3ApiWriteMem64(buf+48, stat.st_ctim);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(buf, 64); // wasi_filestat_t\n\n    uvwasi_filestat_t stat;\n\n    uvwasi_errno_t ret = uvwasi_fd_filestat_get(&uvwasi, fd, &stat);\n\n    WASI_TRACE(\"fd:%d | fs.size:%\" PRIu64, fd, stat.st_size);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 64);\n    m3ApiWriteMem64(buf+0,  stat.st_dev);\n    m3ApiWriteMem64(buf+8,  stat.st_ino);\n    m3ApiWriteMem8 (buf+16, stat.st_filetype);\n    m3ApiWriteMem64(buf+24, stat.st_nlink);\n    m3ApiWriteMem64(buf+32, stat.st_size);\n    m3ApiWriteMem64(buf+40, stat.st_atim);\n    m3ApiWriteMem64(buf+48, stat.st_mtim);\n    m3ApiWriteMem64(buf+56, stat.st_ctim);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (uvwasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(uvwasi_filesize_t));\n\n    uvwasi_whence_t whence = -1;\n    switch (wasi_whence) {\n    case 0: whence = UVWASI_WHENCE_CUR; break;\n    case 1: whence = UVWASI_WHENCE_END; break;\n    case 2: whence = UVWASI_WHENCE_SET; break;\n    }\n\n    uvwasi_filesize_t pos;\n    uvwasi_errno_t ret = uvwasi_fd_seek(&uvwasi, fd, offset, whence, &pos);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", whence:%s | result:%\" PRIu64,\n               fd, offset, wasi_whence2str(whence), pos);\n\n    m3ApiWriteMem64(result, pos);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_fd_seek)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_filedelta_t   , offset)\n    m3ApiGetArg      (uint32_t             , wasi_whence)\n    m3ApiGetArgMem   (uvwasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(uvwasi_filesize_t));\n\n    uvwasi_whence_t whence = -1;\n    switch (wasi_whence) {\n    case 0: whence = UVWASI_WHENCE_SET; break;\n    case 1: whence = UVWASI_WHENCE_CUR; break;\n    case 2: whence = UVWASI_WHENCE_END; break;\n    }\n\n    uvwasi_filesize_t pos;\n    uvwasi_errno_t ret = uvwasi_fd_seek(&uvwasi, fd, offset, whence, &pos);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", whence:%s | result:%\" PRIu64,\n               fd, offset, wasi_whence2str(whence), pos);\n\n    m3ApiWriteMem64(result, pos);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_renumber)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , from)\n    m3ApiGetArg      (uvwasi_fd_t          , to)\n\n    uvwasi_errno_t ret = uvwasi_fd_renumber(&uvwasi, from, to);\n\n    WASI_TRACE(\"from:%d, to:%d\", from, to);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_sync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n\n    uvwasi_errno_t ret = uvwasi_fd_sync(&uvwasi, fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_tell)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (uvwasi_filesize_t *  , result)\n\n    m3ApiCheckMem(result, sizeof(uvwasi_filesize_t));\n\n    uvwasi_filesize_t pos;\n    uvwasi_errno_t ret = uvwasi_fd_tell(&uvwasi, fd, &pos);\n\n    WASI_TRACE(\"fd:%d | result:%\" PRIu64, fd, pos);\n\n    m3ApiWriteMem64(result, pos);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_create_directory)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    uvwasi_errno_t ret = uvwasi_path_create_directory(&uvwasi, fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_readlink)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n    m3ApiGetArgMem   (char *               , buf)\n    m3ApiGetArg      (uvwasi_size_t        , buf_len)\n    m3ApiGetArgMem   (uvwasi_size_t *      , bufused)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf, buf_len);\n    m3ApiCheckMem(bufused, sizeof(uvwasi_size_t));\n\n    uvwasi_size_t uvbufused;\n\n    uvwasi_errno_t ret = uvwasi_path_readlink(&uvwasi, fd, path, path_len, buf, buf_len, &uvbufused);\n\n    WASI_TRACE(\"fd:%d, path:%s | buf:%s, bufused:%d\", fd, path, buf, uvbufused);\n\n    m3ApiWriteMem32(bufused, uvbufused);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_remove_directory)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    uvwasi_errno_t ret = uvwasi_path_remove_directory(&uvwasi, fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_rename)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , old_fd)\n    m3ApiGetArgMem   (const char *         , old_path)\n    m3ApiGetArg      (uvwasi_size_t        , old_path_len)\n    m3ApiGetArg      (uvwasi_fd_t          , new_fd)\n    m3ApiGetArgMem   (const char *         , new_path)\n    m3ApiGetArg      (uvwasi_size_t        , new_path_len)\n\n    m3ApiCheckMem(old_path, old_path_len);\n    m3ApiCheckMem(new_path, new_path_len);\n\n    uvwasi_errno_t ret = uvwasi_path_rename(&uvwasi, old_fd, old_path, old_path_len,\n                                                     new_fd, new_path, new_path_len);\n\n    WASI_TRACE(\"old_fd:%d, old_path:%s, new_fd:%d, new_path:%s\", old_fd, old_path, new_fd, new_path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_symlink)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (const char *         , old_path)\n    m3ApiGetArg      (uvwasi_size_t        , old_path_len)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , new_path)\n    m3ApiGetArg      (uvwasi_size_t        , new_path_len)\n\n    m3ApiCheckMem(old_path, old_path_len);\n    m3ApiCheckMem(new_path, new_path_len);\n\n    uvwasi_errno_t ret = uvwasi_path_symlink(&uvwasi, old_path, old_path_len,\n                                                  fd, new_path, new_path_len);\n\n    WASI_TRACE(\"old_path:%s, fd:%d, new_path:%s\", old_path, fd, new_path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_unlink_file)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n\n    m3ApiCheckMem(path, path_len);\n\n    uvwasi_errno_t ret = uvwasi_path_unlink_file(&uvwasi, fd, path, path_len);\n\n    WASI_TRACE(\"fd:%d, path:%s\", fd, path);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_path_open)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , dirfd)\n    m3ApiGetArg      (uvwasi_lookupflags_t , dirflags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uvwasi_size_t        , path_len)\n    m3ApiGetArg      (uvwasi_oflags_t      , oflags)\n    m3ApiGetArg      (uvwasi_rights_t      , fs_rights_base)\n    m3ApiGetArg      (uvwasi_rights_t      , fs_rights_inheriting)\n    m3ApiGetArg      (uvwasi_fdflags_t     , fs_flags)\n    m3ApiGetArgMem   (uvwasi_fd_t *        , fd)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(fd,   sizeof(uvwasi_fd_t));\n\n    uvwasi_fd_t uvfd;\n\n    uvwasi_errno_t ret = uvwasi_path_open(&uvwasi,\n                                 dirfd,\n                                 dirflags,\n                                 path,\n                                 path_len,\n                                 oflags,\n                                 fs_rights_base,\n                                 fs_rights_inheriting,\n                                 fs_flags,\n                                 &uvfd);\n\n    WASI_TRACE(\"dirfd:%d, dirflags:0x%x, path:%s, oflags:0x%x, fs_flags:0x%x | fd:%d\", dirfd, dirflags, path, oflags, fs_flags, uvfd);\n\n    m3ApiWriteMem32(fd, uvfd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_unstable_path_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_lookupflags_t , flags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uint32_t             , path_len)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf,  56); // wasi_filestat_t\n\n    uvwasi_filestat_t stat;\n\n    uvwasi_errno_t ret = uvwasi_path_filestat_get(&uvwasi, fd, flags, path, path_len, &stat);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x, path:%s | fs.size:%\" PRIu64, fd, flags, path, stat.st_size);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 56);\n    m3ApiWriteMem64(buf+0,  stat.st_dev);\n    m3ApiWriteMem64(buf+8,  stat.st_ino);\n    m3ApiWriteMem8 (buf+16, stat.st_filetype);\n    m3ApiWriteMem32(buf+20, stat.st_nlink);\n    m3ApiWriteMem64(buf+24, stat.st_size);\n    m3ApiWriteMem64(buf+32, stat.st_atim);\n    m3ApiWriteMem64(buf+40, stat.st_mtim);\n    m3ApiWriteMem64(buf+48, stat.st_ctim);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_snapshot_preview1_path_filestat_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_lookupflags_t , flags)\n    m3ApiGetArgMem   (const char *         , path)\n    m3ApiGetArg      (uint32_t             , path_len)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n\n    m3ApiCheckMem(path, path_len);\n    m3ApiCheckMem(buf,  64); // wasi_filestat_t\n\n    uvwasi_filestat_t stat;\n\n    uvwasi_errno_t ret = uvwasi_path_filestat_get(&uvwasi, fd, flags, path, path_len, &stat);\n\n    WASI_TRACE(\"fd:%d, flags:0x%x, path:%s | fs.size:%\" PRIu64, fd, flags, path, stat.st_size);\n\n    if (ret != UVWASI_ESUCCESS) {\n        m3ApiReturn(ret);\n    }\n\n    memset(buf, 0, 64);\n    m3ApiWriteMem64(buf+0,  stat.st_dev);\n    m3ApiWriteMem64(buf+8,  stat.st_ino);\n    m3ApiWriteMem8 (buf+16, stat.st_filetype);\n    m3ApiWriteMem64(buf+24, stat.st_nlink);\n    m3ApiWriteMem64(buf+32, stat.st_size);\n    m3ApiWriteMem64(buf+40, stat.st_atim);\n    m3ApiWriteMem64(buf+48, stat.st_mtim);\n    m3ApiWriteMem64(buf+56, stat.st_ctim);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_pread)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (uvwasi_size_t        , iovs_len)\n    m3ApiGetArg      (uvwasi_filesize_t    , offset)\n    m3ApiGetArgMem   (uvwasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(uvwasi_size_t));\n\n#if defined(M3_COMPILER_MSVC)\n    if (iovs_len > 32) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_iovec_t  iovs[32];\n#else\n    if (iovs_len > 128) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_iovec_t  iovs[iovs_len];\n#endif\n\n    for (uvwasi_size_t i = 0; i < iovs_len; ++i) {\n        iovs[i].buf = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        iovs[i].buf_len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        m3ApiCheckMem(iovs[i].buf,     iovs[i].buf_len);\n        //fprintf(stderr, \"> fd_pread fd:%d iov%d.len:%d\\n\", fd, i, iovs[i].buf_len);\n    }\n\n    uvwasi_size_t num_read;\n\n    uvwasi_errno_t ret = uvwasi_fd_pread(&uvwasi, fd, iovs, iovs_len, offset, &num_read);\n\n    WASI_TRACE(\"fd:%d | nread:%d\", fd, num_read);\n\n    m3ApiWriteMem32(nread, num_read);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_read)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (uvwasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (uvwasi_size_t *      , nread)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nread,        sizeof(uvwasi_size_t));\n\n#if defined(M3_COMPILER_MSVC)\n    if (iovs_len > 32) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_iovec_t  iovs[32];\n#else\n    if (iovs_len > 128) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_iovec_t  iovs[iovs_len];\n#endif\n    uvwasi_size_t num_read;\n    uvwasi_errno_t ret;\n\n    for (uvwasi_size_t i = 0; i < iovs_len; ++i) {\n        iovs[i].buf = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        iovs[i].buf_len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        m3ApiCheckMem(iovs[i].buf,     iovs[i].buf_len);\n        //fprintf(stderr, \"> fd_read fd:%d iov%d.len:%d\\n\", fd, i, iovs[i].buf_len);\n    }\n\n    ret = uvwasi_fd_read(&uvwasi, fd, iovs, iovs_len, &num_read);\n\n    WASI_TRACE(\"fd:%d | nread:%d\", fd, num_read);\n\n    m3ApiWriteMem32(nread, num_read);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_write)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (uvwasi_size_t        , iovs_len)\n    m3ApiGetArgMem   (uvwasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(uvwasi_size_t));\n\n#if defined(M3_COMPILER_MSVC)\n    if (iovs_len > 32) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_ciovec_t  iovs[32];\n#else\n    if (iovs_len > 128) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_ciovec_t  iovs[iovs_len];\n#endif\n    uvwasi_size_t num_written;\n    uvwasi_errno_t ret;\n\n    for (uvwasi_size_t i = 0; i < iovs_len; ++i) {\n        iovs[i].buf = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        iovs[i].buf_len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        m3ApiCheckMem(iovs[i].buf,     iovs[i].buf_len);\n    }\n\n    ret = uvwasi_fd_write(&uvwasi, fd, iovs, iovs_len, &num_written);\n\n    WASI_TRACE(\"fd:%d | nwritten:%d\", fd, num_written);\n\n    m3ApiWriteMem32(nwritten, num_written);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_pwrite)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)\n    m3ApiGetArg      (uvwasi_size_t        , iovs_len)\n    m3ApiGetArg      (uvwasi_filesize_t    , offset)\n    m3ApiGetArgMem   (uvwasi_size_t *      , nwritten)\n\n    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));\n    m3ApiCheckMem(nwritten,     sizeof(uvwasi_size_t));\n\n#if defined(M3_COMPILER_MSVC)\n    if (iovs_len > 32) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_ciovec_t  iovs[32];\n#else\n    if (iovs_len > 128) m3ApiReturn(UVWASI_EINVAL);\n    uvwasi_ciovec_t  iovs[iovs_len];\n#endif\n    uvwasi_size_t num_written;\n    uvwasi_errno_t ret;\n\n    for (uvwasi_size_t i = 0; i < iovs_len; ++i) {\n        iovs[i].buf = m3ApiOffsetToPtr(m3ApiReadMem32(&wasi_iovs[i].buf));\n        iovs[i].buf_len = m3ApiReadMem32(&wasi_iovs[i].buf_len);\n        m3ApiCheckMem(iovs[i].buf,     iovs[i].buf_len);\n    }\n\n    ret = uvwasi_fd_pwrite(&uvwasi, fd, iovs, iovs_len, offset, &num_written);\n\n    WASI_TRACE(\"fd:%d | nwritten:%d\", fd, num_written);\n\n    m3ApiWriteMem32(nwritten, num_written);\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_readdir)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArgMem   (void *               , buf)\n    m3ApiGetArg      (uvwasi_size_t        , buf_len)\n    m3ApiGetArg      (uvwasi_dircookie_t   , cookie)\n    m3ApiGetArgMem   (uvwasi_size_t *      , bufused)\n\n    m3ApiCheckMem(buf,      buf_len);\n    m3ApiCheckMem(bufused,  sizeof(uvwasi_size_t));\n\n    uvwasi_size_t uvbufused;\n    uvwasi_errno_t ret = uvwasi_fd_readdir(&uvwasi, fd, buf, buf_len, cookie, &uvbufused);\n\n    WASI_TRACE(\"fd:%d | bufused:%d\", fd, uvbufused);\n\n    m3ApiWriteMem32(bufused, uvbufused);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_advise)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_filesize_t    , offset)\n    m3ApiGetArg      (uvwasi_filesize_t    , length)\n    m3ApiGetArg      (uvwasi_advice_t      , advice)\n\n    uvwasi_errno_t ret = uvwasi_fd_advise(&uvwasi, fd, offset, length, advice);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", length:%\" PRIu64 \", advice:%d\", fd, offset, length, advice);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_allocate)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t          , fd)\n    m3ApiGetArg      (uvwasi_filesize_t    , offset)\n    m3ApiGetArg      (uvwasi_filesize_t    , length)\n\n    uvwasi_errno_t ret = uvwasi_fd_allocate(&uvwasi, fd, offset, length);\n\n    WASI_TRACE(\"fd:%d, offset:%\" PRIu64 \", length:%\" PRIu64, fd, offset, length);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_close)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t, fd)\n\n    uvwasi_errno_t ret = uvwasi_fd_close(&uvwasi, fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_fd_datasync)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_fd_t, fd)\n\n    uvwasi_errno_t ret = uvwasi_fd_datasync(&uvwasi, fd);\n\n    WASI_TRACE(\"fd:%d\", fd);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_random_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (uint8_t *            , buf)\n    m3ApiGetArg      (uvwasi_size_t        , buf_len)\n\n    m3ApiCheckMem(buf, buf_len);\n\n    uvwasi_errno_t ret = uvwasi_random_get(&uvwasi, buf, buf_len);\n\n    WASI_TRACE(\"len:%d\", buf_len);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_res_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArgMem   (uvwasi_timestamp_t * , resolution)\n\n    m3ApiCheckMem(resolution, sizeof(uvwasi_timestamp_t));\n\n    uvwasi_timestamp_t t;\n    uvwasi_errno_t ret = uvwasi_clock_res_get(&uvwasi, wasi_clk_id, &t);\n\n    WASI_TRACE(\"clk_id:%d | res:%\" PRIu64, wasi_clk_id, t);\n\n    m3ApiWriteMem64(resolution, t);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_clock_time_get)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_clockid_t     , wasi_clk_id)\n    m3ApiGetArg      (uvwasi_timestamp_t   , precision)\n    m3ApiGetArgMem   (uvwasi_timestamp_t * , time)\n\n    m3ApiCheckMem(time, sizeof(uvwasi_timestamp_t));\n\n    uvwasi_timestamp_t t;\n    uvwasi_errno_t ret = uvwasi_clock_time_get(&uvwasi, wasi_clk_id, precision, &t);\n\n    WASI_TRACE(\"clk_id:%d | res:%\" PRIu64, wasi_clk_id, t);\n\n    m3ApiWriteMem64(time, t);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_poll_oneoff)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArgMem   (const uvwasi_subscription_t * , in)\n    m3ApiGetArgMem   (uvwasi_event_t *              , out)\n    m3ApiGetArg      (uvwasi_size_t                 , nsubscriptions)\n    m3ApiGetArgMem   (uvwasi_size_t *               , nevents)\n\n    m3ApiCheckMem(in,       nsubscriptions * sizeof(uvwasi_subscription_t));\n    m3ApiCheckMem(out,      nsubscriptions * sizeof(uvwasi_event_t));\n    m3ApiCheckMem(nevents,  sizeof(uvwasi_size_t));\n\n    // TODO: unstable/snapshot_preview1 compatibility\n\n    uvwasi_errno_t ret = uvwasi_poll_oneoff(&uvwasi, in, out, nsubscriptions, nevents);\n\n    WASI_TRACE(\"nsubscriptions:%d | nevents:%d\", nsubscriptions, *nevents);\n\n    //TODO: m3ApiWriteMem\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_exit)\n{\n    m3ApiGetArg      (uint32_t, code)\n\n    m3_wasi_context_t* context = (m3_wasi_context_t*)(_ctx->userdata);\n\n    if (context) {\n        context->exit_code = code;\n    }\n\n    //TODO: fprintf(stderr, \"proc_exit code:%d\\n\", code);\n\n    m3ApiTrap(m3Err_trapExit);\n}\n\nm3ApiRawFunction(m3_wasi_generic_proc_raise)\n{\n    m3ApiReturnType  (uint32_t)\n    m3ApiGetArg      (uvwasi_signal_t, sig)\n\n    uvwasi_errno_t ret = uvwasi_proc_raise(&uvwasi, sig);\n\n    WASI_TRACE(\"sig:%d\", sig);\n\n    m3ApiReturn(ret);\n}\n\nm3ApiRawFunction(m3_wasi_generic_sched_yield)\n{\n    m3ApiReturnType  (uint32_t)\n    uvwasi_errno_t ret = uvwasi_sched_yield(&uvwasi);\n\n    WASI_TRACE(\"\");\n\n    m3ApiReturn(ret);\n}\n\n\nstatic\nM3Result SuppressLookupFailure(M3Result i_result)\n{\n    if (i_result == m3Err_functionLookupFailed)\n        return m3Err_none;\n    else\n        return i_result;\n}\n\nm3_wasi_context_t* m3_GetWasiContext()\n{\n    return wasi_context;\n}\n\n\nM3Result  m3_LinkWASI  (IM3Module module)\n{\n    #define ENV_COUNT       9\n\n    char* env[ENV_COUNT];\n    env[0] = \"TERM=xterm-256color\";\n    env[1] = \"COLORTERM=truecolor\";\n    env[2] = \"LANG=en_US.UTF-8\";\n    env[3] = \"PWD=/\";\n    env[4] = \"HOME=/\";\n    env[5] = \"PATH=/\";\n    env[6] = \"WASM3=1\";\n    env[7] = \"WASM3_ARCH=\" M3_ARCH;\n    env[8] = NULL;\n\n    #define PREOPENS_COUNT  2\n\n    uvwasi_preopen_t preopens[PREOPENS_COUNT];\n    preopens[0].mapped_path = \"/\";\n    preopens[0].real_path = \".\";\n    preopens[1].mapped_path = \"./\";\n    preopens[1].real_path = \".\";\n\n    uvwasi_options_t init_options;\n    uvwasi_options_init(&init_options);\n    init_options.argc = 0;      // runtime->argc is not initialized at this point, so we implement args_get directly\n    init_options.envp = (const char **) env;\n    init_options.preopenc = PREOPENS_COUNT;\n    init_options.preopens = preopens;\n\n    return m3_LinkWASIWithOptions(module, init_options);\n}\n\nM3Result  m3_LinkWASIWithOptions  (IM3Module module, uvwasi_options_t init_options)\n{\n    M3Result result = m3Err_none;\n\n    if (!wasi_context) {\n        wasi_context = (m3_wasi_context_t*)malloc(sizeof(m3_wasi_context_t));\n        wasi_context->exit_code = 0;\n        wasi_context->argc = 0;\n        wasi_context->argv = 0;\n\n        uvwasi_errno_t ret = uvwasi_init(&uvwasi, &init_options);\n\n        if (ret != UVWASI_ESUCCESS) {\n            return \"uvwasi_init failed\";\n        }\n    }\n\n    static const char* namespaces[2] = { \"wasi_unstable\", \"wasi_snapshot_preview1\" };\n\n    // Some functions are incompatible between WASI versions\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_seek\",           \"i(iIi*)\",   &m3_wasi_unstable_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_seek\",           \"i(iIi*)\",   &m3_wasi_snapshot_preview1_fd_seek)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_unstable_fd_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"fd_filestat_get\",   \"i(i*)\",     &m3_wasi_snapshot_preview1_fd_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_unstable\",          \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_unstable_path_filestat_get)));\n_   (SuppressLookupFailure (m3_LinkRawFunction (module, \"wasi_snapshot_preview1\", \"path_filestat_get\", \"i(ii*i*)\",  &m3_wasi_snapshot_preview1_path_filestat_get)));\n\n    for (int i=0; i<2; i++)\n    {\n        const char* wasi = namespaces[i];\n\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_get\",           \"i(**)\",   &m3_wasi_generic_args_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"args_sizes_get\",     \"i(**)\",   &m3_wasi_generic_args_sizes_get, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_res_get\",        \"i(i*)\",   &m3_wasi_generic_clock_res_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"clock_time_get\",       \"i(iI*)\",  &m3_wasi_generic_clock_time_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_get\",          \"i(**)\",   &m3_wasi_generic_environ_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"environ_sizes_get\",    \"i(**)\",   &m3_wasi_generic_environ_sizes_get)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_advise\",            \"i(iIIi)\", &m3_wasi_generic_fd_advise)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_allocate\",          \"i(iII)\",  &m3_wasi_generic_fd_allocate)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_close\",             \"i(i)\",    &m3_wasi_generic_fd_close)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_datasync\",          \"i(i)\",    &m3_wasi_generic_fd_datasync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_get\",        \"i(i*)\",   &m3_wasi_generic_fd_fdstat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_flags\",  \"i(ii)\",   &m3_wasi_generic_fd_fdstat_set_flags)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_fdstat_set_rights\", \"i(iII)\",  &m3_wasi_generic_fd_fdstat_set_rights)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_size\", \"i(iI)\",   &m3_wasi_generic_fd_filestat_set_size)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_filestat_set_times\",\"i(iIIi)\", &m3_wasi_generic_fd_filestat_set_times)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pread\",             \"i(i*iI*)\",&m3_wasi_generic_fd_pread)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_get\",       \"i(i*)\",   &m3_wasi_generic_fd_prestat_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_prestat_dir_name\",  \"i(i*i)\",  &m3_wasi_generic_fd_prestat_dir_name)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_pwrite\",            \"i(i*iI*)\",&m3_wasi_generic_fd_pwrite)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_read\",              \"i(i*i*)\", &m3_wasi_generic_fd_read)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_readdir\",           \"i(i*iI*)\",&m3_wasi_generic_fd_readdir)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_renumber\",          \"i(ii)\",   &m3_wasi_generic_fd_renumber)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_sync\",              \"i(i)\",    &m3_wasi_generic_fd_sync)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_tell\",              \"i(i*)\",   &m3_wasi_generic_fd_tell)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"fd_write\",             \"i(i*i*)\", &m3_wasi_generic_fd_write)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_create_directory\",    \"i(i*i)\",       &m3_wasi_generic_path_create_directory)));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_filestat_set_times\",  \"i(ii*iIIi)\",   )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_link\",                \"i(ii*ii*i)\",   )));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_open\",                \"i(ii*iiIIi*)\", &m3_wasi_generic_path_open)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_readlink\",            \"i(i*i*i*)\",    &m3_wasi_generic_path_readlink)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_remove_directory\",    \"i(i*i)\",       &m3_wasi_generic_path_remove_directory)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_rename\",              \"i(i*ii*i)\",    &m3_wasi_generic_path_rename)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_symlink\",             \"i(*ii*i)\",     &m3_wasi_generic_path_symlink)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"path_unlink_file\",         \"i(i*i)\",       &m3_wasi_generic_path_unlink_file)));\n\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"poll_oneoff\",          \"i(**i*)\", &m3_wasi_generic_poll_oneoff)));\n_       (SuppressLookupFailure (m3_LinkRawFunctionEx (module, wasi, \"proc_exit\",          \"v(i)\",    &m3_wasi_generic_proc_exit, wasi_context)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"proc_raise\",           \"i(i)\",    &m3_wasi_generic_proc_raise)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"random_get\",           \"i(*i)\",   &m3_wasi_generic_random_get)));\n_       (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sched_yield\",          \"i()\",     &m3_wasi_generic_sched_yield)));\n\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_recv\",            \"i(i*ii**)\",        )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_send\",            \"i(i*ii*)\",         )));\n//_     (SuppressLookupFailure (m3_LinkRawFunction (module, wasi, \"sock_shutdown\",        \"i(ii)\",            )));\n    }\n\n_catch:\n    return result;\n}\n\n#endif // d_m3HasUVWASI\n\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extensions/m3_extensions.c": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extensions/m3_extensions.c", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  m3_extensions.c\n//\n//  Created by Steven Massey on 3/30/21.\n//  Copyright © 2021 Steven Massey. All rights reserved.\n//\n\n#include \"wasm3_ext.h\"\n\n#include \"m3_env.h\"\n#include \"m3_bind.h\"\n#include \"m3_exception.h\"\n#include \"m3_pointers.h\"\n\n\nIM3Module  m3_NewModule  (IM3Environment i_environment)\n{\n    IM3Module module = m3_AllocStruct (M3Module);\n\n    if (module)\n    {\n        module->name = \".unnamed\";\n        module->startFunction = -1;\n        module->environment = i_environment;\n\n        module->wasmStart = NULL;\n        module->wasmEnd = NULL;\n    }\n\n    return module;\n}\n\n\n\nM3Result  m3_InjectFunction  (IM3Module                 i_module,\n                              int32_t *                 io_functionIndex,\n                              const char * const        i_signature,\n                              const uint8_t * const     i_wasmBytes,\n                              bool                      i_doCompilation)\n{\n    M3Result result = m3Err_none;                                       d_m3Assert (io_functionIndex);\n\n    IM3Function function = NULL;\n    IM3FuncType ftype = NULL;\n_   (SignatureToFuncType (& ftype, i_signature));\n\n    i32 index = * io_functionIndex;\n\n    bytes_t bytes = i_wasmBytes;\n    bytes_t end = i_wasmBytes + 5;\n\n    u32 size;\n_   (ReadLEB_u32 (& size, & bytes, end));\n    end = bytes + size;\n\n    if (index >= 0)\n    {\n        _throwif (\"function index out of bounds\", index >= i_module->numFunctions);\n\n        function = & i_module->functions [index];\n\n        if (not AreFuncTypesEqual (ftype, function->funcType))\n            _throw (\"function type mismatch\");\n    }\n    else\n    {\n        // add slot to function type table in the module\n        u32 funcTypeIndex = i_module->numFuncTypes++;\n        i_module->funcTypes = m3_ReallocArray (IM3FuncType, i_module->funcTypes, i_module->numFuncTypes, funcTypeIndex);\n        _throwifnull (i_module->funcTypes);\n\n        // add functype object to the environment\n        Environment_AddFuncType (i_module->environment, & ftype);\n        i_module->funcTypes [funcTypeIndex] = ftype;\n        ftype = NULL; // prevent freeing below\n\n        index = (i32) i_module->numFunctions;\n_       (Module_AddFunction (i_module, funcTypeIndex, NULL));\n        function = Module_GetFunction (i_module, index);\n\n        * io_functionIndex = index;\n    }\n\n    function->compiled = NULL;\n\n    if (function->ownsWasmCode)\n        m3_Int_Free (function->wasm);\n\n    size_t numBytes = end - i_wasmBytes;\n    function->wasm = m3_CopyMem (i_wasmBytes, numBytes);\n    _throwifnull (function->wasm);\n\n    function->wasmEnd = function->wasm + numBytes;\n    function->ownsWasmCode = true;\n\n    function->module = i_module;\n\n    if (i_doCompilation and not i_module->runtime)\n        _throw (\"module must be loaded into runtime to compile function\");\n\n_   (CompileFunction (function));\n\n    _catch:\n    m3_Free (ftype);\n\n    return result;\n}\n\n\nIM3Function  m3_GetFunctionByIndex  (IM3Module i_module, uint32_t i_index)\n{\n    return Module_GetFunction (i_module, i_index);\n}\n", "is_header": false, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extensions/wasm3_ext.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extensions/wasm3_ext.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "//\n//  Wasm3, high performance WebAssembly interpreter\n//\n//  Extensions\n//\n//  Copyright © 2019-2021 Steven Massey, Volodymyr Shymanskyy.\n//  All rights reserved.\n//\n\n#ifndef wasm3_ext_h\n#define wasm3_ext_h\n\n#include \"wasm3.h\"\n#include <stdbool.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//  API extensions\n//-------------------------------------------------------------------------------------------------------------------------------\n/*\n    These extensions allow for unconventional uses of Wasm3 -- mainly dynamic modification of modules to inject new Wasm\n    functions during runtime.\n*/\n//-------------------------------------------------------------------------------------------------------------------------------\n\n    // Creates an empty module.\n    IM3Module           m3_NewModule                (IM3Environment         i_environment);\n\n\n    // To append a new function, set io_functionIndex to negative. On return, the new function index will be set.\n    // To overwrite an existing function, set io_functionIndex to the desired element. i_signature must match the existing\n    // function signature.\n    // ** InjectFunction invalidates any existing IM3Function pointers\n    M3Result            m3_InjectFunction           (IM3Module              i_module,\n                                                     int32_t *              io_functionIndex,\n                                                     const char * const     i_signature,\n                                                     const uint8_t * const  i_wasmBytes,            // i_wasmBytes is copied\n                                                     bool                   i_doCompilation);\n\n\n    IM3Function         m3_GetFunctionByIndex       (IM3Module              i_module,\n                                                     uint32_t               i_index);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif // wasm3_h\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib64.wasm.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib64.wasm.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "unsigned char fib64_wasm[] = {\n  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0x60,\n  0x01, 0x7e, 0x01, 0x7e, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03,\n  0x66, 0x69, 0x62, 0x00, 0x00, 0x0a, 0x1f, 0x01, 0x1d, 0x00, 0x20, 0x00,\n  0x42, 0x02, 0x54, 0x04, 0x40, 0x20, 0x00, 0x0f, 0x0b, 0x20, 0x00, 0x42,\n  0x02, 0x7d, 0x10, 0x00, 0x20, 0x00, 0x42, 0x01, 0x7d, 0x10, 0x00, 0x7c,\n  0x0f, 0x0b\n};\nunsigned int fib64_wasm_len = 62;\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/coremark_minimal.wasm.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/coremark_minimal.wasm.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "unsigned char coremark_minimal_wasm[] = {\n  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x3e, 0x0a, 0x60,\n  0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x60, 0x00, 0x00, 0x60, 0x02, 0x7f, 0x7f,\n  0x00, 0x60, 0x03, 0x7f, 0x7f, 0x7f, 0x00, 0x60, 0x04, 0x7f, 0x7f, 0x7f,\n  0x7f, 0x00, 0x60, 0x00, 0x01, 0x7f, 0x60, 0x03, 0x7f, 0x7f, 0x7f, 0x01,\n  0x7f, 0x60, 0x05, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x01, 0x7f, 0x60, 0x06,\n  0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x01, 0x7f, 0x60, 0x00, 0x01, 0x7d,\n  0x02, 0x10, 0x01, 0x03, 0x65, 0x6e, 0x76, 0x08, 0x63, 0x6c, 0x6f, 0x63,\n  0x6b, 0x5f, 0x6d, 0x73, 0x00, 0x05, 0x03, 0x10, 0x0f, 0x00, 0x00, 0x06,\n  0x09, 0x07, 0x04, 0x08, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x01, 0x01,\n  0x05, 0x03, 0x01, 0x00, 0x01, 0x06, 0x07, 0x01, 0x7f, 0x01, 0x41, 0x80,\n  0x04, 0x0b, 0x07, 0x10, 0x02, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79,\n  0x02, 0x00, 0x03, 0x72, 0x75, 0x6e, 0x00, 0x04, 0x0a, 0x82, 0x39, 0x0f,\n  0xdb, 0x01, 0x01, 0x04, 0x7f, 0x20, 0x00, 0x2f, 0x01, 0x00, 0x22, 0x03,\n  0x41, 0x80, 0x01, 0x71, 0x04, 0x40, 0x20, 0x03, 0x41, 0xff, 0x00, 0x71,\n  0x0f, 0x0b, 0x20, 0x03, 0x41, 0x03, 0x76, 0x41, 0x0f, 0x71, 0x22, 0x02,\n  0x41, 0x04, 0x74, 0x20, 0x02, 0x72, 0x21, 0x04, 0x02, 0x40, 0x02, 0x40,\n  0x02, 0x40, 0x20, 0x03, 0x22, 0x02, 0x41, 0x07, 0x71, 0x0e, 0x02, 0x00,\n  0x01, 0x02, 0x0b, 0x20, 0x01, 0x28, 0x02, 0x18, 0x20, 0x01, 0x41, 0x14,\n  0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x2e, 0x01, 0x00, 0x20, 0x01, 0x2e,\n  0x01, 0x02, 0x20, 0x04, 0x41, 0x22, 0x20, 0x04, 0x41, 0x22, 0x4b, 0x1b,\n  0x20, 0x01, 0x2f, 0x01, 0x38, 0x10, 0x07, 0x21, 0x02, 0x20, 0x01, 0x2f,\n  0x01, 0x3e, 0x0d, 0x01, 0x20, 0x01, 0x20, 0x02, 0x3b, 0x01, 0x3e, 0x0c,\n  0x01, 0x0b, 0x20, 0x01, 0x2f, 0x01, 0x38, 0x21, 0x02, 0x20, 0x01, 0x41,\n  0x28, 0x6a, 0x22, 0x05, 0x28, 0x02, 0x00, 0x20, 0x05, 0x28, 0x02, 0x0c,\n  0x20, 0x05, 0x28, 0x02, 0x04, 0x20, 0x05, 0x28, 0x02, 0x08, 0x20, 0x04,\n  0x10, 0x05, 0x20, 0x02, 0x10, 0x0c, 0x21, 0x02, 0x20, 0x01, 0x2f, 0x01,\n  0x3c, 0x0d, 0x00, 0x20, 0x01, 0x20, 0x02, 0x3b, 0x01, 0x3c, 0x0b, 0x20,\n  0x01, 0x20, 0x02, 0x20, 0x01, 0x2f, 0x01, 0x38, 0x10, 0x0a, 0x3b, 0x01,\n  0x38, 0x20, 0x00, 0x20, 0x02, 0x41, 0xff, 0x00, 0x71, 0x22, 0x00, 0x20,\n  0x03, 0x41, 0x80, 0xfe, 0x03, 0x71, 0x72, 0x41, 0x80, 0x01, 0x72, 0x3b,\n  0x01, 0x00, 0x20, 0x00, 0x0b, 0x97, 0x0a, 0x01, 0x10, 0x7f, 0x20, 0x00,\n  0x28, 0x02, 0x24, 0x21, 0x04, 0x02, 0x7f, 0x20, 0x00, 0x2e, 0x01, 0x04,\n  0x22, 0x0b, 0x41, 0x01, 0x48, 0x04, 0x40, 0x20, 0x01, 0x21, 0x09, 0x41,\n  0x00, 0x0c, 0x01, 0x0b, 0x20, 0x01, 0x21, 0x09, 0x03, 0x40, 0x20, 0x04,\n  0x21, 0x03, 0x02, 0x40, 0x02, 0x40, 0x20, 0x09, 0x41, 0x10, 0x74, 0x41,\n  0x10, 0x75, 0x41, 0x7f, 0x4a, 0x04, 0x40, 0x03, 0x40, 0x20, 0x03, 0x28,\n  0x02, 0x04, 0x2f, 0x01, 0x02, 0x20, 0x09, 0x41, 0xff, 0xff, 0x03, 0x71,\n  0x46, 0x0d, 0x03, 0x20, 0x03, 0x28, 0x02, 0x00, 0x22, 0x03, 0x0d, 0x00,\n  0x0b, 0x0c, 0x01, 0x0b, 0x03, 0x40, 0x20, 0x03, 0x28, 0x02, 0x04, 0x2d,\n  0x00, 0x00, 0x20, 0x06, 0x41, 0xff, 0x01, 0x71, 0x73, 0x45, 0x0d, 0x02,\n  0x20, 0x03, 0x28, 0x02, 0x00, 0x22, 0x03, 0x0d, 0x00, 0x0b, 0x0b, 0x41,\n  0x00, 0x21, 0x03, 0x0b, 0x02, 0x40, 0x20, 0x04, 0x45, 0x04, 0x40, 0x41,\n  0x00, 0x21, 0x04, 0x0c, 0x01, 0x0b, 0x41, 0x00, 0x21, 0x05, 0x20, 0x04,\n  0x21, 0x02, 0x03, 0x40, 0x20, 0x02, 0x22, 0x04, 0x28, 0x02, 0x00, 0x21,\n  0x02, 0x20, 0x04, 0x20, 0x05, 0x36, 0x02, 0x00, 0x20, 0x04, 0x21, 0x05,\n  0x20, 0x02, 0x0d, 0x00, 0x0b, 0x0b, 0x02, 0x40, 0x20, 0x03, 0x45, 0x04,\n  0x40, 0x20, 0x0e, 0x41, 0x01, 0x6a, 0x21, 0x0e, 0x20, 0x04, 0x28, 0x02,\n  0x00, 0x28, 0x02, 0x04, 0x2d, 0x00, 0x01, 0x41, 0x01, 0x71, 0x20, 0x0d,\n  0x6a, 0x21, 0x0d, 0x0c, 0x01, 0x0b, 0x20, 0x0f, 0x41, 0x01, 0x6a, 0x21,\n  0x0f, 0x20, 0x03, 0x28, 0x02, 0x04, 0x2f, 0x01, 0x00, 0x22, 0x02, 0x41,\n  0x09, 0x76, 0x20, 0x02, 0x71, 0x41, 0x01, 0x71, 0x20, 0x0d, 0x6a, 0x21,\n  0x0d, 0x20, 0x03, 0x28, 0x02, 0x00, 0x22, 0x02, 0x45, 0x0d, 0x00, 0x20,\n  0x03, 0x20, 0x02, 0x28, 0x02, 0x00, 0x36, 0x02, 0x00, 0x20, 0x02, 0x20,\n  0x04, 0x28, 0x02, 0x00, 0x36, 0x02, 0x00, 0x20, 0x04, 0x20, 0x02, 0x36,\n  0x02, 0x00, 0x0b, 0x20, 0x09, 0x41, 0x7f, 0x73, 0x41, 0x80, 0x80, 0x02,\n  0x71, 0x41, 0x0f, 0x76, 0x20, 0x09, 0x6a, 0x21, 0x09, 0x20, 0x06, 0x41,\n  0x10, 0x74, 0x41, 0x80, 0x80, 0x04, 0x6a, 0x41, 0x10, 0x75, 0x22, 0x06,\n  0x20, 0x0b, 0x48, 0x0d, 0x00, 0x0b, 0x20, 0x0b, 0x41, 0x7f, 0x6a, 0x41,\n  0xff, 0x01, 0x71, 0x0b, 0x21, 0x10, 0x02, 0x40, 0x02, 0x40, 0x20, 0x01,\n  0x41, 0x01, 0x48, 0x0d, 0x00, 0x41, 0x01, 0x21, 0x0a, 0x03, 0x40, 0x20,\n  0x0a, 0x41, 0x01, 0x48, 0x0d, 0x02, 0x41, 0x00, 0x21, 0x0c, 0x41, 0x00,\n  0x21, 0x06, 0x20, 0x04, 0x21, 0x02, 0x41, 0x00, 0x21, 0x04, 0x03, 0x40,\n  0x20, 0x0c, 0x22, 0x11, 0x41, 0x01, 0x6a, 0x21, 0x0c, 0x41, 0x00, 0x21,\n  0x03, 0x20, 0x02, 0x21, 0x05, 0x02, 0x7f, 0x02, 0x40, 0x03, 0x40, 0x20,\n  0x05, 0x28, 0x02, 0x00, 0x22, 0x05, 0x45, 0x0d, 0x01, 0x20, 0x0a, 0x20,\n  0x03, 0x41, 0x01, 0x6a, 0x22, 0x03, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x0a,\n  0x0c, 0x01, 0x0b, 0x20, 0x03, 0x41, 0x01, 0x6a, 0x0b, 0x21, 0x08, 0x20,\n  0x02, 0x21, 0x03, 0x20, 0x05, 0x21, 0x02, 0x20, 0x0a, 0x21, 0x07, 0x03,\n  0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x7f, 0x02, 0x40, 0x02, 0x7f, 0x02,\n  0x40, 0x20, 0x08, 0x41, 0x00, 0x4a, 0x0d, 0x00, 0x20, 0x02, 0x45, 0x0d,\n  0x04, 0x20, 0x07, 0x41, 0x01, 0x48, 0x0d, 0x04, 0x20, 0x08, 0x0d, 0x00,\n  0x20, 0x07, 0x41, 0x7f, 0x6a, 0x21, 0x07, 0x41, 0x00, 0x21, 0x08, 0x20,\n  0x02, 0x28, 0x02, 0x00, 0x0c, 0x01, 0x0b, 0x20, 0x02, 0x45, 0x0d, 0x01,\n  0x20, 0x07, 0x45, 0x0d, 0x01, 0x20, 0x02, 0x28, 0x02, 0x04, 0x21, 0x01,\n  0x20, 0x03, 0x28, 0x02, 0x04, 0x20, 0x00, 0x10, 0x01, 0x41, 0xff, 0xff,\n  0x03, 0x71, 0x20, 0x01, 0x20, 0x00, 0x10, 0x01, 0x41, 0xff, 0xff, 0x03,\n  0x71, 0x4d, 0x0d, 0x01, 0x20, 0x07, 0x41, 0x7f, 0x6a, 0x21, 0x07, 0x20,\n  0x02, 0x28, 0x02, 0x00, 0x0b, 0x21, 0x01, 0x20, 0x03, 0x21, 0x0b, 0x20,\n  0x02, 0x0c, 0x01, 0x0b, 0x20, 0x08, 0x41, 0x7f, 0x6a, 0x21, 0x08, 0x20,\n  0x03, 0x28, 0x02, 0x00, 0x21, 0x0b, 0x20, 0x02, 0x21, 0x01, 0x20, 0x03,\n  0x0b, 0x21, 0x05, 0x20, 0x06, 0x45, 0x04, 0x40, 0x20, 0x05, 0x21, 0x04,\n  0x0c, 0x02, 0x0b, 0x20, 0x06, 0x20, 0x05, 0x36, 0x02, 0x00, 0x0c, 0x01,\n  0x0b, 0x20, 0x02, 0x0d, 0x02, 0x20, 0x06, 0x41, 0x00, 0x36, 0x02, 0x00,\n  0x20, 0x0a, 0x41, 0x01, 0x74, 0x21, 0x0a, 0x20, 0x11, 0x0d, 0x03, 0x0c,\n  0x04, 0x0b, 0x20, 0x0b, 0x21, 0x03, 0x20, 0x01, 0x21, 0x02, 0x20, 0x05,\n  0x21, 0x06, 0x0c, 0x00, 0x0b, 0x00, 0x0b, 0x00, 0x0b, 0x00, 0x0b, 0x20,\n  0x0f, 0x41, 0x02, 0x74, 0x20, 0x0e, 0x6b, 0x20, 0x0d, 0x6a, 0x21, 0x0c,\n  0x20, 0x04, 0x28, 0x02, 0x00, 0x22, 0x01, 0x28, 0x02, 0x04, 0x21, 0x06,\n  0x20, 0x01, 0x20, 0x01, 0x28, 0x02, 0x00, 0x22, 0x00, 0x28, 0x02, 0x04,\n  0x36, 0x02, 0x04, 0x20, 0x01, 0x20, 0x00, 0x28, 0x02, 0x00, 0x36, 0x02,\n  0x00, 0x20, 0x00, 0x20, 0x06, 0x36, 0x02, 0x04, 0x20, 0x00, 0x41, 0x00,\n  0x36, 0x02, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x20, 0x09, 0x41,\n  0x10, 0x74, 0x41, 0x10, 0x75, 0x41, 0x7f, 0x4c, 0x04, 0x40, 0x20, 0x04,\n  0x45, 0x0d, 0x01, 0x20, 0x04, 0x21, 0x02, 0x03, 0x40, 0x20, 0x10, 0x20,\n  0x02, 0x28, 0x02, 0x04, 0x2d, 0x00, 0x00, 0x46, 0x0d, 0x03, 0x20, 0x02,\n  0x28, 0x02, 0x00, 0x22, 0x02, 0x0d, 0x00, 0x0b, 0x0c, 0x01, 0x0b, 0x20,\n  0x04, 0x45, 0x0d, 0x00, 0x20, 0x09, 0x41, 0xff, 0xff, 0x03, 0x71, 0x21,\n  0x01, 0x20, 0x04, 0x21, 0x02, 0x03, 0x40, 0x20, 0x02, 0x28, 0x02, 0x04,\n  0x2f, 0x01, 0x02, 0x20, 0x01, 0x46, 0x0d, 0x02, 0x20, 0x02, 0x28, 0x02,\n  0x00, 0x22, 0x02, 0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x04, 0x28, 0x02, 0x00,\n  0x22, 0x02, 0x45, 0x0d, 0x01, 0x0b, 0x03, 0x40, 0x20, 0x04, 0x28, 0x02,\n  0x04, 0x2e, 0x01, 0x00, 0x20, 0x0c, 0x41, 0xff, 0xff, 0x03, 0x71, 0x10,\n  0x0c, 0x21, 0x0c, 0x20, 0x02, 0x28, 0x02, 0x00, 0x22, 0x02, 0x0d, 0x00,\n  0x0b, 0x20, 0x00, 0x28, 0x02, 0x04, 0x21, 0x06, 0x0b, 0x20, 0x00, 0x20,\n  0x04, 0x28, 0x02, 0x00, 0x22, 0x01, 0x28, 0x02, 0x04, 0x36, 0x02, 0x04,\n  0x20, 0x00, 0x20, 0x01, 0x28, 0x02, 0x00, 0x36, 0x02, 0x00, 0x20, 0x01,\n  0x20, 0x06, 0x36, 0x02, 0x04, 0x20, 0x01, 0x20, 0x00, 0x36, 0x02, 0x00,\n  0x41, 0x01, 0x21, 0x00, 0x03, 0x40, 0x20, 0x00, 0x41, 0x01, 0x4e, 0x04,\n  0x40, 0x41, 0x00, 0x21, 0x0a, 0x41, 0x00, 0x21, 0x06, 0x20, 0x04, 0x21,\n  0x02, 0x41, 0x00, 0x21, 0x04, 0x03, 0x40, 0x20, 0x0a, 0x22, 0x09, 0x41,\n  0x01, 0x6a, 0x21, 0x0a, 0x41, 0x00, 0x21, 0x03, 0x20, 0x02, 0x21, 0x05,\n  0x02, 0x7f, 0x02, 0x40, 0x03, 0x40, 0x20, 0x05, 0x28, 0x02, 0x00, 0x22,\n  0x05, 0x45, 0x0d, 0x01, 0x20, 0x00, 0x20, 0x03, 0x41, 0x01, 0x6a, 0x22,\n  0x03, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00, 0x0c, 0x01, 0x0b, 0x20, 0x03,\n  0x41, 0x01, 0x6a, 0x0b, 0x21, 0x08, 0x20, 0x02, 0x21, 0x03, 0x20, 0x05,\n  0x21, 0x02, 0x20, 0x00, 0x21, 0x07, 0x03, 0x40, 0x02, 0x40, 0x02, 0x40,\n  0x02, 0x7f, 0x02, 0x40, 0x02, 0x7f, 0x02, 0x40, 0x20, 0x08, 0x41, 0x00,\n  0x4a, 0x0d, 0x00, 0x20, 0x02, 0x45, 0x0d, 0x04, 0x20, 0x07, 0x41, 0x01,\n  0x48, 0x0d, 0x04, 0x20, 0x08, 0x0d, 0x00, 0x20, 0x07, 0x41, 0x7f, 0x6a,\n  0x21, 0x07, 0x41, 0x00, 0x21, 0x08, 0x20, 0x02, 0x28, 0x02, 0x00, 0x0c,\n  0x01, 0x0b, 0x20, 0x02, 0x45, 0x0d, 0x01, 0x20, 0x07, 0x45, 0x0d, 0x01,\n  0x20, 0x03, 0x28, 0x02, 0x04, 0x22, 0x01, 0x20, 0x01, 0x2d, 0x00, 0x01,\n  0x3a, 0x00, 0x00, 0x20, 0x02, 0x28, 0x02, 0x04, 0x22, 0x05, 0x20, 0x05,\n  0x2d, 0x00, 0x01, 0x3a, 0x00, 0x00, 0x20, 0x01, 0x2e, 0x01, 0x02, 0x20,\n  0x05, 0x2e, 0x01, 0x02, 0x4c, 0x0d, 0x01, 0x20, 0x07, 0x41, 0x7f, 0x6a,\n  0x21, 0x07, 0x20, 0x02, 0x28, 0x02, 0x00, 0x0b, 0x21, 0x0b, 0x20, 0x02,\n  0x21, 0x05, 0x20, 0x03, 0x0c, 0x01, 0x0b, 0x20, 0x08, 0x41, 0x7f, 0x6a,\n  0x21, 0x08, 0x20, 0x02, 0x21, 0x0b, 0x20, 0x03, 0x21, 0x05, 0x20, 0x03,\n  0x28, 0x02, 0x00, 0x0b, 0x21, 0x01, 0x20, 0x06, 0x45, 0x04, 0x40, 0x20,\n  0x05, 0x21, 0x04, 0x0c, 0x02, 0x0b, 0x20, 0x06, 0x20, 0x05, 0x36, 0x02,\n  0x00, 0x0c, 0x01, 0x0b, 0x20, 0x02, 0x0d, 0x02, 0x20, 0x06, 0x41, 0x00,\n  0x36, 0x02, 0x00, 0x20, 0x00, 0x41, 0x01, 0x74, 0x21, 0x00, 0x20, 0x09,\n  0x0d, 0x04, 0x20, 0x04, 0x28, 0x02, 0x00, 0x22, 0x02, 0x04, 0x40, 0x03,\n  0x40, 0x20, 0x04, 0x28, 0x02, 0x04, 0x2e, 0x01, 0x00, 0x20, 0x0c, 0x41,\n  0xff, 0xff, 0x03, 0x71, 0x10, 0x0c, 0x21, 0x0c, 0x20, 0x02, 0x28, 0x02,\n  0x00, 0x22, 0x02, 0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x0c, 0x41, 0xff, 0xff,\n  0x03, 0x71, 0x0f, 0x0b, 0x20, 0x01, 0x21, 0x03, 0x20, 0x0b, 0x21, 0x02,\n  0x20, 0x05, 0x21, 0x06, 0x0c, 0x00, 0x0b, 0x00, 0x0b, 0x00, 0x0b, 0x0b,\n  0x03, 0x40, 0x0c, 0x00, 0x0b, 0x00, 0x0b, 0x03, 0x40, 0x0c, 0x00, 0x0b,\n  0x00, 0x0b, 0xac, 0x05, 0x01, 0x09, 0x7f, 0x20, 0x01, 0x41, 0x00, 0x36,\n  0x02, 0x00, 0x20, 0x01, 0x20, 0x01, 0x20, 0x00, 0x41, 0x14, 0x6e, 0x41,\n  0x7e, 0x6a, 0x22, 0x06, 0x41, 0x03, 0x74, 0x6a, 0x22, 0x07, 0x36, 0x02,\n  0x04, 0x20, 0x07, 0x41, 0x80, 0x81, 0x02, 0x36, 0x01, 0x00, 0x20, 0x07,\n  0x20, 0x06, 0x41, 0x02, 0x74, 0x6a, 0x21, 0x09, 0x20, 0x01, 0x41, 0x08,\n  0x6a, 0x21, 0x03, 0x20, 0x07, 0x41, 0x04, 0x6a, 0x21, 0x05, 0x02, 0x40,\n  0x20, 0x00, 0x41, 0xe4, 0x00, 0x49, 0x0d, 0x00, 0x20, 0x09, 0x20, 0x05,\n  0x41, 0x04, 0x6a, 0x22, 0x00, 0x4d, 0x04, 0x40, 0x0c, 0x01, 0x0b, 0x20,\n  0x01, 0x20, 0x03, 0x36, 0x02, 0x00, 0x20, 0x01, 0x41, 0x00, 0x36, 0x02,\n  0x08, 0x20, 0x05, 0x41, 0xff, 0xff, 0xff, 0xff, 0x07, 0x36, 0x01, 0x00,\n  0x20, 0x01, 0x41, 0x0c, 0x6a, 0x20, 0x05, 0x36, 0x02, 0x00, 0x20, 0x03,\n  0x21, 0x04, 0x20, 0x00, 0x21, 0x05, 0x20, 0x01, 0x41, 0x10, 0x6a, 0x21,\n  0x03, 0x0b, 0x20, 0x06, 0x04, 0x40, 0x41, 0x00, 0x21, 0x00, 0x03, 0x40,\n  0x02, 0x40, 0x20, 0x03, 0x41, 0x08, 0x6a, 0x22, 0x08, 0x20, 0x07, 0x4f,\n  0x0d, 0x00, 0x20, 0x05, 0x41, 0x04, 0x6a, 0x22, 0x0a, 0x20, 0x09, 0x4f,\n  0x0d, 0x00, 0x20, 0x03, 0x20, 0x04, 0x36, 0x02, 0x00, 0x20, 0x03, 0x20,\n  0x05, 0x36, 0x02, 0x04, 0x20, 0x05, 0x41, 0xff, 0xff, 0x01, 0x3b, 0x01,\n  0x02, 0x20, 0x05, 0x20, 0x00, 0x20, 0x02, 0x73, 0x41, 0x03, 0x74, 0x41,\n  0xf8, 0x00, 0x71, 0x20, 0x00, 0x41, 0x07, 0x71, 0x72, 0x22, 0x04, 0x41,\n  0x08, 0x74, 0x20, 0x04, 0x72, 0x3b, 0x01, 0x00, 0x20, 0x01, 0x20, 0x03,\n  0x36, 0x02, 0x00, 0x20, 0x03, 0x21, 0x04, 0x20, 0x0a, 0x21, 0x05, 0x20,\n  0x08, 0x21, 0x03, 0x0b, 0x20, 0x06, 0x20, 0x00, 0x41, 0x01, 0x6a, 0x22,\n  0x00, 0x47, 0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x04, 0x28, 0x02, 0x00, 0x22,\n  0x03, 0x04, 0x40, 0x20, 0x06, 0x41, 0x05, 0x6e, 0x21, 0x08, 0x41, 0x01,\n  0x21, 0x00, 0x03, 0x40, 0x20, 0x00, 0x41, 0x01, 0x6a, 0x21, 0x05, 0x20,\n  0x04, 0x28, 0x02, 0x04, 0x20, 0x00, 0x20, 0x08, 0x4f, 0x04, 0x7f, 0x20,\n  0x05, 0x41, 0x08, 0x74, 0x41, 0x80, 0x0e, 0x71, 0x20, 0x00, 0x20, 0x02,\n  0x73, 0x41, 0xff, 0xff, 0x00, 0x71, 0x72, 0x05, 0x20, 0x00, 0x0b, 0x3b,\n  0x01, 0x02, 0x20, 0x05, 0x21, 0x00, 0x20, 0x03, 0x22, 0x04, 0x28, 0x02,\n  0x00, 0x22, 0x03, 0x0d, 0x00, 0x0b, 0x0b, 0x41, 0x01, 0x21, 0x06, 0x03,\n  0x40, 0x20, 0x06, 0x41, 0x01, 0x4e, 0x04, 0x40, 0x41, 0x00, 0x21, 0x09,\n  0x41, 0x00, 0x21, 0x05, 0x20, 0x01, 0x21, 0x00, 0x41, 0x00, 0x21, 0x01,\n  0x03, 0x40, 0x20, 0x09, 0x22, 0x0b, 0x41, 0x01, 0x6a, 0x21, 0x09, 0x41,\n  0x00, 0x21, 0x03, 0x20, 0x00, 0x21, 0x04, 0x02, 0x7f, 0x02, 0x40, 0x03,\n  0x40, 0x20, 0x04, 0x28, 0x02, 0x00, 0x22, 0x04, 0x45, 0x0d, 0x01, 0x20,\n  0x06, 0x20, 0x03, 0x41, 0x01, 0x6a, 0x22, 0x03, 0x47, 0x0d, 0x00, 0x0b,\n  0x20, 0x06, 0x0c, 0x01, 0x0b, 0x20, 0x03, 0x41, 0x01, 0x6a, 0x0b, 0x21,\n  0x07, 0x20, 0x00, 0x21, 0x03, 0x20, 0x04, 0x21, 0x00, 0x20, 0x06, 0x21,\n  0x02, 0x03, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x7f, 0x02, 0x40, 0x02,\n  0x7f, 0x02, 0x40, 0x20, 0x07, 0x41, 0x00, 0x4a, 0x0d, 0x00, 0x20, 0x00,\n  0x45, 0x0d, 0x04, 0x20, 0x02, 0x41, 0x01, 0x48, 0x0d, 0x04, 0x20, 0x07,\n  0x0d, 0x00, 0x20, 0x00, 0x28, 0x02, 0x00, 0x21, 0x08, 0x41, 0x00, 0x21,\n  0x07, 0x20, 0x02, 0x41, 0x7f, 0x6a, 0x0c, 0x01, 0x0b, 0x20, 0x00, 0x45,\n  0x0d, 0x01, 0x20, 0x02, 0x45, 0x0d, 0x01, 0x20, 0x03, 0x28, 0x02, 0x04,\n  0x22, 0x04, 0x20, 0x04, 0x2d, 0x00, 0x01, 0x3a, 0x00, 0x00, 0x20, 0x00,\n  0x28, 0x02, 0x04, 0x22, 0x08, 0x20, 0x08, 0x2d, 0x00, 0x01, 0x3a, 0x00,\n  0x00, 0x20, 0x04, 0x2e, 0x01, 0x02, 0x20, 0x08, 0x2e, 0x01, 0x02, 0x4c,\n  0x0d, 0x01, 0x20, 0x00, 0x28, 0x02, 0x00, 0x21, 0x08, 0x20, 0x02, 0x41,\n  0x7f, 0x6a, 0x0b, 0x21, 0x02, 0x20, 0x03, 0x21, 0x0a, 0x20, 0x00, 0x0c,\n  0x01, 0x0b, 0x20, 0x07, 0x41, 0x7f, 0x6a, 0x21, 0x07, 0x20, 0x03, 0x28,\n  0x02, 0x00, 0x21, 0x0a, 0x20, 0x00, 0x21, 0x08, 0x20, 0x03, 0x0b, 0x21,\n  0x04, 0x20, 0x05, 0x45, 0x04, 0x40, 0x20, 0x04, 0x21, 0x01, 0x0c, 0x02,\n  0x0b, 0x20, 0x05, 0x20, 0x04, 0x36, 0x02, 0x00, 0x0c, 0x01, 0x0b, 0x20,\n  0x00, 0x0d, 0x02, 0x20, 0x05, 0x41, 0x00, 0x36, 0x02, 0x00, 0x20, 0x06,\n  0x41, 0x01, 0x74, 0x21, 0x06, 0x20, 0x0b, 0x0d, 0x04, 0x20, 0x01, 0x0f,\n  0x0b, 0x20, 0x0a, 0x21, 0x03, 0x20, 0x08, 0x21, 0x00, 0x20, 0x04, 0x21,\n  0x05, 0x0c, 0x00, 0x0b, 0x00, 0x0b, 0x00, 0x0b, 0x0b, 0x03, 0x40, 0x0c,\n  0x00, 0x0b, 0x00, 0x0b, 0xa7, 0x0c, 0x03, 0x0f, 0x7f, 0x01, 0x7d, 0x01,\n  0x7c, 0x23, 0x00, 0x41, 0xd0, 0x00, 0x6b, 0x22, 0x00, 0x24, 0x00, 0x20,\n  0x00, 0x41, 0x00, 0x36, 0x02, 0x4c, 0x20, 0x00, 0x41, 0xc2, 0x00, 0x6a,\n  0x22, 0x0e, 0x41, 0x01, 0x3a, 0x00, 0x00, 0x20, 0x00, 0x41, 0xa0, 0x06,\n  0x28, 0x02, 0x00, 0x28, 0x02, 0x00, 0x3b, 0x01, 0x00, 0x20, 0x00, 0x41,\n  0xa4, 0x06, 0x28, 0x02, 0x00, 0x28, 0x02, 0x00, 0x3b, 0x01, 0x02, 0x20,\n  0x00, 0x41, 0xa8, 0x06, 0x28, 0x02, 0x00, 0x28, 0x02, 0x00, 0x3b, 0x01,\n  0x04, 0x20, 0x00, 0x41, 0xac, 0x06, 0x28, 0x02, 0x00, 0x28, 0x02, 0x00,\n  0x36, 0x02, 0x1c, 0x20, 0x00, 0x41, 0xb0, 0x06, 0x28, 0x02, 0x00, 0x28,\n  0x02, 0x00, 0x22, 0x01, 0x41, 0x07, 0x20, 0x01, 0x1b, 0x22, 0x01, 0x36,\n  0x02, 0x20, 0x02, 0x40, 0x20, 0x00, 0x2f, 0x01, 0x04, 0x22, 0x05, 0x20,\n  0x00, 0x2f, 0x01, 0x02, 0x22, 0x04, 0x20, 0x00, 0x2f, 0x01, 0x00, 0x22,\n  0x02, 0x72, 0x72, 0x04, 0x40, 0x20, 0x02, 0x41, 0xff, 0xff, 0x03, 0x71,\n  0x41, 0x01, 0x47, 0x0d, 0x01, 0x41, 0x95, 0xe8, 0x00, 0x21, 0x03, 0x20,\n  0x04, 0x20, 0x05, 0x72, 0x0d, 0x01, 0x0b, 0x20, 0x00, 0x41, 0xe6, 0x00,\n  0x3b, 0x01, 0x04, 0x20, 0x00, 0x20, 0x03, 0x3b, 0x01, 0x02, 0x20, 0x00,\n  0x20, 0x03, 0x3b, 0x01, 0x00, 0x20, 0x03, 0x21, 0x02, 0x0b, 0x20, 0x00,\n  0x41, 0x00, 0x3b, 0x01, 0x40, 0x20, 0x00, 0x41, 0xc0, 0x06, 0x36, 0x02,\n  0x08, 0x20, 0x00, 0x41, 0xd0, 0x0f, 0x20, 0x01, 0x41, 0x01, 0x71, 0x22,\n  0x05, 0x20, 0x01, 0x41, 0x02, 0x71, 0x22, 0x04, 0x41, 0x01, 0x76, 0x6a,\n  0x20, 0x01, 0x41, 0x04, 0x71, 0x22, 0x03, 0x41, 0x02, 0x76, 0x6a, 0x6e,\n  0x22, 0x06, 0x36, 0x02, 0x18, 0x20, 0x05, 0x04, 0x40, 0x20, 0x00, 0x41,\n  0xc0, 0x06, 0x36, 0x02, 0x0c, 0x41, 0x01, 0x21, 0x07, 0x0b, 0x20, 0x04,\n  0x04, 0x40, 0x20, 0x00, 0x41, 0x10, 0x6a, 0x20, 0x06, 0x20, 0x07, 0x6c,\n  0x41, 0xc0, 0x06, 0x6a, 0x36, 0x02, 0x00, 0x20, 0x07, 0x41, 0x01, 0x6a,\n  0x21, 0x07, 0x0b, 0x20, 0x03, 0x04, 0x40, 0x20, 0x00, 0x41, 0x14, 0x6a,\n  0x20, 0x06, 0x20, 0x07, 0x6c, 0x41, 0xc0, 0x06, 0x6a, 0x36, 0x02, 0x00,\n  0x0b, 0x20, 0x05, 0x04, 0x7f, 0x20, 0x00, 0x20, 0x06, 0x20, 0x00, 0x28,\n  0x02, 0x0c, 0x20, 0x02, 0x41, 0x10, 0x74, 0x41, 0x10, 0x75, 0x10, 0x03,\n  0x36, 0x02, 0x24, 0x20, 0x00, 0x28, 0x02, 0x20, 0x22, 0x01, 0x41, 0x02,\n  0x71, 0x05, 0x20, 0x04, 0x0b, 0x04, 0x7f, 0x20, 0x00, 0x28, 0x02, 0x18,\n  0x20, 0x00, 0x28, 0x02, 0x10, 0x20, 0x00, 0x2e, 0x01, 0x00, 0x20, 0x00,\n  0x2f, 0x01, 0x02, 0x41, 0x10, 0x74, 0x72, 0x20, 0x00, 0x41, 0x28, 0x6a,\n  0x10, 0x06, 0x20, 0x00, 0x28, 0x02, 0x20, 0x05, 0x20, 0x01, 0x0b, 0x41,\n  0x04, 0x71, 0x04, 0x40, 0x20, 0x00, 0x28, 0x02, 0x18, 0x20, 0x00, 0x2e,\n  0x01, 0x00, 0x20, 0x00, 0x28, 0x02, 0x14, 0x10, 0x09, 0x0b, 0x20, 0x00,\n  0x28, 0x02, 0x1c, 0x45, 0x04, 0x40, 0x20, 0x00, 0x41, 0x01, 0x36, 0x02,\n  0x1c, 0x41, 0x01, 0x21, 0x01, 0x03, 0x40, 0x20, 0x00, 0x20, 0x01, 0x41,\n  0x0a, 0x6c, 0x36, 0x02, 0x1c, 0x10, 0x0e, 0x20, 0x00, 0x42, 0x00, 0x37,\n  0x03, 0x38, 0x02, 0x40, 0x20, 0x00, 0x28, 0x02, 0x1c, 0x22, 0x01, 0x45,\n  0x0d, 0x00, 0x20, 0x00, 0x20, 0x00, 0x41, 0x01, 0x10, 0x02, 0x20, 0x00,\n  0x2f, 0x01, 0x38, 0x10, 0x0a, 0x3b, 0x01, 0x38, 0x20, 0x00, 0x20, 0x00,\n  0x41, 0x7f, 0x10, 0x02, 0x20, 0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a, 0x22,\n  0x03, 0x3b, 0x01, 0x3a, 0x20, 0x00, 0x20, 0x03, 0x3b, 0x01, 0x38, 0x20,\n  0x01, 0x41, 0x01, 0x46, 0x0d, 0x00, 0x20, 0x01, 0x41, 0x7f, 0x6a, 0x21,\n  0x01, 0x03, 0x40, 0x20, 0x00, 0x20, 0x00, 0x41, 0x01, 0x10, 0x02, 0x20,\n  0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a, 0x3b, 0x01, 0x38, 0x20, 0x00, 0x20,\n  0x00, 0x41, 0x7f, 0x10, 0x02, 0x20, 0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a,\n  0x3b, 0x01, 0x38, 0x20, 0x01, 0x41, 0x7f, 0x6a, 0x22, 0x01, 0x0d, 0x00,\n  0x0b, 0x0b, 0x10, 0x0f, 0x41, 0xa4, 0x16, 0x28, 0x02, 0x00, 0x41, 0xa0,\n  0x16, 0x28, 0x02, 0x00, 0x6b, 0xb8, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x40, 0x8f, 0x40, 0xa3, 0x22, 0x10, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0xf0, 0x3f, 0x63, 0x41, 0x01, 0x73, 0x45, 0x04, 0x40, 0x20, 0x00,\n  0x28, 0x02, 0x1c, 0x21, 0x01, 0x0c, 0x01, 0x0b, 0x0b, 0x20, 0x00, 0x20,\n  0x00, 0x28, 0x02, 0x1c, 0x41, 0x0a, 0x02, 0x7f, 0x20, 0x10, 0x44, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x41, 0x63, 0x20, 0x10, 0x44, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x71, 0x04, 0x40, 0x20,\n  0x10, 0xab, 0x0c, 0x01, 0x0b, 0x41, 0x00, 0x0b, 0x22, 0x03, 0x41, 0x01,\n  0x20, 0x03, 0x1b, 0x6e, 0x41, 0x01, 0x6a, 0x6c, 0x36, 0x02, 0x1c, 0x0b,\n  0x10, 0x0e, 0x20, 0x00, 0x42, 0x00, 0x37, 0x03, 0x38, 0x02, 0x40, 0x20,\n  0x00, 0x28, 0x02, 0x1c, 0x22, 0x01, 0x45, 0x0d, 0x00, 0x20, 0x00, 0x20,\n  0x00, 0x41, 0x01, 0x10, 0x02, 0x20, 0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a,\n  0x3b, 0x01, 0x38, 0x20, 0x00, 0x20, 0x00, 0x41, 0x7f, 0x10, 0x02, 0x20,\n  0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a, 0x22, 0x03, 0x3b, 0x01, 0x3a, 0x20,\n  0x00, 0x20, 0x03, 0x3b, 0x01, 0x38, 0x20, 0x01, 0x41, 0x01, 0x46, 0x0d,\n  0x00, 0x20, 0x01, 0x41, 0x7f, 0x6a, 0x21, 0x01, 0x03, 0x40, 0x20, 0x00,\n  0x20, 0x00, 0x41, 0x01, 0x10, 0x02, 0x20, 0x00, 0x2f, 0x01, 0x38, 0x10,\n  0x0a, 0x3b, 0x01, 0x38, 0x20, 0x00, 0x20, 0x00, 0x41, 0x7f, 0x10, 0x02,\n  0x20, 0x00, 0x2f, 0x01, 0x38, 0x10, 0x0a, 0x3b, 0x01, 0x38, 0x20, 0x01,\n  0x41, 0x7f, 0x6a, 0x22, 0x01, 0x0d, 0x00, 0x0b, 0x0b, 0x10, 0x0f, 0x41,\n  0x00, 0x21, 0x02, 0x41, 0xa4, 0x16, 0x28, 0x02, 0x00, 0x41, 0xa0, 0x16,\n  0x28, 0x02, 0x00, 0x6b, 0x21, 0x0c, 0x20, 0x00, 0x2e, 0x01, 0x00, 0x41,\n  0x00, 0x10, 0x0c, 0x21, 0x03, 0x20, 0x00, 0x2e, 0x01, 0x02, 0x20, 0x03,\n  0x10, 0x0c, 0x21, 0x03, 0x20, 0x00, 0x2e, 0x01, 0x04, 0x20, 0x03, 0x10,\n  0x0c, 0x21, 0x01, 0x41, 0xff, 0xff, 0x03, 0x21, 0x03, 0x02, 0x40, 0x02,\n  0x40, 0x02, 0x40, 0x20, 0x00, 0x2e, 0x01, 0x18, 0x20, 0x01, 0x10, 0x0c,\n  0x22, 0x01, 0x41, 0x84, 0xf6, 0x01, 0x4c, 0x04, 0x40, 0x20, 0x01, 0x41,\n  0xf2, 0x31, 0x46, 0x0d, 0x01, 0x20, 0x01, 0x41, 0xaf, 0x9d, 0x01, 0x47,\n  0x0d, 0x03, 0x41, 0x02, 0x21, 0x02, 0x0c, 0x02, 0x0b, 0x20, 0x01, 0x41,\n  0xf5, 0xd3, 0x03, 0x47, 0x04, 0x40, 0x20, 0x01, 0x41, 0x82, 0x94, 0x02,\n  0x46, 0x0d, 0x02, 0x20, 0x01, 0x41, 0x85, 0xf6, 0x01, 0x47, 0x0d, 0x03,\n  0x41, 0x01, 0x21, 0x02, 0x0c, 0x02, 0x0b, 0x41, 0x03, 0x21, 0x02, 0x0c,\n  0x01, 0x0b, 0x41, 0x04, 0x21, 0x02, 0x0b, 0x41, 0x00, 0x21, 0x03, 0x41,\n  0xb8, 0x06, 0x28, 0x02, 0x00, 0x22, 0x08, 0x45, 0x0d, 0x00, 0x20, 0x00,\n  0x28, 0x02, 0x20, 0x22, 0x04, 0x41, 0x04, 0x71, 0x21, 0x09, 0x20, 0x04,\n  0x41, 0x02, 0x71, 0x21, 0x0d, 0x20, 0x02, 0x41, 0x01, 0x74, 0x22, 0x01,\n  0x41, 0x94, 0x04, 0x6a, 0x21, 0x0a, 0x20, 0x01, 0x41, 0x8a, 0x04, 0x6a,\n  0x21, 0x07, 0x20, 0x00, 0x2f, 0x01, 0x3e, 0x21, 0x0b, 0x20, 0x00, 0x2f,\n  0x01, 0x3c, 0x21, 0x06, 0x02, 0x40, 0x20, 0x04, 0x41, 0x01, 0x71, 0x04,\n  0x40, 0x41, 0x02, 0x41, 0x01, 0x20, 0x00, 0x2f, 0x01, 0x3a, 0x20, 0x01,\n  0x41, 0x80, 0x04, 0x6a, 0x2f, 0x01, 0x00, 0x47, 0x22, 0x04, 0x1b, 0x21,\n  0x05, 0x41, 0x00, 0x21, 0x02, 0x03, 0x40, 0x20, 0x04, 0x21, 0x01, 0x20,\n  0x0d, 0x04, 0x40, 0x20, 0x04, 0x20, 0x05, 0x20, 0x06, 0x20, 0x07, 0x2f,\n  0x01, 0x00, 0x46, 0x1b, 0x21, 0x01, 0x0b, 0x20, 0x09, 0x04, 0x40, 0x20,\n  0x01, 0x20, 0x0b, 0x20, 0x0a, 0x2f, 0x01, 0x00, 0x47, 0x6a, 0x21, 0x01,\n  0x0b, 0x20, 0x01, 0x20, 0x03, 0x6a, 0x21, 0x03, 0x20, 0x08, 0x20, 0x02,\n  0x41, 0x01, 0x6a, 0x22, 0x02, 0x41, 0xff, 0xff, 0x03, 0x71, 0x4b, 0x0d,\n  0x00, 0x0b, 0x0c, 0x01, 0x0b, 0x20, 0x0d, 0x45, 0x04, 0x40, 0x41, 0x00,\n  0x21, 0x02, 0x03, 0x40, 0x41, 0x00, 0x21, 0x01, 0x20, 0x09, 0x04, 0x40,\n  0x20, 0x0b, 0x20, 0x0a, 0x2f, 0x01, 0x00, 0x47, 0x21, 0x01, 0x0b, 0x20,\n  0x01, 0x20, 0x03, 0x6a, 0x21, 0x03, 0x20, 0x08, 0x20, 0x02, 0x41, 0x01,\n  0x6a, 0x22, 0x02, 0x41, 0xff, 0xff, 0x03, 0x71, 0x4b, 0x0d, 0x00, 0x0b,\n  0x0c, 0x01, 0x0b, 0x41, 0x02, 0x41, 0x01, 0x20, 0x06, 0x20, 0x07, 0x2f,\n  0x01, 0x00, 0x47, 0x22, 0x04, 0x1b, 0x21, 0x05, 0x41, 0x00, 0x21, 0x02,\n  0x03, 0x40, 0x20, 0x04, 0x21, 0x01, 0x20, 0x09, 0x04, 0x40, 0x20, 0x04,\n  0x20, 0x05, 0x20, 0x0b, 0x20, 0x0a, 0x2f, 0x01, 0x00, 0x46, 0x1b, 0x21,\n  0x01, 0x0b, 0x20, 0x01, 0x20, 0x03, 0x6a, 0x21, 0x03, 0x20, 0x08, 0x20,\n  0x02, 0x41, 0x01, 0x6a, 0x22, 0x02, 0x41, 0xff, 0xff, 0x03, 0x71, 0x4b,\n  0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x00, 0x20, 0x01, 0x3b, 0x01, 0x40, 0x0b,\n  0x20, 0x0c, 0xb8, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x8f, 0x40,\n  0xa3, 0x21, 0x10, 0x20, 0x00, 0x28, 0x02, 0x20, 0x22, 0x06, 0x41, 0x01,\n  0x71, 0x04, 0x40, 0x41, 0xb8, 0x06, 0x28, 0x02, 0x00, 0x21, 0x02, 0x41,\n  0x00, 0x21, 0x01, 0x03, 0x40, 0x20, 0x01, 0x41, 0xff, 0xff, 0x03, 0x71,\n  0x21, 0x04, 0x20, 0x01, 0x41, 0x01, 0x6a, 0x21, 0x01, 0x20, 0x02, 0x20,\n  0x04, 0x4b, 0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x06, 0x41, 0x02, 0x71, 0x04,\n  0x40, 0x41, 0x00, 0x21, 0x01, 0x41, 0xb8, 0x06, 0x28, 0x02, 0x00, 0x21,\n  0x02, 0x03, 0x40, 0x20, 0x01, 0x41, 0xff, 0xff, 0x03, 0x71, 0x21, 0x04,\n  0x20, 0x01, 0x41, 0x01, 0x6a, 0x21, 0x01, 0x20, 0x02, 0x20, 0x04, 0x4b,\n  0x0d, 0x00, 0x0b, 0x0b, 0x41, 0x00, 0x21, 0x01, 0x41, 0xb8, 0x06, 0x28,\n  0x02, 0x00, 0x21, 0x05, 0x20, 0x06, 0x41, 0x04, 0x71, 0x04, 0x40, 0x03,\n  0x40, 0x20, 0x01, 0x41, 0xff, 0xff, 0x03, 0x71, 0x21, 0x04, 0x20, 0x01,\n  0x41, 0x01, 0x6a, 0x21, 0x01, 0x20, 0x05, 0x20, 0x04, 0x4b, 0x0d, 0x00,\n  0x0b, 0x0b, 0x41, 0x7f, 0x41, 0x00, 0x20, 0x10, 0x44, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x24, 0x40, 0x63, 0x1b, 0x21, 0x02, 0x41, 0x00, 0x21,\n  0x01, 0x03, 0x40, 0x20, 0x01, 0x41, 0xff, 0xff, 0x03, 0x71, 0x21, 0x04,\n  0x20, 0x01, 0x41, 0x01, 0x6a, 0x21, 0x01, 0x20, 0x05, 0x20, 0x04, 0x4b,\n  0x0d, 0x00, 0x0b, 0x20, 0x0e, 0x41, 0x00, 0x3a, 0x00, 0x00, 0x20, 0x03,\n  0x41, 0xff, 0xff, 0x03, 0x71, 0x20, 0x02, 0x41, 0xff, 0xff, 0x03, 0x71,\n  0x46, 0x04, 0x40, 0x20, 0x00, 0x28, 0x02, 0x1c, 0x41, 0xb8, 0x06, 0x28,\n  0x02, 0x00, 0x6c, 0xb8, 0x20, 0x0c, 0xb8, 0x44, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x40, 0x8f, 0x40, 0xa3, 0xa3, 0xb6, 0x21, 0x0f, 0x0b, 0x20, 0x00,\n  0x41, 0xd0, 0x00, 0x6a, 0x24, 0x00, 0x20, 0x0f, 0x0b, 0xfb, 0x09, 0x01,\n  0x0d, 0x7f, 0x02, 0x40, 0x20, 0x00, 0x04, 0x40, 0x20, 0x04, 0x41, 0x80,\n  0x60, 0x72, 0x21, 0x10, 0x20, 0x00, 0x41, 0x01, 0x74, 0x21, 0x0a, 0x20,\n  0x02, 0x21, 0x07, 0x03, 0x40, 0x20, 0x00, 0x21, 0x05, 0x20, 0x07, 0x21,\n  0x06, 0x03, 0x40, 0x20, 0x06, 0x20, 0x06, 0x2f, 0x01, 0x00, 0x20, 0x04,\n  0x6a, 0x3b, 0x01, 0x00, 0x20, 0x06, 0x41, 0x02, 0x6a, 0x21, 0x06, 0x20,\n  0x05, 0x41, 0x7f, 0x6a, 0x22, 0x05, 0x0d, 0x00, 0x0b, 0x20, 0x07, 0x20,\n  0x0a, 0x6a, 0x21, 0x07, 0x20, 0x0b, 0x41, 0x01, 0x6a, 0x22, 0x0b, 0x20,\n  0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00, 0x41, 0x01, 0x74, 0x21, 0x0a,\n  0x20, 0x00, 0x41, 0x02, 0x74, 0x21, 0x0c, 0x20, 0x02, 0x21, 0x0b, 0x20,\n  0x01, 0x21, 0x08, 0x03, 0x40, 0x20, 0x00, 0x21, 0x07, 0x20, 0x0b, 0x21,\n  0x06, 0x20, 0x08, 0x21, 0x05, 0x03, 0x40, 0x20, 0x05, 0x20, 0x06, 0x2e,\n  0x01, 0x00, 0x20, 0x04, 0x6c, 0x36, 0x02, 0x00, 0x20, 0x06, 0x41, 0x02,\n  0x6a, 0x21, 0x06, 0x20, 0x05, 0x41, 0x04, 0x6a, 0x21, 0x05, 0x20, 0x07,\n  0x41, 0x7f, 0x6a, 0x22, 0x07, 0x0d, 0x00, 0x0b, 0x20, 0x0a, 0x20, 0x0b,\n  0x6a, 0x21, 0x0b, 0x20, 0x08, 0x20, 0x0c, 0x6a, 0x21, 0x08, 0x20, 0x09,\n  0x41, 0x01, 0x6a, 0x22, 0x09, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20,\n  0x00, 0x41, 0x02, 0x74, 0x21, 0x0d, 0x20, 0x01, 0x21, 0x0a, 0x41, 0x00,\n  0x21, 0x0c, 0x41, 0x00, 0x21, 0x08, 0x41, 0x00, 0x21, 0x07, 0x41, 0x00,\n  0x21, 0x09, 0x03, 0x40, 0x20, 0x00, 0x21, 0x0b, 0x20, 0x0a, 0x21, 0x05,\n  0x03, 0x40, 0x41, 0x00, 0x20, 0x05, 0x28, 0x02, 0x00, 0x22, 0x06, 0x20,\n  0x09, 0x6a, 0x22, 0x09, 0x20, 0x09, 0x20, 0x10, 0x4a, 0x22, 0x0e, 0x1b,\n  0x21, 0x09, 0x41, 0x0a, 0x20, 0x06, 0x20, 0x07, 0x4a, 0x20, 0x0e, 0x1b,\n  0x20, 0x08, 0x6a, 0x21, 0x08, 0x20, 0x05, 0x41, 0x04, 0x6a, 0x21, 0x05,\n  0x20, 0x06, 0x21, 0x07, 0x20, 0x0b, 0x41, 0x7f, 0x6a, 0x22, 0x0b, 0x0d,\n  0x00, 0x0b, 0x20, 0x0a, 0x20, 0x0d, 0x6a, 0x21, 0x0a, 0x20, 0x0c, 0x41,\n  0x01, 0x6a, 0x22, 0x0c, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00,\n  0x41, 0x01, 0x74, 0x21, 0x0a, 0x20, 0x08, 0x41, 0x10, 0x74, 0x41, 0x10,\n  0x75, 0x41, 0x00, 0x10, 0x0c, 0x21, 0x0e, 0x20, 0x02, 0x21, 0x08, 0x41,\n  0x00, 0x21, 0x09, 0x03, 0x40, 0x20, 0x01, 0x20, 0x09, 0x41, 0x02, 0x74,\n  0x6a, 0x22, 0x0c, 0x41, 0x00, 0x36, 0x02, 0x00, 0x20, 0x03, 0x21, 0x06,\n  0x20, 0x00, 0x21, 0x0b, 0x20, 0x08, 0x21, 0x05, 0x41, 0x00, 0x21, 0x07,\n  0x03, 0x40, 0x20, 0x06, 0x2e, 0x01, 0x00, 0x20, 0x05, 0x2e, 0x01, 0x00,\n  0x6c, 0x20, 0x07, 0x6a, 0x21, 0x07, 0x20, 0x06, 0x41, 0x02, 0x6a, 0x21,\n  0x06, 0x20, 0x05, 0x41, 0x02, 0x6a, 0x21, 0x05, 0x20, 0x0b, 0x41, 0x7f,\n  0x6a, 0x22, 0x0b, 0x0d, 0x00, 0x0b, 0x20, 0x0c, 0x20, 0x07, 0x36, 0x02,\n  0x00, 0x20, 0x08, 0x20, 0x0a, 0x6a, 0x21, 0x08, 0x20, 0x09, 0x41, 0x01,\n  0x6a, 0x22, 0x09, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00, 0x41,\n  0x02, 0x74, 0x21, 0x0d, 0x20, 0x01, 0x21, 0x0a, 0x41, 0x00, 0x21, 0x0c,\n  0x41, 0x00, 0x21, 0x09, 0x41, 0x00, 0x21, 0x07, 0x41, 0x00, 0x21, 0x08,\n  0x03, 0x40, 0x20, 0x00, 0x21, 0x0b, 0x20, 0x0a, 0x21, 0x05, 0x03, 0x40,\n  0x41, 0x00, 0x20, 0x05, 0x28, 0x02, 0x00, 0x22, 0x06, 0x20, 0x08, 0x6a,\n  0x22, 0x08, 0x20, 0x08, 0x20, 0x10, 0x4a, 0x22, 0x0f, 0x1b, 0x21, 0x08,\n  0x41, 0x0a, 0x20, 0x06, 0x20, 0x07, 0x4a, 0x20, 0x0f, 0x1b, 0x20, 0x09,\n  0x6a, 0x21, 0x09, 0x20, 0x05, 0x41, 0x04, 0x6a, 0x21, 0x05, 0x20, 0x06,\n  0x21, 0x07, 0x20, 0x0b, 0x41, 0x7f, 0x6a, 0x22, 0x0b, 0x0d, 0x00, 0x0b,\n  0x20, 0x0a, 0x20, 0x0d, 0x6a, 0x21, 0x0a, 0x20, 0x0c, 0x41, 0x01, 0x6a,\n  0x22, 0x0c, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00, 0x41, 0x01,\n  0x74, 0x21, 0x0d, 0x41, 0x00, 0x21, 0x0a, 0x20, 0x09, 0x41, 0x10, 0x74,\n  0x41, 0x10, 0x75, 0x20, 0x0e, 0x10, 0x0c, 0x21, 0x0e, 0x20, 0x02, 0x21,\n  0x0c, 0x03, 0x40, 0x20, 0x00, 0x20, 0x0a, 0x6c, 0x21, 0x0f, 0x20, 0x03,\n  0x21, 0x09, 0x41, 0x00, 0x21, 0x08, 0x03, 0x40, 0x41, 0x00, 0x21, 0x07,\n  0x20, 0x01, 0x20, 0x08, 0x20, 0x0f, 0x6a, 0x41, 0x02, 0x74, 0x6a, 0x22,\n  0x11, 0x41, 0x00, 0x36, 0x02, 0x00, 0x20, 0x00, 0x21, 0x0b, 0x20, 0x0c,\n  0x21, 0x06, 0x20, 0x09, 0x21, 0x05, 0x03, 0x40, 0x20, 0x05, 0x2e, 0x01,\n  0x00, 0x20, 0x06, 0x2e, 0x01, 0x00, 0x6c, 0x20, 0x07, 0x6a, 0x21, 0x07,\n  0x20, 0x06, 0x41, 0x02, 0x6a, 0x21, 0x06, 0x20, 0x05, 0x20, 0x0d, 0x6a,\n  0x21, 0x05, 0x20, 0x0b, 0x41, 0x7f, 0x6a, 0x22, 0x0b, 0x0d, 0x00, 0x0b,\n  0x20, 0x11, 0x20, 0x07, 0x36, 0x02, 0x00, 0x20, 0x09, 0x41, 0x02, 0x6a,\n  0x21, 0x09, 0x20, 0x08, 0x41, 0x01, 0x6a, 0x22, 0x08, 0x20, 0x00, 0x47,\n  0x0d, 0x00, 0x0b, 0x20, 0x0c, 0x20, 0x0d, 0x6a, 0x21, 0x0c, 0x20, 0x0a,\n  0x41, 0x01, 0x6a, 0x22, 0x0a, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20,\n  0x00, 0x41, 0x02, 0x74, 0x21, 0x0d, 0x20, 0x01, 0x21, 0x0a, 0x41, 0x00,\n  0x21, 0x0c, 0x41, 0x00, 0x21, 0x08, 0x41, 0x00, 0x21, 0x07, 0x41, 0x00,\n  0x21, 0x09, 0x03, 0x40, 0x20, 0x00, 0x21, 0x0b, 0x20, 0x0a, 0x21, 0x05,\n  0x03, 0x40, 0x41, 0x00, 0x20, 0x05, 0x28, 0x02, 0x00, 0x22, 0x06, 0x20,\n  0x09, 0x6a, 0x22, 0x09, 0x20, 0x09, 0x20, 0x10, 0x4a, 0x22, 0x0f, 0x1b,\n  0x21, 0x09, 0x41, 0x0a, 0x20, 0x06, 0x20, 0x07, 0x4a, 0x20, 0x0f, 0x1b,\n  0x20, 0x08, 0x6a, 0x21, 0x08, 0x20, 0x05, 0x41, 0x04, 0x6a, 0x21, 0x05,\n  0x20, 0x06, 0x21, 0x07, 0x20, 0x0b, 0x41, 0x7f, 0x6a, 0x22, 0x0b, 0x0d,\n  0x00, 0x0b, 0x20, 0x0a, 0x20, 0x0d, 0x6a, 0x21, 0x0a, 0x20, 0x0c, 0x41,\n  0x01, 0x6a, 0x22, 0x0c, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00,\n  0x41, 0x01, 0x74, 0x21, 0x0d, 0x41, 0x00, 0x21, 0x0c, 0x20, 0x08, 0x41,\n  0x10, 0x74, 0x41, 0x10, 0x75, 0x20, 0x0e, 0x10, 0x0c, 0x21, 0x0e, 0x20,\n  0x02, 0x21, 0x09, 0x03, 0x40, 0x20, 0x00, 0x20, 0x0c, 0x6c, 0x21, 0x0f,\n  0x20, 0x03, 0x21, 0x08, 0x41, 0x00, 0x21, 0x0a, 0x03, 0x40, 0x41, 0x00,\n  0x21, 0x07, 0x20, 0x01, 0x20, 0x0a, 0x20, 0x0f, 0x6a, 0x41, 0x02, 0x74,\n  0x6a, 0x22, 0x11, 0x41, 0x00, 0x36, 0x02, 0x00, 0x20, 0x00, 0x21, 0x0b,\n  0x20, 0x09, 0x21, 0x06, 0x20, 0x08, 0x21, 0x05, 0x03, 0x40, 0x20, 0x07,\n  0x20, 0x05, 0x2f, 0x01, 0x00, 0x20, 0x06, 0x2f, 0x01, 0x00, 0x6c, 0x22,\n  0x07, 0x41, 0x02, 0x76, 0x41, 0x0f, 0x71, 0x20, 0x07, 0x41, 0x05, 0x76,\n  0x41, 0xff, 0x00, 0x71, 0x6c, 0x6a, 0x21, 0x07, 0x20, 0x06, 0x41, 0x02,\n  0x6a, 0x21, 0x06, 0x20, 0x05, 0x20, 0x0d, 0x6a, 0x21, 0x05, 0x20, 0x0b,\n  0x41, 0x7f, 0x6a, 0x22, 0x0b, 0x0d, 0x00, 0x0b, 0x20, 0x11, 0x20, 0x07,\n  0x36, 0x02, 0x00, 0x20, 0x08, 0x41, 0x02, 0x6a, 0x21, 0x08, 0x20, 0x0a,\n  0x41, 0x01, 0x6a, 0x22, 0x0a, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20,\n  0x09, 0x20, 0x0d, 0x6a, 0x21, 0x09, 0x20, 0x0c, 0x41, 0x01, 0x6a, 0x22,\n  0x0c, 0x20, 0x00, 0x47, 0x0d, 0x00, 0x0b, 0x20, 0x00, 0x41, 0x02, 0x74,\n  0x21, 0x06, 0x41, 0x00, 0x21, 0x0a, 0x41, 0x00, 0x21, 0x08, 0x41, 0x00,\n  0x21, 0x07, 0x41, 0x00, 0x21, 0x09, 0x03, 0x40, 0x20, 0x00, 0x21, 0x0b,\n  0x20, 0x01, 0x21, 0x05, 0x03, 0x40, 0x41, 0x00, 0x20, 0x05, 0x28, 0x02,\n  0x00, 0x22, 0x03, 0x20, 0x09, 0x6a, 0x22, 0x09, 0x20, 0x09, 0x20, 0x10,\n  0x4a, 0x22, 0x0c, 0x1b, 0x21, 0x09, 0x41, 0x0a, 0x20, 0x03, 0x20, 0x07,\n  0x4a, 0x20, 0x0c, 0x1b, 0x20, 0x08, 0x6a, 0x21, 0x08, 0x20, 0x05, 0x41,\n  0x04, 0x6a, 0x21, 0x05, 0x20, 0x03, 0x21, 0x07, 0x20, 0x0b, 0x41, 0x7f,\n  0x6a, 0x22, 0x0b, 0x0d, 0x00, 0x0b, 0x20, 0x01, 0x20, 0x06, 0x6a, 0x21,\n  0x01, 0x20, 0x0a, 0x41, 0x01, 0x6a, 0x22, 0x0a, 0x20, 0x00, 0x47, 0x0d,\n  0x00, 0x0b, 0x20, 0x00, 0x41, 0x01, 0x74, 0x21, 0x01, 0x41, 0x00, 0x21,\n  0x07, 0x20, 0x08, 0x41, 0x10, 0x74, 0x41, 0x10, 0x75, 0x20, 0x0e, 0x10,\n  0x0c, 0x21, 0x08, 0x03, 0x40, 0x20, 0x00, 0x21, 0x05, 0x20, 0x02, 0x21,\n  0x06, 0x03, 0x40, 0x20, 0x06, 0x20, 0x06, 0x2f, 0x01, 0x00, 0x20, 0x04,\n  0x6b, 0x3b, 0x01, 0x00, 0x20, 0x06, 0x41, 0x02, 0x6a, 0x21, 0x06, 0x20,\n  0x05, 0x41, 0x7f, 0x6a, 0x22, 0x05, 0x0d, 0x00, 0x0b, 0x20, 0x01, 0x20,\n  0x02, 0x6a, 0x21, 0x02, 0x20, 0x07, 0x41, 0x01, 0x6a, 0x22, 0x07, 0x20,\n  0x00, 0x47, 0x0d, 0x00, 0x0b, 0x0c, 0x01, 0x0b, 0x41, 0x00, 0x41, 0x00,\n  0x41, 0x00, 0x41, 0x00, 0x41, 0x00, 0x10, 0x0c, 0x10, 0x0c, 0x10, 0x0c,\n  0x10, 0x0c, 0x21, 0x08, 0x0b, 0x20, 0x08, 0x41, 0x10, 0x74, 0x41, 0x10,\n  0x75, 0x0b, 0x91, 0x02, 0x01, 0x0b, 0x7f, 0x02, 0x40, 0x20, 0x00, 0x45,\n  0x04, 0x40, 0x41, 0x7f, 0x21, 0x04, 0x0c, 0x01, 0x0b, 0x41, 0x7f, 0x21,\n  0x05, 0x41, 0x08, 0x21, 0x06, 0x03, 0x40, 0x20, 0x06, 0x20, 0x05, 0x41,\n  0x02, 0x6a, 0x6c, 0x20, 0x06, 0x41, 0x08, 0x6a, 0x21, 0x06, 0x20, 0x05,\n  0x41, 0x01, 0x6a, 0x22, 0x04, 0x21, 0x05, 0x20, 0x00, 0x49, 0x0d, 0x00,\n  0x0b, 0x0b, 0x20, 0x01, 0x41, 0x03, 0x6a, 0x41, 0x7c, 0x71, 0x22, 0x07,\n  0x20, 0x04, 0x20, 0x04, 0x6c, 0x22, 0x09, 0x41, 0x01, 0x74, 0x6a, 0x21,\n  0x0a, 0x20, 0x04, 0x04, 0x40, 0x20, 0x02, 0x41, 0x01, 0x20, 0x02, 0x1b,\n  0x21, 0x00, 0x20, 0x04, 0x41, 0x01, 0x74, 0x21, 0x0b, 0x20, 0x09, 0x41,\n  0x01, 0x74, 0x21, 0x0c, 0x20, 0x07, 0x21, 0x02, 0x41, 0x01, 0x21, 0x01,\n  0x03, 0x40, 0x20, 0x01, 0x41, 0x01, 0x74, 0x21, 0x08, 0x20, 0x02, 0x21,\n  0x05, 0x41, 0x00, 0x21, 0x06, 0x03, 0x40, 0x20, 0x05, 0x20, 0x0c, 0x6a,\n  0x20, 0x01, 0x20, 0x06, 0x6a, 0x22, 0x0d, 0x20, 0x00, 0x20, 0x0d, 0x6c,\n  0x41, 0x80, 0x80, 0x04, 0x6f, 0x22, 0x00, 0x6a, 0x3b, 0x01, 0x00, 0x20,\n  0x05, 0x20, 0x00, 0x20, 0x08, 0x6a, 0x41, 0xff, 0x01, 0x71, 0x3b, 0x01,\n  0x00, 0x20, 0x08, 0x41, 0x02, 0x6a, 0x21, 0x08, 0x20, 0x05, 0x41, 0x02,\n  0x6a, 0x21, 0x05, 0x20, 0x04, 0x20, 0x06, 0x41, 0x01, 0x6a, 0x22, 0x06,\n  0x47, 0x0d, 0x00, 0x0b, 0x20, 0x01, 0x20, 0x06, 0x6a, 0x21, 0x01, 0x20,\n  0x02, 0x20, 0x0b, 0x6a, 0x21, 0x02, 0x20, 0x0e, 0x41, 0x01, 0x6a, 0x22,\n  0x0e, 0x20, 0x04, 0x47, 0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x03, 0x20, 0x0a,\n  0x36, 0x02, 0x08, 0x20, 0x03, 0x20, 0x07, 0x36, 0x02, 0x04, 0x20, 0x03,\n  0x20, 0x04, 0x36, 0x02, 0x00, 0x20, 0x03, 0x20, 0x0a, 0x20, 0x09, 0x41,\n  0x01, 0x74, 0x6a, 0x41, 0x03, 0x6a, 0x41, 0x7c, 0x71, 0x36, 0x02, 0x0c,\n  0x0b, 0x88, 0x04, 0x01, 0x04, 0x7f, 0x23, 0x00, 0x41, 0xd0, 0x00, 0x6b,\n  0x22, 0x06, 0x24, 0x00, 0x20, 0x06, 0x41, 0x20, 0x6a, 0x42, 0x00, 0x37,\n  0x03, 0x00, 0x20, 0x06, 0x41, 0x28, 0x6a, 0x42, 0x00, 0x37, 0x03, 0x00,\n  0x20, 0x06, 0x41, 0x40, 0x6b, 0x42, 0x00, 0x37, 0x03, 0x00, 0x20, 0x06,\n  0x41, 0xc8, 0x00, 0x6a, 0x42, 0x00, 0x37, 0x03, 0x00, 0x20, 0x06, 0x42,\n  0x00, 0x37, 0x03, 0x30, 0x20, 0x06, 0x42, 0x00, 0x37, 0x03, 0x38, 0x20,\n  0x06, 0x42, 0x00, 0x37, 0x03, 0x10, 0x20, 0x06, 0x42, 0x00, 0x37, 0x03,\n  0x18, 0x20, 0x06, 0x20, 0x01, 0x36, 0x02, 0x0c, 0x20, 0x01, 0x2d, 0x00,\n  0x00, 0x04, 0x40, 0x03, 0x40, 0x20, 0x06, 0x41, 0x30, 0x6a, 0x20, 0x06,\n  0x41, 0x0c, 0x6a, 0x20, 0x06, 0x41, 0x10, 0x6a, 0x10, 0x08, 0x41, 0x02,\n  0x74, 0x6a, 0x22, 0x07, 0x20, 0x07, 0x28, 0x02, 0x00, 0x41, 0x01, 0x6a,\n  0x36, 0x02, 0x00, 0x20, 0x06, 0x28, 0x02, 0x0c, 0x2d, 0x00, 0x00, 0x0d,\n  0x00, 0x0b, 0x0b, 0x20, 0x06, 0x20, 0x01, 0x36, 0x02, 0x0c, 0x20, 0x00,\n  0x20, 0x01, 0x6a, 0x21, 0x08, 0x20, 0x00, 0x41, 0x01, 0x4e, 0x04, 0x40,\n  0x20, 0x01, 0x21, 0x07, 0x03, 0x40, 0x20, 0x07, 0x2d, 0x00, 0x00, 0x22,\n  0x09, 0x41, 0x2c, 0x47, 0x04, 0x40, 0x20, 0x07, 0x20, 0x02, 0x20, 0x09,\n  0x73, 0x3a, 0x00, 0x00, 0x0b, 0x20, 0x06, 0x20, 0x04, 0x20, 0x07, 0x6a,\n  0x22, 0x07, 0x36, 0x02, 0x0c, 0x20, 0x07, 0x20, 0x08, 0x49, 0x0d, 0x00,\n  0x0b, 0x0b, 0x20, 0x06, 0x20, 0x01, 0x36, 0x02, 0x0c, 0x20, 0x01, 0x2d,\n  0x00, 0x00, 0x04, 0x40, 0x03, 0x40, 0x20, 0x06, 0x41, 0x30, 0x6a, 0x20,\n  0x06, 0x41, 0x0c, 0x6a, 0x20, 0x06, 0x41, 0x10, 0x6a, 0x10, 0x08, 0x41,\n  0x02, 0x74, 0x6a, 0x22, 0x02, 0x20, 0x02, 0x28, 0x02, 0x00, 0x41, 0x01,\n  0x6a, 0x36, 0x02, 0x00, 0x20, 0x06, 0x28, 0x02, 0x0c, 0x2d, 0x00, 0x00,\n  0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x06, 0x20, 0x01, 0x36, 0x02, 0x0c, 0x20,\n  0x00, 0x41, 0x01, 0x4e, 0x04, 0x40, 0x03, 0x40, 0x20, 0x01, 0x2d, 0x00,\n  0x00, 0x22, 0x00, 0x41, 0x2c, 0x47, 0x04, 0x40, 0x20, 0x01, 0x20, 0x00,\n  0x20, 0x03, 0x73, 0x3a, 0x00, 0x00, 0x0b, 0x20, 0x06, 0x20, 0x01, 0x20,\n  0x04, 0x6a, 0x22, 0x01, 0x36, 0x02, 0x0c, 0x20, 0x01, 0x20, 0x08, 0x49,\n  0x0d, 0x00, 0x0b, 0x0b, 0x20, 0x06, 0x28, 0x02, 0x30, 0x20, 0x05, 0x10,\n  0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x10, 0x20, 0x00, 0x10, 0x0b,\n  0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x34, 0x20, 0x00, 0x10, 0x0b, 0x21,\n  0x00, 0x20, 0x06, 0x28, 0x02, 0x14, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00,\n  0x20, 0x06, 0x28, 0x02, 0x38, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20,\n  0x06, 0x28, 0x02, 0x18, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06,\n  0x28, 0x02, 0x3c, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28,\n  0x02, 0x1c, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02,\n  0x40, 0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x20,\n  0x20, 0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x44, 0x20,\n  0x00, 0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x24, 0x20, 0x00,\n  0x10, 0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x48, 0x20, 0x00, 0x10,\n  0x0b, 0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x28, 0x20, 0x00, 0x10, 0x0b,\n  0x21, 0x00, 0x20, 0x06, 0x28, 0x02, 0x4c, 0x20, 0x00, 0x10, 0x0b, 0x21,\n  0x00, 0x20, 0x06, 0x28, 0x02, 0x2c, 0x20, 0x00, 0x10, 0x0b, 0x20, 0x06,\n  0x41, 0xd0, 0x00, 0x6a, 0x24, 0x00, 0x0b, 0x8c, 0x04, 0x01, 0x08, 0x7f,\n  0x20, 0x00, 0x28, 0x02, 0x00, 0x22, 0x04, 0x2d, 0x00, 0x00, 0x22, 0x03,\n  0x45, 0x04, 0x40, 0x20, 0x00, 0x20, 0x04, 0x36, 0x02, 0x00, 0x41, 0x00,\n  0x0f, 0x0b, 0x20, 0x04, 0x41, 0x01, 0x6a, 0x21, 0x05, 0x20, 0x01, 0x41,\n  0x10, 0x6a, 0x21, 0x06, 0x20, 0x01, 0x41, 0x14, 0x6a, 0x21, 0x07, 0x20,\n  0x01, 0x41, 0x0c, 0x6a, 0x21, 0x04, 0x20, 0x01, 0x41, 0x04, 0x6a, 0x21,\n  0x08, 0x02, 0x40, 0x03, 0x40, 0x20, 0x03, 0x41, 0x2c, 0x46, 0x0d, 0x01,\n  0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40,\n  0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x20, 0x02, 0x0e, 0x08,\n  0x00, 0x09, 0x01, 0x04, 0x02, 0x03, 0x05, 0x06, 0x09, 0x0b, 0x41, 0x04,\n  0x21, 0x02, 0x02, 0x40, 0x20, 0x03, 0x41, 0x50, 0x6a, 0x41, 0xff, 0x01,\n  0x71, 0x41, 0x0a, 0x49, 0x0d, 0x00, 0x41, 0x02, 0x21, 0x02, 0x02, 0x40,\n  0x02, 0x40, 0x20, 0x03, 0x41, 0x55, 0x6a, 0x0e, 0x04, 0x02, 0x01, 0x02,\n  0x00, 0x01, 0x0b, 0x41, 0x05, 0x21, 0x02, 0x0c, 0x01, 0x0b, 0x41, 0x01,\n  0x21, 0x02, 0x20, 0x08, 0x20, 0x08, 0x28, 0x02, 0x00, 0x41, 0x01, 0x6a,\n  0x36, 0x02, 0x00, 0x0b, 0x20, 0x01, 0x20, 0x01, 0x28, 0x02, 0x00, 0x41,\n  0x01, 0x6a, 0x36, 0x02, 0x00, 0x0c, 0x08, 0x0b, 0x20, 0x03, 0x41, 0x50,\n  0x6a, 0x41, 0xff, 0x01, 0x71, 0x41, 0x09, 0x4b, 0x0d, 0x06, 0x20, 0x01,\n  0x20, 0x01, 0x28, 0x02, 0x08, 0x41, 0x01, 0x6a, 0x36, 0x02, 0x08, 0x41,\n  0x04, 0x21, 0x02, 0x0c, 0x07, 0x0b, 0x20, 0x03, 0x41, 0x2e, 0x46, 0x04,\n  0x40, 0x20, 0x06, 0x20, 0x06, 0x28, 0x02, 0x00, 0x41, 0x01, 0x6a, 0x36,\n  0x02, 0x00, 0x41, 0x05, 0x21, 0x02, 0x0c, 0x07, 0x0b, 0x41, 0x04, 0x21,\n  0x02, 0x20, 0x03, 0x41, 0x50, 0x6a, 0x41, 0xff, 0x01, 0x71, 0x41, 0x09,\n  0x4d, 0x0d, 0x06, 0x20, 0x06, 0x21, 0x04, 0x0c, 0x04, 0x0b, 0x20, 0x03,\n  0x41, 0x20, 0x72, 0x41, 0xe5, 0x00, 0x46, 0x04, 0x40, 0x20, 0x07, 0x20,\n  0x07, 0x28, 0x02, 0x00, 0x41, 0x01, 0x6a, 0x36, 0x02, 0x00, 0x41, 0x03,\n  0x21, 0x02, 0x0c, 0x06, 0x0b, 0x41, 0x05, 0x21, 0x02, 0x20, 0x03, 0x41,\n  0x50, 0x6a, 0x41, 0xff, 0x01, 0x71, 0x41, 0x09, 0x4d, 0x0d, 0x05, 0x20,\n  0x07, 0x21, 0x04, 0x0c, 0x03, 0x0b, 0x02, 0x40, 0x20, 0x03, 0x41, 0x55,\n  0x6a, 0x0e, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0b, 0x20, 0x04, 0x20, 0x04,\n  0x28, 0x02, 0x00, 0x41, 0x01, 0x6a, 0x36, 0x02, 0x00, 0x41, 0x06, 0x21,\n  0x02, 0x0c, 0x04, 0x0b, 0x20, 0x01, 0x20, 0x01, 0x28, 0x02, 0x18, 0x41,\n  0x01, 0x6a, 0x36, 0x02, 0x18, 0x41, 0x01, 0x41, 0x07, 0x20, 0x03, 0x41,\n  0x50, 0x6a, 0x41, 0xff, 0x01, 0x71, 0x41, 0x09, 0x4b, 0x1b, 0x21, 0x02,\n  0x0c, 0x03, 0x0b, 0x41, 0x07, 0x21, 0x02, 0x20, 0x03, 0x41, 0x50, 0x6a,\n  0x41, 0xff, 0x01, 0x71, 0x41, 0x0a, 0x49, 0x0d, 0x02, 0x20, 0x08, 0x21,\n  0x04, 0x0b, 0x20, 0x04, 0x20, 0x04, 0x28, 0x02, 0x00, 0x41, 0x01, 0x6a,\n  0x36, 0x02, 0x00, 0x20, 0x00, 0x20, 0x05, 0x36, 0x02, 0x00, 0x41, 0x01,\n  0x0f, 0x0b, 0x20, 0x01, 0x20, 0x01, 0x28, 0x02, 0x08, 0x41, 0x01, 0x6a,\n  0x36, 0x02, 0x08, 0x41, 0x05, 0x41, 0x01, 0x20, 0x03, 0x41, 0x2e, 0x46,\n  0x1b, 0x21, 0x02, 0x0b, 0x20, 0x05, 0x41, 0x01, 0x6a, 0x21, 0x09, 0x20,\n  0x02, 0x41, 0x01, 0x47, 0x04, 0x40, 0x20, 0x05, 0x2d, 0x00, 0x00, 0x21,\n  0x03, 0x20, 0x09, 0x21, 0x05, 0x20, 0x03, 0x0d, 0x01, 0x0b, 0x0b, 0x20,\n  0x09, 0x41, 0x7f, 0x6a, 0x21, 0x05, 0x0b, 0x20, 0x00, 0x20, 0x05, 0x36,\n  0x02, 0x00, 0x20, 0x02, 0x0b, 0xad, 0x01, 0x01, 0x06, 0x7f, 0x20, 0x00,\n  0x41, 0x7f, 0x6a, 0x22, 0x08, 0x41, 0x02, 0x4f, 0x04, 0x40, 0x03, 0x40,\n  0x20, 0x04, 0x04, 0x40, 0x20, 0x02, 0x20, 0x03, 0x6a, 0x21, 0x06, 0x20,\n  0x04, 0x21, 0x07, 0x03, 0x40, 0x20, 0x06, 0x20, 0x05, 0x2d, 0x00, 0x00,\n  0x3a, 0x00, 0x00, 0x20, 0x05, 0x41, 0x01, 0x6a, 0x21, 0x05, 0x20, 0x06,\n  0x41, 0x01, 0x6a, 0x21, 0x06, 0x20, 0x07, 0x41, 0x7f, 0x6a, 0x22, 0x07,\n  0x0d, 0x00, 0x0b, 0x20, 0x02, 0x20, 0x03, 0x6a, 0x20, 0x04, 0x6a, 0x41,\n  0x2c, 0x3a, 0x00, 0x00, 0x20, 0x03, 0x20, 0x04, 0x6a, 0x41, 0x01, 0x6a,\n  0x21, 0x03, 0x0b, 0x20, 0x01, 0x41, 0x01, 0x6a, 0x22, 0x01, 0x41, 0x07,\n  0x71, 0x41, 0x02, 0x74, 0x22, 0x04, 0x41, 0xe0, 0x05, 0x6a, 0x28, 0x02,\n  0x00, 0x20, 0x01, 0x41, 0x01, 0x76, 0x41, 0x0c, 0x71, 0x6a, 0x28, 0x02,\n  0x00, 0x21, 0x05, 0x20, 0x03, 0x20, 0x04, 0x41, 0x80, 0x06, 0x6a, 0x28,\n  0x02, 0x00, 0x22, 0x04, 0x6a, 0x41, 0x01, 0x6a, 0x20, 0x08, 0x49, 0x0d,\n  0x00, 0x0b, 0x0b, 0x20, 0x03, 0x20, 0x00, 0x49, 0x04, 0x40, 0x20, 0x02,\n  0x20, 0x03, 0x6a, 0x20, 0x00, 0x20, 0x03, 0x6b, 0x10, 0x0d, 0x0b, 0x0b,\n  0xf2, 0x03, 0x01, 0x02, 0x7f, 0x20, 0x01, 0x41, 0x01, 0x76, 0x22, 0x02,\n  0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20, 0x00, 0x20, 0x01, 0x73,\n  0x41, 0x01, 0x71, 0x1b, 0x22, 0x01, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff,\n  0x01, 0x71, 0x22, 0x02, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20,\n  0x01, 0x20, 0x00, 0x41, 0xff, 0x01, 0x71, 0x22, 0x01, 0x41, 0x01, 0x76,\n  0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x02, 0x41, 0x01, 0x76, 0x41, 0xff,\n  0xff, 0x01, 0x71, 0x22, 0x03, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x03,\n  0x20, 0x01, 0x41, 0x02, 0x76, 0x20, 0x02, 0x73, 0x41, 0x01, 0x71, 0x1b,\n  0x22, 0x02, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x03,\n  0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x03, 0x20, 0x01, 0x41, 0x03, 0x76,\n  0x20, 0x02, 0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x02, 0x41, 0x01, 0x76,\n  0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x03, 0x41, 0x81, 0xc0, 0x7e, 0x73,\n  0x20, 0x03, 0x20, 0x01, 0x41, 0x04, 0x76, 0x20, 0x02, 0x73, 0x41, 0x01,\n  0x71, 0x1b, 0x22, 0x02, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71,\n  0x22, 0x03, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x03, 0x20, 0x01, 0x41,\n  0x05, 0x76, 0x20, 0x02, 0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x02, 0x41,\n  0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x03, 0x41, 0x81, 0xc0,\n  0x7e, 0x73, 0x20, 0x03, 0x20, 0x01, 0x41, 0x06, 0x76, 0x20, 0x02, 0x73,\n  0x41, 0x01, 0x71, 0x1b, 0x22, 0x02, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff,\n  0x01, 0x71, 0x22, 0x03, 0x20, 0x03, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20,\n  0x02, 0x41, 0x01, 0x71, 0x20, 0x01, 0x41, 0x07, 0x76, 0x46, 0x1b, 0x22,\n  0x01, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x02, 0x41,\n  0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20, 0x01, 0x20, 0x00, 0x41, 0x08,\n  0x76, 0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x01, 0x41, 0x01, 0x76, 0x41,\n  0xff, 0xff, 0x01, 0x71, 0x22, 0x02, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20,\n  0x02, 0x20, 0x01, 0x20, 0x00, 0x41, 0x09, 0x76, 0x73, 0x41, 0x01, 0x71,\n  0x1b, 0x22, 0x01, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22,\n  0x02, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20, 0x01, 0x20, 0x00,\n  0x41, 0x0a, 0x76, 0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x01, 0x41, 0x01,\n  0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x02, 0x41, 0x81, 0xc0, 0x7e,\n  0x73, 0x20, 0x02, 0x20, 0x01, 0x20, 0x00, 0x41, 0x0b, 0x76, 0x73, 0x41,\n  0x01, 0x71, 0x1b, 0x22, 0x01, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01,\n  0x71, 0x22, 0x02, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20, 0x01,\n  0x20, 0x00, 0x41, 0x0c, 0x76, 0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x01,\n  0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x02, 0x41, 0x81,\n  0xc0, 0x7e, 0x73, 0x20, 0x02, 0x20, 0x01, 0x20, 0x00, 0x41, 0x0d, 0x76,\n  0x73, 0x41, 0x01, 0x71, 0x1b, 0x22, 0x01, 0x41, 0x01, 0x76, 0x41, 0xff,\n  0xff, 0x01, 0x71, 0x22, 0x02, 0x41, 0x81, 0xc0, 0x7e, 0x73, 0x20, 0x02,\n  0x20, 0x01, 0x20, 0x00, 0x41, 0x0e, 0x76, 0x73, 0x41, 0x01, 0x71, 0x1b,\n  0x22, 0x01, 0x41, 0x01, 0x76, 0x41, 0xff, 0xff, 0x01, 0x71, 0x22, 0x02,\n  0x20, 0x02, 0x41, 0x81, 0xc0, 0x02, 0x73, 0x20, 0x01, 0x41, 0x01, 0x71,\n  0x20, 0x00, 0x41, 0x0f, 0x76, 0x46, 0x1b, 0x0b, 0x14, 0x00, 0x20, 0x00,\n  0x41, 0x10, 0x76, 0x20, 0x00, 0x41, 0xff, 0xff, 0x03, 0x71, 0x20, 0x01,\n  0x10, 0x0a, 0x10, 0x0a, 0x0b, 0x0d, 0x00, 0x20, 0x00, 0x41, 0xff, 0xff,\n  0x03, 0x71, 0x20, 0x01, 0x10, 0x0a, 0x0b, 0xae, 0x01, 0x01, 0x02, 0x7f,\n  0x02, 0x40, 0x20, 0x01, 0x45, 0x0d, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a,\n  0x22, 0x02, 0x41, 0x7f, 0x6a, 0x41, 0x00, 0x3a, 0x00, 0x00, 0x20, 0x00,\n  0x41, 0x00, 0x3a, 0x00, 0x00, 0x20, 0x01, 0x41, 0x03, 0x49, 0x0d, 0x00,\n  0x20, 0x02, 0x41, 0x7e, 0x6a, 0x41, 0x00, 0x3a, 0x00, 0x00, 0x20, 0x00,\n  0x41, 0x00, 0x3a, 0x00, 0x01, 0x20, 0x02, 0x41, 0x7d, 0x6a, 0x41, 0x00,\n  0x3a, 0x00, 0x00, 0x20, 0x00, 0x41, 0x00, 0x3a, 0x00, 0x02, 0x20, 0x01,\n  0x41, 0x07, 0x49, 0x0d, 0x00, 0x20, 0x02, 0x41, 0x7c, 0x6a, 0x41, 0x00,\n  0x3a, 0x00, 0x00, 0x20, 0x00, 0x41, 0x00, 0x3a, 0x00, 0x03, 0x20, 0x01,\n  0x41, 0x09, 0x49, 0x0d, 0x00, 0x20, 0x01, 0x41, 0x00, 0x20, 0x00, 0x6b,\n  0x41, 0x03, 0x71, 0x22, 0x01, 0x6b, 0x41, 0x02, 0x76, 0x22, 0x02, 0x45,\n  0x0d, 0x00, 0x41, 0x00, 0x20, 0x02, 0x6b, 0x21, 0x02, 0x20, 0x00, 0x20,\n  0x01, 0x6a, 0x21, 0x01, 0x03, 0x40, 0x20, 0x01, 0x41, 0x00, 0x36, 0x02,\n  0x00, 0x20, 0x01, 0x41, 0x04, 0x6a, 0x21, 0x01, 0x20, 0x02, 0x41, 0x01,\n  0x6a, 0x22, 0x00, 0x20, 0x02, 0x4f, 0x20, 0x00, 0x21, 0x02, 0x0d, 0x00,\n  0x0b, 0x0b, 0x0b, 0x0a, 0x00, 0x41, 0xa0, 0x16, 0x10, 0x00, 0x36, 0x02,\n  0x00, 0x0b, 0x0a, 0x00, 0x41, 0xa4, 0x16, 0x10, 0x00, 0x36, 0x02, 0x00,\n  0x0b, 0x0b, 0xc5, 0x02, 0x02, 0x00, 0x41, 0x80, 0x04, 0x0b, 0xb2, 0x02,\n  0xb0, 0xd4, 0x40, 0x33, 0x79, 0x6a, 0x14, 0xe7, 0xc1, 0xe3, 0x52, 0xbe,\n  0x99, 0x11, 0x08, 0x56, 0xd7, 0x1f, 0x47, 0x07, 0x47, 0x5e, 0xbf, 0x39,\n  0xa4, 0xe5, 0x3a, 0x8e, 0x84, 0x8d, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00,\n  0x65, 0x02, 0x00, 0x00, 0x6a, 0x02, 0x00, 0x00, 0x6f, 0x02, 0x00, 0x00,\n  0x74, 0x02, 0x00, 0x00, 0x7d, 0x02, 0x00, 0x00, 0x86, 0x02, 0x00, 0x00,\n  0x8f, 0x02, 0x00, 0x00, 0x98, 0x02, 0x00, 0x00, 0xa1, 0x02, 0x00, 0x00,\n  0xaa, 0x02, 0x00, 0x00, 0xb3, 0x02, 0x00, 0x00, 0xbc, 0x02, 0x00, 0x00,\n  0xc5, 0x02, 0x00, 0x00, 0xce, 0x02, 0x00, 0x00, 0xd7, 0x02, 0x00, 0x00,\n  0x35, 0x30, 0x31, 0x32, 0x00, 0x31, 0x32, 0x33, 0x34, 0x00, 0x2d, 0x38,\n  0x37, 0x34, 0x00, 0x2b, 0x31, 0x32, 0x32, 0x00, 0x33, 0x35, 0x2e, 0x35,\n  0x34, 0x34, 0x30, 0x30, 0x00, 0x2e, 0x31, 0x32, 0x33, 0x34, 0x35, 0x30,\n  0x30, 0x00, 0x2d, 0x31, 0x31, 0x30, 0x2e, 0x37, 0x30, 0x30, 0x00, 0x2b,\n  0x30, 0x2e, 0x36, 0x34, 0x34, 0x30, 0x30, 0x00, 0x35, 0x2e, 0x35, 0x30,\n  0x30, 0x65, 0x2b, 0x33, 0x00, 0x2d, 0x2e, 0x31, 0x32, 0x33, 0x65, 0x2d,\n  0x32, 0x00, 0x2d, 0x38, 0x37, 0x65, 0x2b, 0x38, 0x33, 0x32, 0x00, 0x2b,\n  0x30, 0x2e, 0x36, 0x65, 0x2d, 0x31, 0x32, 0x00, 0x54, 0x30, 0x2e, 0x33,\n  0x65, 0x2d, 0x31, 0x46, 0x00, 0x2d, 0x54, 0x2e, 0x54, 0x2b, 0x2b, 0x54,\n  0x71, 0x00, 0x31, 0x54, 0x33, 0x2e, 0x34, 0x65, 0x34, 0x7a, 0x00, 0x33,\n  0x34, 0x2e, 0x30, 0x65, 0x2d, 0x54, 0x5e, 0x00, 0x20, 0x02, 0x00, 0x00,\n  0x20, 0x02, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,\n  0x30, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00,\n  0x50, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n  0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,\n  0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,\n  0x10, 0x0b, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00,\n  0x18, 0x0b, 0x00, 0x00, 0x1c, 0x0b, 0x00, 0x41, 0xb4, 0x06, 0x0b, 0x05,\n  0x66, 0x00, 0x00, 0x00, 0x01\n};\nunsigned int coremark_minimal_wasm_len = 7769;\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib32_tail.wasm.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib32_tail.wasm.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "unsigned char fib32_tail_wasm[] = {\n  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0d, 0x02, 0x60,\n  0x03, 0x7f, 0x7f, 0x7f, 0x01, 0x7f, 0x60, 0x01, 0x7f, 0x01, 0x7f, 0x03,\n  0x03, 0x02, 0x00, 0x01, 0x07, 0x07, 0x01, 0x03, 0x66, 0x69, 0x62, 0x00,\n  0x01, 0x0a, 0x26, 0x02, 0x19, 0x00, 0x20, 0x00, 0x45, 0x04, 0x7f, 0x20,\n  0x01, 0x05, 0x20, 0x00, 0x41, 0x01, 0x6b, 0x20, 0x02, 0x20, 0x01, 0x20,\n  0x02, 0x6a, 0x12, 0x00, 0x0b, 0x0b, 0x0a, 0x00, 0x20, 0x00, 0x41, 0x00,\n  0x41, 0x01, 0x12, 0x00, 0x0b\n};\nunsigned int fib32_tail_wasm_len = 77;\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib32.wasm.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/fib32.wasm.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "unsigned char fib32_wasm[] = {\n  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0x60,\n  0x01, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03,\n  0x66, 0x69, 0x62, 0x00, 0x00, 0x0a, 0x1f, 0x01, 0x1d, 0x00, 0x20, 0x00,\n  0x41, 0x02, 0x49, 0x04, 0x40, 0x20, 0x00, 0x0f, 0x0b, 0x20, 0x00, 0x41,\n  0x02, 0x6b, 0x10, 0x00, 0x20, 0x00, 0x41, 0x01, 0x6b, 0x10, 0x00, 0x6a,\n  0x0f, 0x0b\n};\nunsigned int fib32_wasm_len = 62;\n", "is_header": true, "available_types": []}, "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/wasi_core.h": {"path": "../../hello-idf/components/wasm3-helloesp/platforms/embedded/esp32-idf-wasi/wasm3/wasm3/extra/wasi_core.h", "includes": [], "included_by": [], "definitions": [], "usages": [], "raw_content": "/**\n * THIS FILE IS AUTO-GENERATED from the following files:\n *   typenames.witx, wasi_snapshot_preview1.witx\n *\n * @file\n * This file describes the [WASI] interface, consisting of functions, types,\n * and defined values (macros).\n *\n * The interface described here is greatly inspired by [CloudABI]'s clean,\n * thoughtfully-designed, capability-oriented, POSIX-style API.\n *\n * [CloudABI]: https://github.com/NuxiNL/cloudlibc\n * [WASI]: https://github.com/WebAssembly/WASI/\n */\n\n/*\n * File origin:\n *   https://github.com/CraneStation/wasi-libc/blob/master/libc-bottom-half/headers/public/wasi/api.h\n * Revision:\n *   2c2fc9a2fddd0927a66f1c142e65c8dab6f5c5d7\n * License:\n *   CC0 1.0 Universal (CC0 1.0) Public Domain Dedication\n *   https://creativecommons.org/publicdomain/zero/1.0/\n */\n\n#ifndef __wasi_api_h\n#define __wasi_api_h\n\n#include <stddef.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\n// Hacks alert\n#undef _Static_assert\n#define _Static_assert(...)\n#undef _Noreturn\n#define _Noreturn\n#endif\n\n_Static_assert(_Alignof(int8_t) == 1, \"non-wasi data layout\");\n_Static_assert(_Alignof(uint8_t) == 1, \"non-wasi data layout\");\n_Static_assert(_Alignof(int16_t) == 2, \"non-wasi data layout\");\n_Static_assert(_Alignof(uint16_t) == 2, \"non-wasi data layout\");\n_Static_assert(_Alignof(int32_t) == 4, \"non-wasi data layout\");\n_Static_assert(_Alignof(uint32_t) == 4, \"non-wasi data layout\");\n_Static_assert(_Alignof(int64_t) == 8, \"non-wasi data layout\");\n_Static_assert(_Alignof(uint64_t) == 8, \"non-wasi data layout\");\n// _Static_assert(_Alignof(void*) == 4, \"non-wasi data layout\");\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// TODO: Encoding this in witx.\n#define __WASI_DIRCOOKIE_START (UINT64_C(0))\n// typedef __SIZE_TYPE__ __wasi_size_t;\ntypedef uint32_t __wasi_size_t; // fixme for wasm64\n\n// _Static_assert(sizeof(__wasi_size_t) == 4, \"witx calculated size\");\n// _Static_assert(_Alignof(__wasi_size_t) == 4, \"witx calculated align\");\n\n/**\n * Non-negative file size or length of a region within a file.\n */\ntypedef uint64_t __wasi_filesize_t;\n\n_Static_assert(sizeof(__wasi_filesize_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_filesize_t) == 8, \"witx calculated align\");\n\n/**\n * Timestamp in nanoseconds.\n */\ntypedef uint64_t __wasi_timestamp_t;\n\n_Static_assert(sizeof(__wasi_timestamp_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_timestamp_t) == 8, \"witx calculated align\");\n\n/**\n * Identifiers for clocks.\n */\ntypedef uint32_t __wasi_clockid_t;\n\n/**\n * The clock measuring real time. Time value zero corresponds with\n * 1970-01-01T00:00:00Z.\n */\n#define __WASI_CLOCKID_REALTIME (UINT32_C(0))\n\n/**\n * The store-wide monotonic clock, which is defined as a clock measuring\n * real time, whose value cannot be adjusted and which cannot have negative\n * clock jumps. The epoch of this clock is undefined. The absolute time\n * value of this clock therefore has no meaning.\n */\n#define __WASI_CLOCKID_MONOTONIC (UINT32_C(1))\n\n/**\n * The CPU-time clock associated with the current process.\n */\n#define __WASI_CLOCKID_PROCESS_CPUTIME_ID (UINT32_C(2))\n\n/**\n * The CPU-time clock associated with the current thread.\n */\n#define __WASI_CLOCKID_THREAD_CPUTIME_ID (UINT32_C(3))\n\n_Static_assert(sizeof(__wasi_clockid_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_clockid_t) == 4, \"witx calculated align\");\n\n/**\n * Error codes returned by functions.\n * Not all of these error codes are returned by the functions provided by this\n * API; some are used in higher-level library layers, and others are provided\n * merely for alignment with POSIX.\n */\ntypedef uint16_t __wasi_errno_t;\n\n/**\n * No error occurred. System call completed successfully.\n */\n#define __WASI_ERRNO_SUCCESS (UINT16_C(0))\n\n/**\n * Argument list too long.\n */\n#define __WASI_ERRNO_2BIG (UINT16_C(1))\n\n/**\n * Permission denied.\n */\n#define __WASI_ERRNO_ACCES (UINT16_C(2))\n\n/**\n * Address in use.\n */\n#define __WASI_ERRNO_ADDRINUSE (UINT16_C(3))\n\n/**\n * Address not available.\n */\n#define __WASI_ERRNO_ADDRNOTAVAIL (UINT16_C(4))\n\n/**\n * Address family not supported.\n */\n#define __WASI_ERRNO_AFNOSUPPORT (UINT16_C(5))\n\n/**\n * Resource unavailable, or operation would block.\n */\n#define __WASI_ERRNO_AGAIN (UINT16_C(6))\n\n/**\n * Connection already in progress.\n */\n#define __WASI_ERRNO_ALREADY (UINT16_C(7))\n\n/**\n * Bad file descriptor.\n */\n#define __WASI_ERRNO_BADF (UINT16_C(8))\n\n/**\n * Bad message.\n */\n#define __WASI_ERRNO_BADMSG (UINT16_C(9))\n\n/**\n * Device or resource busy.\n */\n#define __WASI_ERRNO_BUSY (UINT16_C(10))\n\n/**\n * Operation canceled.\n */\n#define __WASI_ERRNO_CANCELED (UINT16_C(11))\n\n/**\n * No child processes.\n */\n#define __WASI_ERRNO_CHILD (UINT16_C(12))\n\n/**\n * Connection aborted.\n */\n#define __WASI_ERRNO_CONNABORTED (UINT16_C(13))\n\n/**\n * Connection refused.\n */\n#define __WASI_ERRNO_CONNREFUSED (UINT16_C(14))\n\n/**\n * Connection reset.\n */\n#define __WASI_ERRNO_CONNRESET (UINT16_C(15))\n\n/**\n * Resource deadlock would occur.\n */\n#define __WASI_ERRNO_DEADLK (UINT16_C(16))\n\n/**\n * Destination address required.\n */\n#define __WASI_ERRNO_DESTADDRREQ (UINT16_C(17))\n\n/**\n * Mathematics argument out of domain of function.\n */\n#define __WASI_ERRNO_DOM (UINT16_C(18))\n\n/**\n * Reserved.\n */\n#define __WASI_ERRNO_DQUOT (UINT16_C(19))\n\n/**\n * File exists.\n */\n#define __WASI_ERRNO_EXIST (UINT16_C(20))\n\n/**\n * Bad address.\n */\n#define __WASI_ERRNO_FAULT (UINT16_C(21))\n\n/**\n * File too large.\n */\n#define __WASI_ERRNO_FBIG (UINT16_C(22))\n\n/**\n * Host is unreachable.\n */\n#define __WASI_ERRNO_HOSTUNREACH (UINT16_C(23))\n\n/**\n * Identifier removed.\n */\n#define __WASI_ERRNO_IDRM (UINT16_C(24))\n\n/**\n * Illegal byte sequence.\n */\n#define __WASI_ERRNO_ILSEQ (UINT16_C(25))\n\n/**\n * Operation in progress.\n */\n#define __WASI_ERRNO_INPROGRESS (UINT16_C(26))\n\n/**\n * Interrupted function.\n */\n#define __WASI_ERRNO_INTR (UINT16_C(27))\n\n/**\n * Invalid argument.\n */\n#define __WASI_ERRNO_INVAL (UINT16_C(28))\n\n/**\n * I/O error.\n */\n#define __WASI_ERRNO_IO (UINT16_C(29))\n\n/**\n * Socket is connected.\n */\n#define __WASI_ERRNO_ISCONN (UINT16_C(30))\n\n/**\n * Is a directory.\n */\n#define __WASI_ERRNO_ISDIR (UINT16_C(31))\n\n/**\n * Too many levels of symbolic links.\n */\n#define __WASI_ERRNO_LOOP (UINT16_C(32))\n\n/**\n * File descriptor value too large.\n */\n#define __WASI_ERRNO_MFILE (UINT16_C(33))\n\n/**\n * Too many links.\n */\n#define __WASI_ERRNO_MLINK (UINT16_C(34))\n\n/**\n * Message too large.\n */\n#define __WASI_ERRNO_MSGSIZE (UINT16_C(35))\n\n/**\n * Reserved.\n */\n#define __WASI_ERRNO_MULTIHOP (UINT16_C(36))\n\n/**\n * Filename too long.\n */\n#define __WASI_ERRNO_NAMETOOLONG (UINT16_C(37))\n\n/**\n * Network is down.\n */\n#define __WASI_ERRNO_NETDOWN (UINT16_C(38))\n\n/**\n * Connection aborted by network.\n */\n#define __WASI_ERRNO_NETRESET (UINT16_C(39))\n\n/**\n * Network unreachable.\n */\n#define __WASI_ERRNO_NETUNREACH (UINT16_C(40))\n\n/**\n * Too many files open in system.\n */\n#define __WASI_ERRNO_NFILE (UINT16_C(41))\n\n/**\n * No buffer space available.\n */\n#define __WASI_ERRNO_NOBUFS (UINT16_C(42))\n\n/**\n * No such device.\n */\n#define __WASI_ERRNO_NODEV (UINT16_C(43))\n\n/**\n * No such file or directory.\n */\n#define __WASI_ERRNO_NOENT (UINT16_C(44))\n\n/**\n * Executable file format error.\n */\n#define __WASI_ERRNO_NOEXEC (UINT16_C(45))\n\n/**\n * No locks available.\n */\n#define __WASI_ERRNO_NOLCK (UINT16_C(46))\n\n/**\n * Reserved.\n */\n#define __WASI_ERRNO_NOLINK (UINT16_C(47))\n\n/**\n * Not enough space.\n */\n#define __WASI_ERRNO_NOMEM (UINT16_C(48))\n\n/**\n * No message of the desired type.\n */\n#define __WASI_ERRNO_NOMSG (UINT16_C(49))\n\n/**\n * Protocol not available.\n */\n#define __WASI_ERRNO_NOPROTOOPT (UINT16_C(50))\n\n/**\n * No space left on device.\n */\n#define __WASI_ERRNO_NOSPC (UINT16_C(51))\n\n/**\n * Function not supported.\n */\n#define __WASI_ERRNO_NOSYS (UINT16_C(52))\n\n/**\n * The socket is not connected.\n */\n#define __WASI_ERRNO_NOTCONN (UINT16_C(53))\n\n/**\n * Not a directory or a symbolic link to a directory.\n */\n#define __WASI_ERRNO_NOTDIR (UINT16_C(54))\n\n/**\n * Directory not empty.\n */\n#define __WASI_ERRNO_NOTEMPTY (UINT16_C(55))\n\n/**\n * State not recoverable.\n */\n#define __WASI_ERRNO_NOTRECOVERABLE (UINT16_C(56))\n\n/**\n * Not a socket.\n */\n#define __WASI_ERRNO_NOTSOCK (UINT16_C(57))\n\n/**\n * Not supported, or operation not supported on socket.\n */\n#define __WASI_ERRNO_NOTSUP (UINT16_C(58))\n\n/**\n * Inappropriate I/O control operation.\n */\n#define __WASI_ERRNO_NOTTY (UINT16_C(59))\n\n/**\n * No such device or address.\n */\n#define __WASI_ERRNO_NXIO (UINT16_C(60))\n\n/**\n * Value too large to be stored in data type.\n */\n#define __WASI_ERRNO_OVERFLOW (UINT16_C(61))\n\n/**\n * Previous owner died.\n */\n#define __WASI_ERRNO_OWNERDEAD (UINT16_C(62))\n\n/**\n * Operation not permitted.\n */\n#define __WASI_ERRNO_PERM (UINT16_C(63))\n\n/**\n * Broken pipe.\n */\n#define __WASI_ERRNO_PIPE (UINT16_C(64))\n\n/**\n * Protocol error.\n */\n#define __WASI_ERRNO_PROTO (UINT16_C(65))\n\n/**\n * Protocol not supported.\n */\n#define __WASI_ERRNO_PROTONOSUPPORT (UINT16_C(66))\n\n/**\n * Protocol wrong type for socket.\n */\n#define __WASI_ERRNO_PROTOTYPE (UINT16_C(67))\n\n/**\n * Result too large.\n */\n#define __WASI_ERRNO_RANGE (UINT16_C(68))\n\n/**\n * Read-only file system.\n */\n#define __WASI_ERRNO_ROFS (UINT16_C(69))\n\n/**\n * Invalid seek.\n */\n#define __WASI_ERRNO_SPIPE (UINT16_C(70))\n\n/**\n * No such process.\n */\n#define __WASI_ERRNO_SRCH (UINT16_C(71))\n\n/**\n * Reserved.\n */\n#define __WASI_ERRNO_STALE (UINT16_C(72))\n\n/**\n * Connection timed out.\n */\n#define __WASI_ERRNO_TIMEDOUT (UINT16_C(73))\n\n/**\n * Text file busy.\n */\n#define __WASI_ERRNO_TXTBSY (UINT16_C(74))\n\n/**\n * Cross-device link.\n */\n#define __WASI_ERRNO_XDEV (UINT16_C(75))\n\n/**\n * Extension: Capabilities insufficient.\n */\n#define __WASI_ERRNO_NOTCAPABLE (UINT16_C(76))\n\n_Static_assert(sizeof(__wasi_errno_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_errno_t) == 2, \"witx calculated align\");\n\n/**\n * File descriptor rights, determining which actions may be performed.\n */\ntypedef uint64_t __wasi_rights_t;\n\n/**\n * The right to invoke `fd_datasync`.\n * If `path_open` is set, includes the right to invoke\n * `path_open` with `fdflags::dsync`.\n */\n#define __WASI_RIGHTS_FD_DATASYNC (UINT64_C(1))\n\n/**\n * The right to invoke `fd_read` and `sock_recv`.\n * If `rights::fd_seek` is set, includes the right to invoke `fd_pread`.\n */\n#define __WASI_RIGHTS_FD_READ (UINT64_C(2))\n\n/**\n * The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.\n */\n#define __WASI_RIGHTS_FD_SEEK (UINT64_C(4))\n\n/**\n * The right to invoke `fd_fdstat_set_flags`.\n */\n#define __WASI_RIGHTS_FD_FDSTAT_SET_FLAGS (UINT64_C(8))\n\n/**\n * The right to invoke `fd_sync`.\n * If `path_open` is set, includes the right to invoke\n * `path_open` with `fdflags::rsync` and `fdflags::dsync`.\n */\n#define __WASI_RIGHTS_FD_SYNC (UINT64_C(16))\n\n/**\n * The right to invoke `fd_seek` in such a way that the file offset\n * remains unaltered (i.e., `whence::cur` with offset zero), or to\n * invoke `fd_tell`.\n */\n#define __WASI_RIGHTS_FD_TELL (UINT64_C(32))\n\n/**\n * The right to invoke `fd_write` and `sock_send`.\n * If `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.\n */\n#define __WASI_RIGHTS_FD_WRITE (UINT64_C(64))\n\n/**\n * The right to invoke `fd_advise`.\n */\n#define __WASI_RIGHTS_FD_ADVISE (UINT64_C(128))\n\n/**\n * The right to invoke `fd_allocate`.\n */\n#define __WASI_RIGHTS_FD_ALLOCATE (UINT64_C(256))\n\n/**\n * The right to invoke `path_create_directory`.\n */\n#define __WASI_RIGHTS_PATH_CREATE_DIRECTORY (UINT64_C(512))\n\n/**\n * If `path_open` is set, the right to invoke `path_open` with `oflags::creat`.\n */\n#define __WASI_RIGHTS_PATH_CREATE_FILE (UINT64_C(1024))\n\n/**\n * The right to invoke `path_link` with the file descriptor as the\n * source directory.\n */\n#define __WASI_RIGHTS_PATH_LINK_SOURCE (UINT64_C(2048))\n\n/**\n * The right to invoke `path_link` with the file descriptor as the\n * target directory.\n */\n#define __WASI_RIGHTS_PATH_LINK_TARGET (UINT64_C(4096))\n\n/**\n * The right to invoke `path_open`.\n */\n#define __WASI_RIGHTS_PATH_OPEN (UINT64_C(8192))\n\n/**\n * The right to invoke `fd_readdir`.\n */\n#define __WASI_RIGHTS_FD_READDIR (UINT64_C(16384))\n\n/**\n * The right to invoke `path_readlink`.\n */\n#define __WASI_RIGHTS_PATH_READLINK (UINT64_C(32768))\n\n/**\n * The right to invoke `path_rename` with the file descriptor as the source directory.\n */\n#define __WASI_RIGHTS_PATH_RENAME_SOURCE (UINT64_C(65536))\n\n/**\n * The right to invoke `path_rename` with the file descriptor as the target directory.\n */\n#define __WASI_RIGHTS_PATH_RENAME_TARGET (UINT64_C(131072))\n\n/**\n * The right to invoke `path_filestat_get`.\n */\n#define __WASI_RIGHTS_PATH_FILESTAT_GET (UINT64_C(262144))\n\n/**\n * The right to change a file's size (there is no `path_filestat_set_size`).\n * If `path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.\n */\n#define __WASI_RIGHTS_PATH_FILESTAT_SET_SIZE (UINT64_C(524288))\n\n/**\n * The right to invoke `path_filestat_set_times`.\n */\n#define __WASI_RIGHTS_PATH_FILESTAT_SET_TIMES (UINT64_C(1048576))\n\n/**\n * The right to invoke `fd_filestat_get`.\n */\n#define __WASI_RIGHTS_FD_FILESTAT_GET (UINT64_C(2097152))\n\n/**\n * The right to invoke `fd_filestat_set_size`.\n */\n#define __WASI_RIGHTS_FD_FILESTAT_SET_SIZE (UINT64_C(4194304))\n\n/**\n * The right to invoke `fd_filestat_set_times`.\n */\n#define __WASI_RIGHTS_FD_FILESTAT_SET_TIMES (UINT64_C(8388608))\n\n/**\n * The right to invoke `path_symlink`.\n */\n#define __WASI_RIGHTS_PATH_SYMLINK (UINT64_C(16777216))\n\n/**\n * The right to invoke `path_remove_directory`.\n */\n#define __WASI_RIGHTS_PATH_REMOVE_DIRECTORY (UINT64_C(33554432))\n\n/**\n * The right to invoke `path_unlink_file`.\n */\n#define __WASI_RIGHTS_PATH_UNLINK_FILE (UINT64_C(67108864))\n\n/**\n * If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`.\n * If `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.\n */\n#define __WASI_RIGHTS_POLL_FD_READWRITE (UINT64_C(134217728))\n\n/**\n * The right to invoke `sock_shutdown`.\n */\n#define __WASI_RIGHTS_SOCK_SHUTDOWN (UINT64_C(268435456))\n\n_Static_assert(sizeof(__wasi_rights_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_rights_t) == 8, \"witx calculated align\");\n\n/**\n * A file descriptor index.\n */\ntypedef uint32_t __wasi_fd_t;\n\n_Static_assert(sizeof(__wasi_fd_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_fd_t) == 4, \"witx calculated align\");\n\n/**\n * A region of memory for scatter/gather reads.\n */\ntypedef struct __wasi_iovec_t {\n    /**\n     * The address of the buffer to be filled.\n     */\n    uint8_t * buf;\n\n    /**\n     * The length of the buffer to be filled.\n     */\n    __wasi_size_t buf_len;\n\n} __wasi_iovec_t;\n\n// _Static_assert(sizeof(__wasi_iovec_t) == 8, \"witx calculated size\");\n// _Static_assert(_Alignof(__wasi_iovec_t) == 4, \"witx calculated align\");\n// _Static_assert(offsetof(__wasi_iovec_t, buf) == 0, \"witx calculated offset\");\n// _Static_assert(offsetof(__wasi_iovec_t, buf_len) == 4, \"witx calculated offset\");\n\n/**\n * A region of memory for scatter/gather writes.\n */\ntypedef struct __wasi_ciovec_t {\n    /**\n     * The address of the buffer to be written.\n     */\n    const uint8_t * buf;\n\n    /**\n     * The length of the buffer to be written.\n     */\n    __wasi_size_t buf_len;\n\n} __wasi_ciovec_t;\n\n// _Static_assert(sizeof(__wasi_ciovec_t) == 8, \"witx calculated size\");\n// _Static_assert(_Alignof(__wasi_ciovec_t) == 4, \"witx calculated align\");\n// _Static_assert(offsetof(__wasi_ciovec_t, buf) == 0, \"witx calculated offset\");\n// _Static_assert(offsetof(__wasi_ciovec_t, buf_len) == 4, \"witx calculated offset\");\n\n/**\n * Relative offset within a file.\n */\ntypedef int64_t __wasi_filedelta_t;\n\n_Static_assert(sizeof(__wasi_filedelta_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_filedelta_t) == 8, \"witx calculated align\");\n\n/**\n * The position relative to which to set the offset of the file descriptor.\n */\ntypedef uint8_t __wasi_whence_t;\n\n/**\n * Seek relative to start-of-file.\n */\n#define __WASI_WHENCE_SET (UINT8_C(0))\n\n/**\n * Seek relative to current position.\n */\n#define __WASI_WHENCE_CUR (UINT8_C(1))\n\n/**\n * Seek relative to end-of-file.\n */\n#define __WASI_WHENCE_END (UINT8_C(2))\n\n_Static_assert(sizeof(__wasi_whence_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_whence_t) == 1, \"witx calculated align\");\n\n/**\n * A reference to the offset of a directory entry.\n *\n * The value 0 signifies the start of the directory.\n */\ntypedef uint64_t __wasi_dircookie_t;\n\n_Static_assert(sizeof(__wasi_dircookie_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_dircookie_t) == 8, \"witx calculated align\");\n\n/**\n * The type for the $d_namlen field of $dirent.\n */\ntypedef uint32_t __wasi_dirnamlen_t;\n\n_Static_assert(sizeof(__wasi_dirnamlen_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_dirnamlen_t) == 4, \"witx calculated align\");\n\n/**\n * File serial number that is unique within its file system.\n */\ntypedef uint64_t __wasi_inode_t;\n\n_Static_assert(sizeof(__wasi_inode_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_inode_t) == 8, \"witx calculated align\");\n\n/**\n * The type of a file descriptor or file.\n */\ntypedef uint8_t __wasi_filetype_t;\n\n/**\n * The type of the file descriptor or file is unknown or is different from any of the other types specified.\n */\n#define __WASI_FILETYPE_UNKNOWN (UINT8_C(0))\n\n/**\n * The file descriptor or file refers to a block device inode.\n */\n#define __WASI_FILETYPE_BLOCK_DEVICE (UINT8_C(1))\n\n/**\n * The file descriptor or file refers to a character device inode.\n */\n#define __WASI_FILETYPE_CHARACTER_DEVICE (UINT8_C(2))\n\n/**\n * The file descriptor or file refers to a directory inode.\n */\n#define __WASI_FILETYPE_DIRECTORY (UINT8_C(3))\n\n/**\n * The file descriptor or file refers to a regular file inode.\n */\n#define __WASI_FILETYPE_REGULAR_FILE (UINT8_C(4))\n\n/**\n * The file descriptor or file refers to a datagram socket.\n */\n#define __WASI_FILETYPE_SOCKET_DGRAM (UINT8_C(5))\n\n/**\n * The file descriptor or file refers to a byte-stream socket.\n */\n#define __WASI_FILETYPE_SOCKET_STREAM (UINT8_C(6))\n\n/**\n * The file refers to a symbolic link inode.\n */\n#define __WASI_FILETYPE_SYMBOLIC_LINK (UINT8_C(7))\n\n_Static_assert(sizeof(__wasi_filetype_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_filetype_t) == 1, \"witx calculated align\");\n\n/**\n * A directory entry.\n */\ntypedef struct __wasi_dirent_t {\n    /**\n     * The offset of the next directory entry stored in this directory.\n     */\n    __wasi_dircookie_t d_next;\n\n    /**\n     * The serial number of the file referred to by this directory entry.\n     */\n    __wasi_inode_t d_ino;\n\n    /**\n     * The length of the name of the directory entry.\n     */\n    __wasi_dirnamlen_t d_namlen;\n\n    /**\n     * The type of the file referred to by this directory entry.\n     */\n    __wasi_filetype_t d_type;\n\n} __wasi_dirent_t;\n\n_Static_assert(sizeof(__wasi_dirent_t) == 24, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_dirent_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_dirent_t, d_next) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_dirent_t, d_ino) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_dirent_t, d_namlen) == 16, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_dirent_t, d_type) == 20, \"witx calculated offset\");\n\n/**\n * File or memory access pattern advisory information.\n */\ntypedef uint8_t __wasi_advice_t;\n\n/**\n * The application has no advice to give on its behavior with respect to the specified data.\n */\n#define __WASI_ADVICE_NORMAL (UINT8_C(0))\n\n/**\n * The application expects to access the specified data sequentially from lower offsets to higher offsets.\n */\n#define __WASI_ADVICE_SEQUENTIAL (UINT8_C(1))\n\n/**\n * The application expects to access the specified data in a random order.\n */\n#define __WASI_ADVICE_RANDOM (UINT8_C(2))\n\n/**\n * The application expects to access the specified data in the near future.\n */\n#define __WASI_ADVICE_WILLNEED (UINT8_C(3))\n\n/**\n * The application expects that it will not access the specified data in the near future.\n */\n#define __WASI_ADVICE_DONTNEED (UINT8_C(4))\n\n/**\n * The application expects to access the specified data once and then not reuse it thereafter.\n */\n#define __WASI_ADVICE_NOREUSE (UINT8_C(5))\n\n_Static_assert(sizeof(__wasi_advice_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_advice_t) == 1, \"witx calculated align\");\n\n/**\n * File descriptor flags.\n */\ntypedef uint16_t __wasi_fdflags_t;\n\n/**\n * Append mode: Data written to the file is always appended to the file's end.\n */\n#define __WASI_FDFLAGS_APPEND (UINT16_C(1))\n\n/**\n * Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.\n */\n#define __WASI_FDFLAGS_DSYNC (UINT16_C(2))\n\n/**\n * Non-blocking mode.\n */\n#define __WASI_FDFLAGS_NONBLOCK (UINT16_C(4))\n\n/**\n * Synchronized read I/O operations.\n */\n#define __WASI_FDFLAGS_RSYNC (UINT16_C(8))\n\n/**\n * Write according to synchronized I/O file integrity completion. In\n * addition to synchronizing the data stored in the file, the implementation\n * may also synchronously update the file's metadata.\n */\n#define __WASI_FDFLAGS_SYNC (UINT16_C(16))\n\n_Static_assert(sizeof(__wasi_fdflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_fdflags_t) == 2, \"witx calculated align\");\n\n/**\n * File descriptor attributes.\n */\ntypedef struct __wasi_fdstat_t {\n    /**\n     * File type.\n     */\n    __wasi_filetype_t fs_filetype;\n\n    /**\n     * File descriptor flags.\n     */\n    __wasi_fdflags_t fs_flags;\n\n    /**\n     * Rights that apply to this file descriptor.\n     */\n    __wasi_rights_t fs_rights_base;\n\n    /**\n     * Maximum set of rights that may be installed on new file descriptors that\n     * are created through this file descriptor, e.g., through `path_open`.\n     */\n    __wasi_rights_t fs_rights_inheriting;\n\n} __wasi_fdstat_t;\n\n_Static_assert(sizeof(__wasi_fdstat_t) == 24, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_fdstat_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_fdstat_t, fs_filetype) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_fdstat_t, fs_flags) == 2, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_fdstat_t, fs_rights_base) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_fdstat_t, fs_rights_inheriting) == 16, \"witx calculated offset\");\n\n/**\n * Identifier for a device containing a file system. Can be used in combination\n * with `inode` to uniquely identify a file or directory in the filesystem.\n */\ntypedef uint64_t __wasi_device_t;\n\n_Static_assert(sizeof(__wasi_device_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_device_t) == 8, \"witx calculated align\");\n\n/**\n * Which file time attributes to adjust.\n */\ntypedef uint16_t __wasi_fstflags_t;\n\n/**\n * Adjust the last data access timestamp to the value stored in `filestat::atim`.\n */\n#define __WASI_FSTFLAGS_ATIM (UINT16_C(1))\n\n/**\n * Adjust the last data access timestamp to the time of clock `clockid::realtime`.\n */\n#define __WASI_FSTFLAGS_ATIM_NOW (UINT16_C(2))\n\n/**\n * Adjust the last data modification timestamp to the value stored in `filestat::mtim`.\n */\n#define __WASI_FSTFLAGS_MTIM (UINT16_C(4))\n\n/**\n * Adjust the last data modification timestamp to the time of clock `clockid::realtime`.\n */\n#define __WASI_FSTFLAGS_MTIM_NOW (UINT16_C(8))\n\n_Static_assert(sizeof(__wasi_fstflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_fstflags_t) == 2, \"witx calculated align\");\n\n/**\n * Flags determining the method of how paths are resolved.\n */\ntypedef uint32_t __wasi_lookupflags_t;\n\n/**\n * As long as the resolved path corresponds to a symbolic link, it is expanded.\n */\n#define __WASI_LOOKUPFLAGS_SYMLINK_FOLLOW (UINT32_C(1))\n\n_Static_assert(sizeof(__wasi_lookupflags_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_lookupflags_t) == 4, \"witx calculated align\");\n\n/**\n * Open flags used by `path_open`.\n */\ntypedef uint16_t __wasi_oflags_t;\n\n/**\n * Create file if it does not exist.\n */\n#define __WASI_OFLAGS_CREAT (UINT16_C(1))\n\n/**\n * Fail if not a directory.\n */\n#define __WASI_OFLAGS_DIRECTORY (UINT16_C(2))\n\n/**\n * Fail if file already exists.\n */\n#define __WASI_OFLAGS_EXCL (UINT16_C(4))\n\n/**\n * Truncate file to size 0.\n */\n#define __WASI_OFLAGS_TRUNC (UINT16_C(8))\n\n_Static_assert(sizeof(__wasi_oflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_oflags_t) == 2, \"witx calculated align\");\n\n/**\n * Number of hard links to an inode.\n */\ntypedef uint64_t __wasi_linkcount_t;\n\n_Static_assert(sizeof(__wasi_linkcount_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_linkcount_t) == 8, \"witx calculated align\");\n\n/**\n * File attributes.\n */\ntypedef struct __wasi_filestat_t {\n    /**\n     * Device ID of device containing the file.\n     */\n    __wasi_device_t dev;\n\n    /**\n     * File serial number.\n     */\n    __wasi_inode_t ino;\n\n    /**\n     * File type.\n     */\n    __wasi_filetype_t filetype;\n\n    /**\n     * Number of hard links to the file.\n     */\n    __wasi_linkcount_t nlink;\n\n    /**\n     * For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link.\n     */\n    __wasi_filesize_t size;\n\n    /**\n     * Last data access timestamp.\n     */\n    __wasi_timestamp_t atim;\n\n    /**\n     * Last data modification timestamp.\n     */\n    __wasi_timestamp_t mtim;\n\n    /**\n     * Last file status change timestamp.\n     */\n    __wasi_timestamp_t ctim;\n\n} __wasi_filestat_t;\n\n_Static_assert(sizeof(__wasi_filestat_t) == 64, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_filestat_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_filestat_t, dev) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, ino) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, filetype) == 16, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, nlink) == 24, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, size) == 32, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, atim) == 40, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, mtim) == 48, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_filestat_t, ctim) == 56, \"witx calculated offset\");\n\n/**\n * User-provided value that may be attached to objects that is retained when\n * extracted from the implementation.\n */\ntypedef uint64_t __wasi_userdata_t;\n\n_Static_assert(sizeof(__wasi_userdata_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_userdata_t) == 8, \"witx calculated align\");\n\n/**\n * Type of a subscription to an event or its occurrence.\n */\ntypedef uint8_t __wasi_eventtype_t;\n\n/**\n * The time value of clock `subscription_clock::id` has\n * reached timestamp `subscription_clock::timeout`.\n */\n#define __WASI_EVENTTYPE_CLOCK (UINT8_C(0))\n\n/**\n * File descriptor `subscription_fd_readwrite::file_descriptor` has data\n * available for reading. This event always triggers for regular files.\n */\n#define __WASI_EVENTTYPE_FD_READ (UINT8_C(1))\n\n/**\n * File descriptor `subscription_fd_readwrite::file_descriptor` has capacity\n * available for writing. This event always triggers for regular files.\n */\n#define __WASI_EVENTTYPE_FD_WRITE (UINT8_C(2))\n\n_Static_assert(sizeof(__wasi_eventtype_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_eventtype_t) == 1, \"witx calculated align\");\n\n/**\n * The state of the file descriptor subscribed to with\n * `eventtype::fd_read` or `eventtype::fd_write`.\n */\ntypedef uint16_t __wasi_eventrwflags_t;\n\n/**\n * The peer of this socket has closed or disconnected.\n */\n#define __WASI_EVENTRWFLAGS_FD_READWRITE_HANGUP (UINT16_C(1))\n\n_Static_assert(sizeof(__wasi_eventrwflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_eventrwflags_t) == 2, \"witx calculated align\");\n\n/**\n * The contents of an $event when type is `eventtype::fd_read` or\n * `eventtype::fd_write`.\n */\ntypedef struct __wasi_event_fd_readwrite_t {\n    /**\n     * The number of bytes available for reading or writing.\n     */\n    __wasi_filesize_t nbytes;\n\n    /**\n     * The state of the file descriptor.\n     */\n    __wasi_eventrwflags_t flags;\n\n} __wasi_event_fd_readwrite_t;\n\n_Static_assert(sizeof(__wasi_event_fd_readwrite_t) == 16, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_event_fd_readwrite_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_event_fd_readwrite_t, nbytes) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_event_fd_readwrite_t, flags) == 8, \"witx calculated offset\");\n\n/**\n * The contents of an $event.\n */\ntypedef union __wasi_event_u_t {\n    /**\n     * When type is `eventtype::fd_read` or `eventtype::fd_write`:\n     */\n    __wasi_event_fd_readwrite_t fd_readwrite;\n\n} __wasi_event_u_t;\n\n_Static_assert(sizeof(__wasi_event_u_t) == 16, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_event_u_t) == 8, \"witx calculated align\");\n\n/**\n * An event that occurred.\n */\ntypedef struct __wasi_event_t {\n    /**\n     * User-provided value that got attached to `subscription::userdata`.\n     */\n    __wasi_userdata_t userdata;\n\n    /**\n     * If non-zero, an error that occurred while processing the subscription request.\n     */\n    __wasi_errno_t error;\n\n    /**\n     * The type of the event that occurred.\n     */\n    __wasi_eventtype_t type;\n\n    /**\n     * The contents of the event.\n     */\n    __wasi_event_u_t u;\n\n} __wasi_event_t;\n\n_Static_assert(sizeof(__wasi_event_t) == 32, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_event_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_event_t, userdata) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_event_t, error) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_event_t, type) == 10, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_event_t, u) == 16, \"witx calculated offset\");\n\n/**\n * Flags determining how to interpret the timestamp provided in\n * `subscription_clock::timeout`.\n */\ntypedef uint16_t __wasi_subclockflags_t;\n\n/**\n * If set, treat the timestamp provided in\n * `subscription_clock::timeout` as an absolute timestamp of clock\n * `subscription_clock::id`. If clear, treat the timestamp\n * provided in `subscription_clock::timeout` relative to the\n * current time value of clock `subscription_clock::id`.\n */\n#define __WASI_SUBCLOCKFLAGS_SUBSCRIPTION_CLOCK_ABSTIME (UINT16_C(1))\n\n_Static_assert(sizeof(__wasi_subclockflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_subclockflags_t) == 2, \"witx calculated align\");\n\n/**\n * The contents of a $subscription when type is `eventtype::clock`.\n */\ntypedef struct __wasi_subscription_clock_t {\n    /**\n     * The clock against which to compare the timestamp.\n     */\n    __wasi_clockid_t id;\n\n    /**\n     * The absolute or relative timestamp.\n     */\n    __wasi_timestamp_t timeout;\n\n    /**\n     * The amount of time that the implementation may wait additionally\n     * to coalesce with other events.\n     */\n    __wasi_timestamp_t precision;\n\n    /**\n     * Flags specifying whether the timeout is absolute or relative\n     */\n    __wasi_subclockflags_t flags;\n\n} __wasi_subscription_clock_t;\n\n_Static_assert(sizeof(__wasi_subscription_clock_t) == 32, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_subscription_clock_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_subscription_clock_t, id) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_subscription_clock_t, timeout) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_subscription_clock_t, precision) == 16, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_subscription_clock_t, flags) == 24, \"witx calculated offset\");\n\n/**\n * The contents of a $subscription when type is type is\n * `eventtype::fd_read` or `eventtype::fd_write`.\n */\ntypedef struct __wasi_subscription_fd_readwrite_t {\n    /**\n     * The file descriptor on which to wait for it to become ready for reading or writing.\n     */\n    __wasi_fd_t file_descriptor;\n\n} __wasi_subscription_fd_readwrite_t;\n\n_Static_assert(sizeof(__wasi_subscription_fd_readwrite_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_subscription_fd_readwrite_t) == 4, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_subscription_fd_readwrite_t, file_descriptor) == 0, \"witx calculated offset\");\n\n/**\n * The contents of a $subscription.\n */\ntypedef union __wasi_subscription_u_t {\n    /**\n     * When type is `eventtype::clock`:\n     */\n    __wasi_subscription_clock_t clock;\n\n    /**\n     * When type is `eventtype::fd_read` or `eventtype::fd_write`:\n     */\n    __wasi_subscription_fd_readwrite_t fd_readwrite;\n\n} __wasi_subscription_u_t;\n\n_Static_assert(sizeof(__wasi_subscription_u_t) == 32, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_subscription_u_t) == 8, \"witx calculated align\");\n\n/**\n * Subscription to an event.\n */\ntypedef struct __wasi_subscription_t {\n    /**\n     * User-provided value that is attached to the subscription in the\n     * implementation and returned through `event::userdata`.\n     */\n    __wasi_userdata_t userdata;\n\n    /**\n     * The type of the event to which to subscribe.\n     */\n    __wasi_eventtype_t type;\n\n    /**\n     * The contents of the subscription.\n     */\n    __wasi_subscription_u_t u;\n\n} __wasi_subscription_t;\n\n_Static_assert(sizeof(__wasi_subscription_t) == 48, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_subscription_t) == 8, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_subscription_t, userdata) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_subscription_t, type) == 8, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_subscription_t, u) == 16, \"witx calculated offset\");\n\n/**\n * Exit code generated by a process when exiting.\n */\ntypedef uint32_t __wasi_exitcode_t;\n\n_Static_assert(sizeof(__wasi_exitcode_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_exitcode_t) == 4, \"witx calculated align\");\n\n/**\n * Signal condition.\n */\ntypedef uint8_t __wasi_signal_t;\n\n/**\n * No signal. Note that POSIX has special semantics for `kill(pid, 0)`,\n * so this value is reserved.\n */\n#define __WASI_SIGNAL_NONE (UINT8_C(0))\n\n/**\n * Hangup.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_HUP (UINT8_C(1))\n\n/**\n * Terminate interrupt signal.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_INT (UINT8_C(2))\n\n/**\n * Terminal quit signal.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_QUIT (UINT8_C(3))\n\n/**\n * Illegal instruction.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_ILL (UINT8_C(4))\n\n/**\n * Trace/breakpoint trap.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_TRAP (UINT8_C(5))\n\n/**\n * Process abort signal.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_ABRT (UINT8_C(6))\n\n/**\n * Access to an undefined portion of a memory object.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_BUS (UINT8_C(7))\n\n/**\n * Erroneous arithmetic operation.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_FPE (UINT8_C(8))\n\n/**\n * Kill.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_KILL (UINT8_C(9))\n\n/**\n * User-defined signal 1.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_USR1 (UINT8_C(10))\n\n/**\n * Invalid memory reference.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_SEGV (UINT8_C(11))\n\n/**\n * User-defined signal 2.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_USR2 (UINT8_C(12))\n\n/**\n * Write on a pipe with no one to read it.\n * Action: Ignored.\n */\n#define __WASI_SIGNAL_PIPE (UINT8_C(13))\n\n/**\n * Alarm clock.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_ALRM (UINT8_C(14))\n\n/**\n * Termination signal.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_TERM (UINT8_C(15))\n\n/**\n * Child process terminated, stopped, or continued.\n * Action: Ignored.\n */\n#define __WASI_SIGNAL_CHLD (UINT8_C(16))\n\n/**\n * Continue executing, if stopped.\n * Action: Continues executing, if stopped.\n */\n#define __WASI_SIGNAL_CONT (UINT8_C(17))\n\n/**\n * Stop executing.\n * Action: Stops executing.\n */\n#define __WASI_SIGNAL_STOP (UINT8_C(18))\n\n/**\n * Terminal stop signal.\n * Action: Stops executing.\n */\n#define __WASI_SIGNAL_TSTP (UINT8_C(19))\n\n/**\n * Background process attempting read.\n * Action: Stops executing.\n */\n#define __WASI_SIGNAL_TTIN (UINT8_C(20))\n\n/**\n * Background process attempting write.\n * Action: Stops executing.\n */\n#define __WASI_SIGNAL_TTOU (UINT8_C(21))\n\n/**\n * High bandwidth data is available at a socket.\n * Action: Ignored.\n */\n#define __WASI_SIGNAL_URG (UINT8_C(22))\n\n/**\n * CPU time limit exceeded.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_XCPU (UINT8_C(23))\n\n/**\n * File size limit exceeded.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_XFSZ (UINT8_C(24))\n\n/**\n * Virtual timer expired.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_VTALRM (UINT8_C(25))\n\n/**\n * Profiling timer expired.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_PROF (UINT8_C(26))\n\n/**\n * Window changed.\n * Action: Ignored.\n */\n#define __WASI_SIGNAL_WINCH (UINT8_C(27))\n\n/**\n * I/O possible.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_POLL (UINT8_C(28))\n\n/**\n * Power failure.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_PWR (UINT8_C(29))\n\n/**\n * Bad system call.\n * Action: Terminates the process.\n */\n#define __WASI_SIGNAL_SYS (UINT8_C(30))\n\n_Static_assert(sizeof(__wasi_signal_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_signal_t) == 1, \"witx calculated align\");\n\n/**\n * Flags provided to `sock_recv`.\n */\ntypedef uint16_t __wasi_riflags_t;\n\n/**\n * Returns the message without removing it from the socket's receive queue.\n */\n#define __WASI_RIFLAGS_RECV_PEEK (UINT16_C(1))\n\n/**\n * On byte-stream sockets, block until the full amount of data can be returned.\n */\n#define __WASI_RIFLAGS_RECV_WAITALL (UINT16_C(2))\n\n_Static_assert(sizeof(__wasi_riflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_riflags_t) == 2, \"witx calculated align\");\n\n/**\n * Flags returned by `sock_recv`.\n */\ntypedef uint16_t __wasi_roflags_t;\n\n/**\n * Returned by `sock_recv`: Message data has been truncated.\n */\n#define __WASI_ROFLAGS_RECV_DATA_TRUNCATED (UINT16_C(1))\n\n_Static_assert(sizeof(__wasi_roflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_roflags_t) == 2, \"witx calculated align\");\n\n/**\n * Flags provided to `sock_send`. As there are currently no flags\n * defined, it must be set to zero.\n */\ntypedef uint16_t __wasi_siflags_t;\n\n_Static_assert(sizeof(__wasi_siflags_t) == 2, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_siflags_t) == 2, \"witx calculated align\");\n\n/**\n * Which channels on a socket to shut down.\n */\ntypedef uint8_t __wasi_sdflags_t;\n\n/**\n * Disables further receive operations.\n */\n#define __WASI_SDFLAGS_RD (UINT8_C(1))\n\n/**\n * Disables further send operations.\n */\n#define __WASI_SDFLAGS_WR (UINT8_C(2))\n\n_Static_assert(sizeof(__wasi_sdflags_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_sdflags_t) == 1, \"witx calculated align\");\n\n/**\n * Identifiers for preopened capabilities.\n */\ntypedef uint8_t __wasi_preopentype_t;\n\n/**\n * A pre-opened directory.\n */\n#define __WASI_PREOPENTYPE_DIR (UINT8_C(0))\n\n_Static_assert(sizeof(__wasi_preopentype_t) == 1, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_preopentype_t) == 1, \"witx calculated align\");\n\n/**\n * The contents of a $prestat when type is `preopentype::dir`.\n */\ntypedef struct __wasi_prestat_dir_t {\n    /**\n     * The length of the directory name for use with `fd_prestat_dir_name`.\n     */\n    __wasi_size_t pr_name_len;\n\n} __wasi_prestat_dir_t;\n\n_Static_assert(sizeof(__wasi_prestat_dir_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_prestat_dir_t) == 4, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_prestat_dir_t, pr_name_len) == 0, \"witx calculated offset\");\n\n/**\n * The contents of an $prestat.\n */\ntypedef union __wasi_prestat_u_t {\n    /**\n     * When type is `preopentype::dir`:\n     */\n    __wasi_prestat_dir_t dir;\n\n} __wasi_prestat_u_t;\n\n_Static_assert(sizeof(__wasi_prestat_u_t) == 4, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_prestat_u_t) == 4, \"witx calculated align\");\n\n/**\n * Information about a pre-opened capability.\n */\ntypedef struct __wasi_prestat_t {\n    /**\n     * The type of the pre-opened capability.\n     */\n    __wasi_preopentype_t pr_type;\n\n    /**\n     * The contents of the information.\n     */\n    __wasi_prestat_u_t u;\n\n} __wasi_prestat_t;\n\n_Static_assert(sizeof(__wasi_prestat_t) == 8, \"witx calculated size\");\n_Static_assert(_Alignof(__wasi_prestat_t) == 4, \"witx calculated align\");\n_Static_assert(offsetof(__wasi_prestat_t, pr_type) == 0, \"witx calculated offset\");\n_Static_assert(offsetof(__wasi_prestat_t, u) == 4, \"witx calculated offset\");\n\n/**\n * @defgroup wasi_snapshot_preview1\n * @{\n */\n\n/**\n * Read command-line argument data.\n * The size of the array should match that returned by `args_sizes_get`\n */\n__wasi_errno_t __wasi_args_get(\n    uint8_t * * argv,\n\n    uint8_t * argv_buf\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"args_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Return command-line argument data sizes.\n */\n__wasi_errno_t __wasi_args_sizes_get(\n    /**\n     * The number of arguments.\n     */\n    __wasi_size_t *argc,\n    /**\n     * The size of the argument string data.\n     */\n    __wasi_size_t *argv_buf_size\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"args_sizes_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Read environment variable data.\n * The sizes of the buffers should match that returned by `environ_sizes_get`.\n */\n__wasi_errno_t __wasi_environ_get(\n    uint8_t * * environ,\n\n    uint8_t * environ_buf\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"environ_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Return command-line argument data sizes.\n */\n__wasi_errno_t __wasi_environ_sizes_get(\n    /**\n     * The number of arguments.\n     */\n    __wasi_size_t *argc,\n    /**\n     * The size of the argument string data.\n     */\n    __wasi_size_t *argv_buf_size\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"environ_sizes_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Return the resolution of a clock.\n * Implementations are required to provide a non-zero value for supported clocks. For unsupported clocks,\n * return `errno::inval`.\n * Note: This is similar to `clock_getres` in POSIX.\n */\n__wasi_errno_t __wasi_clock_res_get(\n    /**\n     * The clock for which to return the resolution.\n     */\n    __wasi_clockid_t id,\n\n    /**\n     * The resolution of the clock.\n     */\n    __wasi_timestamp_t *resolution\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"clock_res_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Return the time value of a clock.\n * Note: This is similar to `clock_gettime` in POSIX.\n */\n__wasi_errno_t __wasi_clock_time_get(\n    /**\n     * The clock for which to return the time.\n     */\n    __wasi_clockid_t id,\n\n    /**\n     * The maximum lag (exclusive) that the returned time value may have, compared to its actual value.\n     */\n    __wasi_timestamp_t precision,\n\n    /**\n     * The time value of the clock.\n     */\n    __wasi_timestamp_t *time\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"clock_time_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Provide file advisory information on a file descriptor.\n * Note: This is similar to `posix_fadvise` in POSIX.\n */\n__wasi_errno_t __wasi_fd_advise(\n    __wasi_fd_t fd,\n\n    /**\n     * The offset within the file to which the advisory applies.\n     */\n    __wasi_filesize_t offset,\n\n    /**\n     * The length of the region to which the advisory applies.\n     */\n    __wasi_filesize_t len,\n\n    /**\n     * The advice.\n     */\n    __wasi_advice_t advice\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_advise\"),\n    __warn_unused_result__\n));\n\n/**\n * Force the allocation of space in a file.\n * Note: This is similar to `posix_fallocate` in POSIX.\n */\n__wasi_errno_t __wasi_fd_allocate(\n    __wasi_fd_t fd,\n\n    /**\n     * The offset at which to start the allocation.\n     */\n    __wasi_filesize_t offset,\n\n    /**\n     * The length of the area that is allocated.\n     */\n    __wasi_filesize_t len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_allocate\"),\n    __warn_unused_result__\n));\n\n/**\n * Close a file descriptor.\n * Note: This is similar to `close` in POSIX.\n */\n__wasi_errno_t __wasi_fd_close(\n    __wasi_fd_t fd\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_close\"),\n    __warn_unused_result__\n));\n\n/**\n * Synchronize the data of a file to disk.\n * Note: This is similar to `fdatasync` in POSIX.\n */\n__wasi_errno_t __wasi_fd_datasync(\n    __wasi_fd_t fd\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_datasync\"),\n    __warn_unused_result__\n));\n\n/**\n * Get the attributes of a file descriptor.\n * Note: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields.\n */\n__wasi_errno_t __wasi_fd_fdstat_get(\n    __wasi_fd_t fd,\n\n    /**\n     * The buffer where the file descriptor's attributes are stored.\n     */\n    __wasi_fdstat_t *stat\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_fdstat_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Adjust the flags associated with a file descriptor.\n * Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX.\n */\n__wasi_errno_t __wasi_fd_fdstat_set_flags(\n    __wasi_fd_t fd,\n\n    /**\n     * The desired values of the file descriptor flags.\n     */\n    __wasi_fdflags_t flags\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_fdstat_set_flags\"),\n    __warn_unused_result__\n));\n\n/**\n * Adjust the rights associated with a file descriptor.\n * This can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights\n */\n__wasi_errno_t __wasi_fd_fdstat_set_rights(\n    __wasi_fd_t fd,\n\n    /**\n     * The desired rights of the file descriptor.\n     */\n    __wasi_rights_t fs_rights_base,\n\n    __wasi_rights_t fs_rights_inheriting\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_fdstat_set_rights\"),\n    __warn_unused_result__\n));\n\n/**\n * Return the attributes of an open file.\n */\n__wasi_errno_t __wasi_fd_filestat_get(\n    __wasi_fd_t fd,\n\n    /**\n     * The buffer where the file's attributes are stored.\n     */\n    __wasi_filestat_t *buf\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_filestat_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros.\n * Note: This is similar to `ftruncate` in POSIX.\n */\n__wasi_errno_t __wasi_fd_filestat_set_size(\n    __wasi_fd_t fd,\n\n    /**\n     * The desired file size.\n     */\n    __wasi_filesize_t size\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_filestat_set_size\"),\n    __warn_unused_result__\n));\n\n/**\n * Adjust the timestamps of an open file or directory.\n * Note: This is similar to `futimens` in POSIX.\n */\n__wasi_errno_t __wasi_fd_filestat_set_times(\n    __wasi_fd_t fd,\n\n    /**\n     * The desired values of the data access timestamp.\n     */\n    __wasi_timestamp_t atim,\n\n    /**\n     * The desired values of the data modification timestamp.\n     */\n    __wasi_timestamp_t mtim,\n\n    /**\n     * A bitmask indicating which timestamps to adjust.\n     */\n    __wasi_fstflags_t fst_flags\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_filestat_set_times\"),\n    __warn_unused_result__\n));\n\n/**\n * Read from a file descriptor, without using and updating the file descriptor's offset.\n * Note: This is similar to `preadv` in POSIX.\n */\n__wasi_errno_t __wasi_fd_pread(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors in which to store data.\n     */\n    const __wasi_iovec_t *iovs,\n\n    /**\n     * The length of the array pointed to by `iovs`.\n     */\n    size_t iovs_len,\n\n    /**\n     * The offset within the file at which to read.\n     */\n    __wasi_filesize_t offset,\n\n    /**\n     * The number of bytes read.\n     */\n    __wasi_size_t *nread\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_pread\"),\n    __warn_unused_result__\n));\n\n/**\n * Return a description of the given preopened file descriptor.\n */\n__wasi_errno_t __wasi_fd_prestat_get(\n    __wasi_fd_t fd,\n\n    /**\n     * The buffer where the description is stored.\n     */\n    __wasi_prestat_t *buf\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_prestat_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Return a description of the given preopened file descriptor.\n */\n__wasi_errno_t __wasi_fd_prestat_dir_name(\n    __wasi_fd_t fd,\n\n    /**\n     * A buffer into which to write the preopened directory name.\n     */\n    uint8_t * path,\n\n    __wasi_size_t path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_prestat_dir_name\"),\n    __warn_unused_result__\n));\n\n/**\n * Write to a file descriptor, without using and updating the file descriptor's offset.\n * Note: This is similar to `pwritev` in POSIX.\n */\n__wasi_errno_t __wasi_fd_pwrite(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors from which to retrieve data.\n     */\n    const __wasi_ciovec_t *iovs,\n\n    /**\n     * The length of the array pointed to by `iovs`.\n     */\n    size_t iovs_len,\n\n    /**\n     * The offset within the file at which to write.\n     */\n    __wasi_filesize_t offset,\n\n    /**\n     * The number of bytes written.\n     */\n    __wasi_size_t *nwritten\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_pwrite\"),\n    __warn_unused_result__\n));\n\n/**\n * Read from a file descriptor.\n * Note: This is similar to `readv` in POSIX.\n */\n__wasi_errno_t __wasi_fd_read(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors to which to store data.\n     */\n    const __wasi_iovec_t *iovs,\n\n    /**\n     * The length of the array pointed to by `iovs`.\n     */\n    size_t iovs_len,\n\n    /**\n     * The number of bytes read.\n     */\n    __wasi_size_t *nread\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_read\"),\n    __warn_unused_result__\n));\n\n/**\n * Read directory entries from a directory.\n * When successful, the contents of the output buffer consist of a sequence of\n * directory entries. Each directory entry consists of a dirent_t object,\n * followed by dirent_t::d_namlen bytes holding the name of the directory\n * entry.\n * This function fills the output buffer as much as possible, potentially\n * truncating the last directory entry. This allows the caller to grow its\n * read buffer size in case it's too small to fit a single large directory\n * entry, or skip the oversized directory entry.\n */\n__wasi_errno_t __wasi_fd_readdir(\n    __wasi_fd_t fd,\n\n    /**\n     * The buffer where directory entries are stored\n     */\n    uint8_t * buf,\n\n    __wasi_size_t buf_len,\n\n    /**\n     * The location within the directory to start reading\n     */\n    __wasi_dircookie_t cookie,\n\n    /**\n     * The number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached.\n     */\n    __wasi_size_t *bufused\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_readdir\"),\n    __warn_unused_result__\n));\n\n/**\n * Atomically replace a file descriptor by renumbering another file descriptor.\n * Due to the strong focus on thread safety, this environment does not provide\n * a mechanism to duplicate or renumber a file descriptor to an arbitrary\n * number, like `dup2()`. This would be prone to race conditions, as an actual\n * file descriptor with the same number could be allocated by a different\n * thread at the same time.\n * This function provides a way to atomically renumber file descriptors, which\n * would disappear if `dup2()` were to be removed entirely.\n */\n__wasi_errno_t __wasi_fd_renumber(\n    __wasi_fd_t fd,\n\n    /**\n     * The file descriptor to overwrite.\n     */\n    __wasi_fd_t to\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_renumber\"),\n    __warn_unused_result__\n));\n\n/**\n * Move the offset of a file descriptor.\n * Note: This is similar to `lseek` in POSIX.\n */\n__wasi_errno_t __wasi_fd_seek(\n    __wasi_fd_t fd,\n\n    /**\n     * The number of bytes to move.\n     */\n    __wasi_filedelta_t offset,\n\n    /**\n     * The base from which the offset is relative.\n     */\n    __wasi_whence_t whence,\n\n    /**\n     * The new offset of the file descriptor, relative to the start of the file.\n     */\n    __wasi_filesize_t *newoffset\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_seek\"),\n    __warn_unused_result__\n));\n\n/**\n * Synchronize the data and metadata of a file to disk.\n * Note: This is similar to `fsync` in POSIX.\n */\n__wasi_errno_t __wasi_fd_sync(\n    __wasi_fd_t fd\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_sync\"),\n    __warn_unused_result__\n));\n\n/**\n * Return the current offset of a file descriptor.\n * Note: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX.\n */\n__wasi_errno_t __wasi_fd_tell(\n    __wasi_fd_t fd,\n\n    /**\n     * The current offset of the file descriptor, relative to the start of the file.\n     */\n    __wasi_filesize_t *offset\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_tell\"),\n    __warn_unused_result__\n));\n\n/**\n * Write to a file descriptor.\n * Note: This is similar to `writev` in POSIX.\n */\n__wasi_errno_t __wasi_fd_write(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors from which to retrieve data.\n     */\n    const __wasi_ciovec_t *iovs,\n\n    /**\n     * The length of the array pointed to by `iovs`.\n     */\n    size_t iovs_len,\n\n    /**\n     * The number of bytes written.\n     */\n    __wasi_size_t *nwritten\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"fd_write\"),\n    __warn_unused_result__\n));\n\n/**\n * Create a directory.\n * Note: This is similar to `mkdirat` in POSIX.\n */\n__wasi_errno_t __wasi_path_create_directory(\n    __wasi_fd_t fd,\n\n    /**\n     * The path at which to create the directory.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_create_directory\"),\n    __warn_unused_result__\n));\n\n/**\n * Return the attributes of a file or directory.\n * Note: This is similar to `stat` in POSIX.\n */\n__wasi_errno_t __wasi_path_filestat_get(\n    __wasi_fd_t fd,\n\n    /**\n     * Flags determining the method of how the path is resolved.\n     */\n    __wasi_lookupflags_t flags,\n\n    /**\n     * The path of the file or directory to inspect.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len,\n\n    /**\n     * The buffer where the file's attributes are stored.\n     */\n    __wasi_filestat_t *buf\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_filestat_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Adjust the timestamps of a file or directory.\n * Note: This is similar to `utimensat` in POSIX.\n */\n__wasi_errno_t __wasi_path_filestat_set_times(\n    __wasi_fd_t fd,\n\n    /**\n     * Flags determining the method of how the path is resolved.\n     */\n    __wasi_lookupflags_t flags,\n\n    /**\n     * The path of the file or directory to operate on.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len,\n\n    /**\n     * The desired values of the data access timestamp.\n     */\n    __wasi_timestamp_t atim,\n\n    /**\n     * The desired values of the data modification timestamp.\n     */\n    __wasi_timestamp_t mtim,\n\n    /**\n     * A bitmask indicating which timestamps to adjust.\n     */\n    __wasi_fstflags_t fst_flags\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_filestat_set_times\"),\n    __warn_unused_result__\n));\n\n/**\n * Create a hard link.\n * Note: This is similar to `linkat` in POSIX.\n */\n__wasi_errno_t __wasi_path_link(\n    __wasi_fd_t old_fd,\n\n    /**\n     * Flags determining the method of how the path is resolved.\n     */\n    __wasi_lookupflags_t old_flags,\n\n    /**\n     * The source path from which to link.\n     */\n    const char *old_path,\n\n    /**\n     * The length of the buffer pointed to by `old_path`.\n     */\n    size_t old_path_len,\n\n    /**\n     * The working directory at which the resolution of the new path starts.\n     */\n    __wasi_fd_t new_fd,\n\n    /**\n     * The destination path at which to create the hard link.\n     */\n    const char *new_path,\n\n    /**\n     * The length of the buffer pointed to by `new_path`.\n     */\n    size_t new_path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_link\"),\n    __warn_unused_result__\n));\n\n/**\n * Open a file or directory.\n * The returned file descriptor is not guaranteed to be the lowest-numbered\n * file descriptor not currently open; it is randomized to prevent\n * applications from depending on making assumptions about indexes, since this\n * is error-prone in multi-threaded contexts. The returned file descriptor is\n * guaranteed to be less than 2**31.\n * Note: This is similar to `openat` in POSIX.\n */\n__wasi_errno_t __wasi_path_open(\n    __wasi_fd_t fd,\n\n    /**\n     * Flags determining the method of how the path is resolved.\n     */\n    __wasi_lookupflags_t dirflags,\n\n    /**\n     * The relative path of the file or directory to open, relative to the\n     * `path_open::fd` directory.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len,\n\n    /**\n     * The method by which to open the file.\n     */\n    __wasi_oflags_t oflags,\n\n    /**\n     * The initial rights of the newly created file descriptor. The\n     * implementation is allowed to return a file descriptor with fewer rights\n     * than specified, if and only if those rights do not apply to the type of\n     * file being opened.\n     * The *base* rights are rights that will apply to operations using the file\n     * descriptor itself, while the *inheriting* rights are rights that apply to\n     * file descriptors derived from it.\n     */\n    __wasi_rights_t fs_rights_base,\n\n    __wasi_rights_t fs_rights_inherting,\n\n    __wasi_fdflags_t fdflags,\n\n    /**\n     * The file descriptor of the file that has been opened.\n     */\n    __wasi_fd_t *opened_fd\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_open\"),\n    __warn_unused_result__\n));\n\n/**\n * Read the contents of a symbolic link.\n * Note: This is similar to `readlinkat` in POSIX.\n */\n__wasi_errno_t __wasi_path_readlink(\n    __wasi_fd_t fd,\n\n    /**\n     * The path of the symbolic link from which to read.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len,\n\n    /**\n     * The buffer to which to write the contents of the symbolic link.\n     */\n    uint8_t * buf,\n\n    __wasi_size_t buf_len,\n\n    /**\n     * The number of bytes placed in the buffer.\n     */\n    __wasi_size_t *bufused\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_readlink\"),\n    __warn_unused_result__\n));\n\n/**\n * Remove a directory.\n * Return `errno::notempty` if the directory is not empty.\n * Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.\n */\n__wasi_errno_t __wasi_path_remove_directory(\n    __wasi_fd_t fd,\n\n    /**\n     * The path to a directory to remove.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_remove_directory\"),\n    __warn_unused_result__\n));\n\n/**\n * Rename a file or directory.\n * Note: This is similar to `renameat` in POSIX.\n */\n__wasi_errno_t __wasi_path_rename(\n    __wasi_fd_t fd,\n\n    /**\n     * The source path of the file or directory to rename.\n     */\n    const char *old_path,\n\n    /**\n     * The length of the buffer pointed to by `old_path`.\n     */\n    size_t old_path_len,\n\n    /**\n     * The working directory at which the resolution of the new path starts.\n     */\n    __wasi_fd_t new_fd,\n\n    /**\n     * The destination path to which to rename the file or directory.\n     */\n    const char *new_path,\n\n    /**\n     * The length of the buffer pointed to by `new_path`.\n     */\n    size_t new_path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_rename\"),\n    __warn_unused_result__\n));\n\n/**\n * Create a symbolic link.\n * Note: This is similar to `symlinkat` in POSIX.\n */\n__wasi_errno_t __wasi_path_symlink(\n    /**\n     * The contents of the symbolic link.\n     */\n    const char *old_path,\n\n    /**\n     * The length of the buffer pointed to by `old_path`.\n     */\n    size_t old_path_len,\n\n    __wasi_fd_t fd,\n\n    /**\n     * The destination path at which to create the symbolic link.\n     */\n    const char *new_path,\n\n    /**\n     * The length of the buffer pointed to by `new_path`.\n     */\n    size_t new_path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_symlink\"),\n    __warn_unused_result__\n));\n\n/**\n * Unlink a file.\n * Return `errno::isdir` if the path refers to a directory.\n * Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.\n */\n__wasi_errno_t __wasi_path_unlink_file(\n    __wasi_fd_t fd,\n\n    /**\n     * The path to a file to unlink.\n     */\n    const char *path,\n\n    /**\n     * The length of the buffer pointed to by `path`.\n     */\n    size_t path_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"path_unlink_file\"),\n    __warn_unused_result__\n));\n\n/**\n * Concurrently poll for the occurrence of a set of events.\n */\n__wasi_errno_t __wasi_poll_oneoff(\n    /**\n     * The events to which to subscribe.\n     */\n    const __wasi_subscription_t * in,\n\n    /**\n     * The events that have occurred.\n     */\n    __wasi_event_t * out,\n\n    /**\n     * Both the number of subscriptions and events.\n     */\n    __wasi_size_t nsubscriptions,\n\n    /**\n     * The number of events stored.\n     */\n    __wasi_size_t *nevents\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"poll_oneoff\"),\n    __warn_unused_result__\n));\n\n/**\n * Terminate the process normally. An exit code of 0 indicates successful\n * termination of the program. The meanings of other values is dependent on\n * the environment.\n */\n_Noreturn void __wasi_proc_exit(\n    /**\n     * The exit code returned by the process.\n     */\n    __wasi_exitcode_t rval\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"proc_exit\"))\n));\n\n/**\n * Send a signal to the process of the calling thread.\n * Note: This is similar to `raise` in POSIX.\n */\n__wasi_errno_t __wasi_proc_raise(\n    /**\n     * The signal condition to trigger.\n     */\n    __wasi_signal_t sig\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"proc_raise\"),\n    __warn_unused_result__\n));\n\n/**\n * Temporarily yield execution of the calling thread.\n * Note: This is similar to `sched_yield` in POSIX.\n */\n__wasi_errno_t __wasi_sched_yield(\n    void\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"sched_yield\"),\n    __warn_unused_result__\n));\n\n/**\n * Write high-quality random data into a buffer.\n * This function blocks when the implementation is unable to immediately\n * provide sufficient high-quality random data.\n * This function may execute slowly, so when large mounts of random data are\n * required, it's advisable to use this function to seed a pseudo-random\n * number generator, rather than to provide the random data directly.\n */\n__wasi_errno_t __wasi_random_get(\n    /**\n     * The buffer to fill with random data.\n     */\n    uint8_t * buf,\n\n    __wasi_size_t buf_len\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"random_get\"),\n    __warn_unused_result__\n));\n\n/**\n * Receive a message from a socket.\n * Note: This is similar to `recv` in POSIX, though it also supports reading\n * the data into multiple buffers in the manner of `readv`.\n */\n__wasi_errno_t __wasi_sock_recv(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors to which to store data.\n     */\n    const __wasi_iovec_t *ri_data,\n\n    /**\n     * The length of the array pointed to by `ri_data`.\n     */\n    size_t ri_data_len,\n\n    /**\n     * Message flags.\n     */\n    __wasi_riflags_t ri_flags,\n\n    /**\n     * Number of bytes stored in ri_data.\n     */\n    __wasi_size_t *ro_datalen,\n    /**\n     * Message flags.\n     */\n    __wasi_roflags_t *ro_flags\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"sock_recv\"),\n    __warn_unused_result__\n));\n\n/**\n * Send a message on a socket.\n * Note: This is similar to `send` in POSIX, though it also supports writing\n * the data from multiple buffers in the manner of `writev`.\n */\n__wasi_errno_t __wasi_sock_send(\n    __wasi_fd_t fd,\n\n    /**\n     * List of scatter/gather vectors to which to retrieve data\n     */\n    const __wasi_ciovec_t *si_data,\n\n    /**\n     * The length of the array pointed to by `si_data`.\n     */\n    size_t si_data_len,\n\n    /**\n     * Message flags.\n     */\n    __wasi_siflags_t si_flags,\n\n    /**\n     * Number of bytes transmitted.\n     */\n    __wasi_size_t *so_datalen\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // __import_name__(\"sock_send\"),\n    __warn_unused_result__\n));\n\n/**\n * Shut down socket send and receive channels.\n * Note: This is similar to `shutdown` in POSIX.\n */\n__wasi_errno_t __wasi_sock_shutdown(\n    __wasi_fd_t fd,\n\n    /**\n     * Which channels on the socket to shut down.\n     */\n    __wasi_sdflags_t how\n) __attribute__((\n    // __import_module__(\"wasi_snapshot_preview1\"),\n    // // __import_name__(\"sock_shutdown\"),\n    __warn_unused_result__\n));\n\n/** @} */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "is_header": true, "available_types": []}}, "include_graph": {}, "reverse_graph": {}, "symbol_definitions": {}, "symbol_usages": {}}